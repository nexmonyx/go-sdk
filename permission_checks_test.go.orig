package nexmonyx

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// TestPermissions_UnauthorizedResponse tests handling of 401 Unauthorized responses
func TestPermissions_UnauthorizedResponse(t *testing.T) {
	tests := []struct {
		name           string
		httpStatus     int
		responseBody   map[string]interface{}
		operation      string
		expectErrorType string
	}{
		{
			name:       "401 unauthorized - missing token",
			httpStatus: http.StatusUnauthorized,
			responseBody: map[string]interface{}{
				"error": "Authentication required",
			},
			operation:      "list_servers",
			expectErrorType: "401",
		},
		{
			name:       "401 unauthorized - invalid token",
			httpStatus: http.StatusUnauthorized,
			responseBody: map[string]interface{}{
				"error": "Invalid authentication token",
			},
			operation:      "get_server",
			expectErrorType: "401",
		},
		{
			name:       "401 unauthorized - expired token",
			httpStatus: http.StatusUnauthorized,
			responseBody: map[string]interface{}{
				"error": "Token has expired",
			},
			operation:      "create_server",
			expectErrorType: "401",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(tt.httpStatus)
				json.NewEncoder(w).Encode(tt.responseBody)
			}))
			defer server.Close()

			client, err := NewClient(&Config{
				BaseURL:    server.URL,
				Auth:       AuthConfig{Token: "invalid-token"},
				RetryCount: 0,
			})
			require.NoError(t, err)

			var apiErr error
			switch tt.operation {
			case "list_servers":
				_, _, apiErr = client.Servers.List(context.Background(), nil)
			case "get_server":
				_, apiErr = client.Servers.Get(context.Background(), "server-uuid")
			case "create_server":
				_, apiErr = client.Servers.Register(context.Background(), "new-server", 1)
			}

			assert.Error(t, apiErr)
			if apiErr != nil {
				// Note: SDK may not include specific status codes in error messages
			}
		})
	}
}

// TestPermissions_ForbiddenResponse tests handling of 403 Forbidden responses
func TestPermissions_ForbiddenResponse(t *testing.T) {
	tests := []struct {
		name         string
		httpStatus   int
		responseBody map[string]interface{}
		operation    string
		expectError  string
	}{
		{
			name:       "403 forbidden - insufficient permissions",
			httpStatus: http.StatusForbidden,
			responseBody: map[string]interface{}{
				"error": "Insufficient permissions to perform this action",
			},
			operation:   "delete_organization",
			expectError: "403",
		},
		{
			name:       "403 forbidden - role restriction",
			httpStatus: http.StatusForbidden,
			responseBody: map[string]interface{}{
				"error": "This action requires admin role",
			},
			operation:   "update_billing",
			expectError: "403",
		},
		{
			name:       "403 forbidden - resource access denied",
			httpStatus: http.StatusForbidden,
			responseBody: map[string]interface{}{
				"error": "You do not have permission to access this resource",
			},
			operation:   "access_server",
			expectError: "403",
		},
		{
			name:       "403 forbidden - organization isolation",
			httpStatus: http.StatusForbidden,
			responseBody: map[string]interface{}{
				"error": "Resource belongs to a different organization",
			},
			operation:   "cross_org_access",
			expectError: "403",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(tt.httpStatus)
				json.NewEncoder(w).Encode(tt.responseBody)
			}))
			defer server.Close()

			client, err := NewClient(&Config{
				BaseURL:    server.URL,
				Auth:       AuthConfig{Token: "test-token"},
				RetryCount: 0,
			})
			require.NoError(t, err)

			var apiErr error
			switch tt.operation {
			case "delete_organization":
				apiErr = client.Organizations.Delete(context.Background(), "org-uuid")
			case "update_billing":
				apiErr = client.Billing.UpdatePaymentMethod(context.Background(), "org-uuid", &PaymentMethod{})
			case "access_server":
				_, apiErr = client.Servers.Get(context.Background(), "server-uuid")
			case "cross_org_access":
				_, _, apiErr = client.Organizations.GetUsers(context.Background(), "other-org-uuid", nil)
			}

			assert.Error(t, apiErr)
			if apiErr != nil {
				// Note: SDK may not include specific status codes in error messages
			}
		})
	}
}

// TestPermissions_APIKeyScopes tests handling of scope-restricted API keys
func TestPermissions_APIKeyScopes(t *testing.T) {
	tests := []struct {
		name           string
		keyScopes      []string
		operation      string
		httpStatus     int
		expectSuccess  bool
		expectErrorMsg string
	}{
		{
			name:          "read-only key - list operation success",
			keyScopes:     []string{"servers:read"},
			operation:     "list_servers",
			httpStatus:    http.StatusOK,
			expectSuccess: true,
		},
		{
			name:           "read-only key - write operation forbidden",
			keyScopes:      []string{"servers:read"},
			operation:      "create_server",
			httpStatus:     http.StatusForbidden,
			expectSuccess:  false,
			expectErrorMsg: "403",
		},
		{
			name:          "write key - write operation success",
			keyScopes:     []string{"servers:write"},
			operation:     "create_server",
			httpStatus:    http.StatusOK,
			expectSuccess: true,
		},
		{
			name:           "metrics key - billing access forbidden",
			keyScopes:      []string{"metrics:write"},
			operation:      "view_billing",
			httpStatus:     http.StatusForbidden,
			expectSuccess:  false,
			expectErrorMsg: "403",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if tt.httpStatus == http.StatusForbidden {
					w.WriteHeader(http.StatusForbidden)
					json.NewEncoder(w).Encode(map[string]interface{}{
						"error": "API key does not have required scope",
					})
					return
				}

				w.WriteHeader(http.StatusOK)
				json.NewEncoder(w).Encode(map[string]interface{}{
					"data": map[string]interface{}{"uuid": "resource-uuid"},
				})
			}))
			defer server.Close()

			client, err := NewClient(&Config{
				BaseURL:    server.URL,
				Auth:       AuthConfig{APIKey: "test-api-key"},
				RetryCount: 0,
			})
			require.NoError(t, err)

			var apiErr error
			switch tt.operation {
			case "list_servers":
				_, _, apiErr = client.Servers.List(context.Background(), nil)
			case "create_server":
				_, apiErr = client.Servers.Register(context.Background(), "new-server", 1)
			case "view_billing":
				_, apiErr = client.Billing.GetSubscription(context.Background(), "org-uuid")
			}

			if tt.expectSuccess {
				assert.NoError(t, apiErr)
			} else {
				assert.Error(t, apiErr)
				if tt.expectErrorMsg != "" && apiErr != nil {
					// Note: SDK may not include specific status codes in error messages
				}
			}
		})
	}
}

// TestPermissions_OrganizationIsolation tests handling of cross-organization access attempts
func TestPermissions_OrganizationIsolation(t *testing.T) {
	tests := []struct {
		name           string
		resourceOrgID  string
		httpStatus     int
		operation      string
		expectSuccess  bool
	}{
		{
			name:          "same organization - access granted",
			resourceOrgID: "org-123",
			httpStatus:    http.StatusOK,
			operation:     "get_server",
			expectSuccess: true,
		},
		{
			name:          "different organization - not found",
			resourceOrgID: "org-456",
			httpStatus:    http.StatusNotFound,
			operation:     "get_server",
			expectSuccess: false,
		},
		{
			name:          "cross-org write - forbidden",
			resourceOrgID: "org-789",
			httpStatus:    http.StatusForbidden,
			operation:     "update_server",
			expectSuccess: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if tt.httpStatus != http.StatusOK {
					w.WriteHeader(tt.httpStatus)
					json.NewEncoder(w).Encode(map[string]interface{}{
						"error": "Resource not found or access denied",
					})
					return
				}

				w.WriteHeader(http.StatusOK)
				json.NewEncoder(w).Encode(map[string]interface{}{
					"data": map[string]interface{}{
						"uuid":            "server-uuid",
						"organization_id": tt.resourceOrgID,
					},
				})
			}))
			defer server.Close()

			client, err := NewClient(&Config{
				BaseURL:    server.URL,
				Auth:       AuthConfig{Token: "test-token"},
				RetryCount: 0,
			})
			require.NoError(t, err)

			var apiErr error
			switch tt.operation {
			case "get_server":
				_, apiErr = client.Servers.Get(context.Background(), "server-uuid")
			case "update_server":
				server := &Server{Hostname: "updated"}
				_, apiErr = client.Servers.Update(context.Background(), "server-uuid", server)
			}

			if tt.expectSuccess {
				assert.NoError(t, apiErr)
			} else {
				assert.Error(t, apiErr)
			}
		})
	}
}

// TestPermissions_ResourceOwnership tests handling of resource ownership checks
func TestPermissions_ResourceOwnership(t *testing.T) {
	tests := []struct {
		name          string
		ownerID       string
		accessorID    string
		httpStatus    int
		operation     string
		expectSuccess bool
	}{
		{
			name:          "owner can read resource",
			ownerID:       "user-123",
			accessorID:    "user-123",
			httpStatus:    http.StatusOK,
			operation:     "read",
			expectSuccess: true,
		},
		{
			name:          "non-owner cannot modify resource",
			ownerID:       "user-123",
			accessorID:    "user-456",
			httpStatus:    http.StatusForbidden,
			operation:     "update",
			expectSuccess: false,
		},
		{
			name:          "owner can delete resource",
			ownerID:       "user-789",
			accessorID:    "user-789",
			httpStatus:    http.StatusOK,
			operation:     "delete",
			expectSuccess: true,
		},
		{
			name:          "non-owner cannot delete resource",
			ownerID:       "user-123",
			accessorID:    "user-999",
			httpStatus:    http.StatusForbidden,
			operation:     "delete",
			expectSuccess: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if tt.httpStatus != http.StatusOK {
					w.WriteHeader(tt.httpStatus)
					json.NewEncoder(w).Encode(map[string]interface{}{
						"error": "You do not own this resource",
					})
					return
				}

				w.WriteHeader(http.StatusOK)
				json.NewEncoder(w).Encode(map[string]interface{}{
					"data": map[string]interface{}{
						"uuid":     "resource-uuid",
						"owner_id": tt.ownerID,
					},
				})
			}))
			defer server.Close()

			client, err := NewClient(&Config{
				BaseURL:    server.URL,
				Auth:       AuthConfig{Token: "test-token"},
				RetryCount: 0,
			})
			require.NoError(t, err)

			var apiErr error
			switch tt.operation {
			case "read":
				_, apiErr = client.Servers.Get(context.Background(), "server-uuid")
			case "update":
				alert := &Alert{Name: "Updated"}
				_, apiErr = client.Alerts.Update(context.Background(), "alert-uuid", alert)
			case "delete":
				apiErr = client.Alerts.Delete(context.Background(), "alert-uuid")
			}

			if tt.expectSuccess {
				assert.NoError(t, apiErr)
			} else {
				assert.Error(t, apiErr)
			}
		})
	}
}

// TestPermissions_RateLimitByRole tests handling of role-based rate limiting
func TestPermissions_RateLimitByRole(t *testing.T) {
	tests := []struct {
		name          string
		userRole      string
		requestNum    int
		rateLimit     int
		expectSuccess bool
	}{
		{
			name:          "admin - high rate limit",
			userRole:      "admin",
			requestNum:    5,
			rateLimit:     100,
			expectSuccess: true,
		},
		{
			name:          "member - moderate rate limit",
			userRole:      "member",
			requestNum:    15,
			rateLimit:     10,
			expectSuccess: false,
		},
		{
			name:          "viewer - low rate limit",
			userRole:      "viewer",
			requestNum:    6,
			rateLimit:     5,
			expectSuccess: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			requestCount := 0

			server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				requestCount++

				if requestCount > tt.rateLimit {
					w.WriteHeader(http.StatusTooManyRequests)
					json.NewEncoder(w).Encode(map[string]interface{}{
						"error": "Rate limit exceeded for your role",
					})
					return
				}

				w.WriteHeader(http.StatusOK)
				json.NewEncoder(w).Encode(map[string]interface{}{
					"data": []interface{}{},
				})
			}))
			defer server.Close()

			client, err := NewClient(&Config{
				BaseURL:    server.URL,
				Auth:       AuthConfig{Token: "test-token-" + tt.userRole},
				RetryCount: 0,
			})
			require.NoError(t, err)

			var finalErr error
			for i := 0; i < tt.requestNum; i++ {
				_, _, finalErr = client.Servers.List(context.Background(), nil)
			}

			if tt.expectSuccess {
				assert.NoError(t, finalErr)
			} else {
				assert.Error(t, finalErr)
				if finalErr != nil {
					// Note: SDK may not include specific status codes in error messages
				}
			}
		})
	}
}
