
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v2: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nexmonyx/go-sdk/v2/agent_versions.go (94.0%)</option>
				
				<option value="file1">github.com/nexmonyx/go-sdk/v2/alerts.go (92.9%)</option>
				
				<option value="file2">github.com/nexmonyx/go-sdk/v2/analytics.go (100.0%)</option>
				
				<option value="file3">github.com/nexmonyx/go-sdk/v2/api_keys.go (74.7%)</option>
				
				<option value="file4">github.com/nexmonyx/go-sdk/v2/audit.go (80.0%)</option>
				
				<option value="file5">github.com/nexmonyx/go-sdk/v2/auth_debug.go (0.0%)</option>
				
				<option value="file6">github.com/nexmonyx/go-sdk/v2/background_jobs.go (83.9%)</option>
				
				<option value="file7">github.com/nexmonyx/go-sdk/v2/billing.go (93.1%)</option>
				
				<option value="file8">github.com/nexmonyx/go-sdk/v2/billing_usage.go (84.8%)</option>
				
				<option value="file9">github.com/nexmonyx/go-sdk/v2/client.go (98.5%)</option>
				
				<option value="file10">github.com/nexmonyx/go-sdk/v2/clusters.go (88.2%)</option>
				
				<option value="file11">github.com/nexmonyx/go-sdk/v2/controllers.go (93.1%)</option>
				
				<option value="file12">github.com/nexmonyx/go-sdk/v2/database.go (100.0%)</option>
				
				<option value="file13">github.com/nexmonyx/go-sdk/v2/disk_io.go (100.0%)</option>
				
				<option value="file14">github.com/nexmonyx/go-sdk/v2/errors.go (100.0%)</option>
				
				<option value="file15">github.com/nexmonyx/go-sdk/v2/example_hardware.go (0.0%)</option>
				
				<option value="file16">github.com/nexmonyx/go-sdk/v2/examples/auth_debug/main.go (0.0%)</option>
				
				<option value="file17">github.com/nexmonyx/go-sdk/v2/examples/debug_heartbeat/main.go (0.0%)</option>
				
				<option value="file18">github.com/nexmonyx/go-sdk/v2/examples/filesystem_metrics/main.go (0.0%)</option>
				
				<option value="file19">github.com/nexmonyx/go-sdk/v2/examples/hardware_example.go (0.0%)</option>
				
				<option value="file20">github.com/nexmonyx/go-sdk/v2/examples/monitoring/advanced/main.go (0.0%)</option>
				
				<option value="file21">github.com/nexmonyx/go-sdk/v2/examples/monitoring/basic/main.go (0.0%)</option>
				
				<option value="file22">github.com/nexmonyx/go-sdk/v2/examples/monitoring_agent_keys/main.go (0.0%)</option>
				
				<option value="file23">github.com/nexmonyx/go-sdk/v2/examples/network_hardware_example.go (0.0%)</option>
				
				<option value="file24">github.com/nexmonyx/go-sdk/v2/examples/service_monitoring/main.go (0.0%)</option>
				
				<option value="file25">github.com/nexmonyx/go-sdk/v2/examples/temperature_power/main.go (0.0%)</option>
				
				<option value="file26">github.com/nexmonyx/go-sdk/v2/examples/test_metrics/main.go (0.0%)</option>
				
				<option value="file27">github.com/nexmonyx/go-sdk/v2/examples/unified_api_keys/main.go (0.0%)</option>
				
				<option value="file28">github.com/nexmonyx/go-sdk/v2/filesystem.go (0.0%)</option>
				
				<option value="file29">github.com/nexmonyx/go-sdk/v2/hardware_inventory.go (86.2%)</option>
				
				<option value="file30">github.com/nexmonyx/go-sdk/v2/health.go (87.5%)</option>
				
				<option value="file31">github.com/nexmonyx/go-sdk/v2/incidents.go (81.5%)</option>
				
				<option value="file32">github.com/nexmonyx/go-sdk/v2/ipmi.go (75.8%)</option>
				
				<option value="file33">github.com/nexmonyx/go-sdk/v2/metrics.go (90.0%)</option>
				
				<option value="file34">github.com/nexmonyx/go-sdk/v2/ml.go (88.7%)</option>
				
				<option value="file35">github.com/nexmonyx/go-sdk/v2/models.go (91.1%)</option>
				
				<option value="file36">github.com/nexmonyx/go-sdk/v2/monitoring.go (87.5%)</option>
				
				<option value="file37">github.com/nexmonyx/go-sdk/v2/monitoring_agent_keys.go (100.0%)</option>
				
				<option value="file38">github.com/nexmonyx/go-sdk/v2/network_hardware.go (98.4%)</option>
				
				<option value="file39">github.com/nexmonyx/go-sdk/v2/notifications.go (88.5%)</option>
				
				<option value="file40">github.com/nexmonyx/go-sdk/v2/organizations.go (93.3%)</option>
				
				<option value="file41">github.com/nexmonyx/go-sdk/v2/packages.go (85.0%)</option>
				
				<option value="file42">github.com/nexmonyx/go-sdk/v2/probe_alerts.go (87.8%)</option>
				
				<option value="file43">github.com/nexmonyx/go-sdk/v2/probe_controller_service.go (71.6%)</option>
				
				<option value="file44">github.com/nexmonyx/go-sdk/v2/probes_service.go (93.9%)</option>
				
				<option value="file45">github.com/nexmonyx/go-sdk/v2/providers.go (81.8%)</option>
				
				<option value="file46">github.com/nexmonyx/go-sdk/v2/quota_history.go (94.2%)</option>
				
				<option value="file47">github.com/nexmonyx/go-sdk/v2/reporting.go (90.6%)</option>
				
				<option value="file48">github.com/nexmonyx/go-sdk/v2/response.go (100.0%)</option>
				
				<option value="file49">github.com/nexmonyx/go-sdk/v2/safe_conversions.go (100.0%)</option>
				
				<option value="file50">github.com/nexmonyx/go-sdk/v2/search.go (96.6%)</option>
				
				<option value="file51">github.com/nexmonyx/go-sdk/v2/server_groups.go (75.8%)</option>
				
				<option value="file52">github.com/nexmonyx/go-sdk/v2/servers.go (61.2%)</option>
				
				<option value="file53">github.com/nexmonyx/go-sdk/v2/service_monitoring_api.go (0.0%)</option>
				
				<option value="file54">github.com/nexmonyx/go-sdk/v2/service_monitoring_helpers.go (74.3%)</option>
				
				<option value="file55">github.com/nexmonyx/go-sdk/v2/settings.go (87.5%)</option>
				
				<option value="file56">github.com/nexmonyx/go-sdk/v2/smart_health.go (100.0%)</option>
				
				<option value="file57">github.com/nexmonyx/go-sdk/v2/systemd.go (84.4%)</option>
				
				<option value="file58">github.com/nexmonyx/go-sdk/v2/tags.go (81.2%)</option>
				
				<option value="file59">github.com/nexmonyx/go-sdk/v2/tasks.go (87.5%)</option>
				
				<option value="file60">github.com/nexmonyx/go-sdk/v2/temperature_power_helpers.go (100.0%)</option>
				
				<option value="file61">github.com/nexmonyx/go-sdk/v2/test_helpers.go (0.0%)</option>
				
				<option value="file62">github.com/nexmonyx/go-sdk/v2/users.go (86.9%)</option>
				
				<option value="file63">github.com/nexmonyx/go-sdk/v2/utils.go (98.3%)</option>
				
				<option value="file64">github.com/nexmonyx/go-sdk/v2/vms.go (87.2%)</option>
				
				<option value="file65">github.com/nexmonyx/go-sdk/v2/websocket.go (75.3%)</option>
				
				<option value="file66">github.com/nexmonyx/go-sdk/v2/websocket_examples.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// RegisterVersion registers a new agent version
func (s *AgentVersionsService) RegisterVersion(ctx context.Context, req *AgentVersionRequest) error <span class="cov6" title="2">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/agent/versions",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// CreateVersion creates a new agent version and returns the created version
func (s *AgentVersionsService) CreateVersion(ctx context.Context, req *AgentVersionRequest) (*AgentVersion, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;AgentVersion{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/agent/versions",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if version, ok := resp.Data.(*AgentVersion); ok </span><span class="cov1" title="1">{
                return version, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetVersion retrieves an agent version by version string
func (s *AgentVersionsService) GetVersion(ctx context.Context, version string) (*AgentVersion, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;AgentVersion{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/agent/versions/%s", version),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if agentVersion, ok := resp.Data.(*AgentVersion); ok </span><span class="cov1" title="1">{
                return agentVersion, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ListVersions retrieves a list of agent versions
func (s *AgentVersionsService) ListVersions(ctx context.Context, opts *ListOptions) ([]*AgentVersion, *PaginationMeta, error) <span class="cov10" title="3">{
        var resp PaginatedResponse
        var versions []*AgentVersion
        resp.Data = &amp;versions

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/agent/versions",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov10" title="3">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov6" title="2">return versions, resp.Meta, nil</span>
}

// AddBinary adds a binary for an agent version
func (s *AgentVersionsService) AddBinary(ctx context.Context, versionID uint, req *AgentBinaryRequest) error <span class="cov6" title="2">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/agent/versions/%d/binaries", versionID),
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Admin Methods - these use the admin endpoints as seen in the register-version.sh script

// AdminCreateVersion creates a new agent version using admin endpoints
func (s *AgentVersionsService) AdminCreateVersion(ctx context.Context, version, notes string) (*AgentVersion, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;AgentVersion{}

        body := map[string]interface{}{
                "Version": version,
                "Notes": notes,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/admin/agent-versions",
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if agentVersion, ok := resp.Data.(*AgentVersion); ok </span><span class="cov1" title="1">{
                return agentVersion, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// AdminAddBinary adds a binary for an agent version using admin endpoints
func (s *AgentVersionsService) AdminAddBinary(ctx context.Context, versionID uint, req *AgentBinaryRequest) error <span class="cov6" title="2">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/admin/agent-versions/%d/binaries", versionID),
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// CreateAlert creates a new alert
func (s *AlertsService) Create(ctx context.Context, alert *Alert) (*Alert, error) <span class="cov10" title="4">{
        var resp StandardResponse
        resp.Data = &amp;Alert{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/alerts/rules",
                Body:   alert,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov8" title="3">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if created, ok := resp.Data.(*Alert); ok </span><span class="cov1" title="1">{
                return created, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetAlert retrieves an alert by ID
func (s *AlertsService) Get(ctx context.Context, id string) (*Alert, error) <span class="cov8" title="3">{
        var resp StandardResponse
        resp.Data = &amp;Alert{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/alerts/rules/%s", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if alert, ok := resp.Data.(*Alert); ok </span><span class="cov1" title="1">{
                return alert, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ListAlerts retrieves a list of alerts
func (s *AlertsService) List(ctx context.Context, opts *ListOptions) ([]*Alert, *PaginationMeta, error) <span class="cov10" title="4">{
        var resp PaginatedResponse
        var alerts []*Alert
        resp.Data = &amp;alerts

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/alerts/rules",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov5" title="2">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov10" title="4">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="3">return alerts, resp.Meta, nil</span>
}

// UpdateAlert updates an existing alert
func (s *AlertsService) Update(ctx context.Context, id string, alert *Alert) (*Alert, error) <span class="cov8" title="3">{
        var resp StandardResponse
        resp.Data = &amp;Alert{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/alerts/rules/%s", id),
                Body:   alert,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if updated, ok := resp.Data.(*Alert); ok </span><span class="cov1" title="1">{
                return updated, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// DeleteAlert deletes an alert
func (s *AlertsService) Delete(ctx context.Context, id string) error <span class="cov8" title="3">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/alerts/rules/%s", id),
                Result: &amp;resp,
        })
        return err
}</span>

// EnableAlert enables an alert
func (s *AlertsService) Enable(ctx context.Context, id string) (*Alert, error) <span class="cov5" title="2">{
        var resp StandardResponse
        resp.Data = &amp;Alert{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/alerts/%s/enable", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if alert, ok := resp.Data.(*Alert); ok </span><span class="cov1" title="1">{
                return alert, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// DisableAlert disables an alert
func (s *AlertsService) Disable(ctx context.Context, id string) (*Alert, error) <span class="cov5" title="2">{
        var resp StandardResponse
        resp.Data = &amp;Alert{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/alerts/%s/disable", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if alert, ok := resp.Data.(*Alert); ok </span><span class="cov1" title="1">{
                return alert, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetAlertHistory retrieves alert history
func (s *AlertsService) GetHistory(ctx context.Context, id string, opts *ListOptions) ([]*AlertHistoryEntry, *PaginationMeta, error) <span class="cov8" title="3">{
        var resp PaginatedResponse
        var history []*AlertHistoryEntry
        resp.Data = &amp;history

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/alerts/%s/history", id),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov8" title="3">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov5" title="2">return history, resp.Meta, nil</span>
}

// TestAlert tests an alert configuration
func (s *AlertsService) Test(ctx context.Context, id string) (*AlertTestResult, error) <span class="cov10" title="4">{
        var resp StandardResponse
        resp.Data = &amp;AlertTestResult{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/alerts/%s/test", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="3">if result, ok := resp.Data.(*AlertTestResult); ok </span><span class="cov8" title="3">{
                return result, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// AcknowledgeAlert acknowledges an alert
func (s *AlertsService) Acknowledge(ctx context.Context, id string, message string) error <span class="cov8" title="3">{
        var resp StandardResponse

        body := map[string]interface{}{
                "message": message,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/alerts/%s/acknowledge", id),
                Body:   body,
                Result: &amp;resp,
        })
        return err
}</span>

// AlertHistoryEntry represents an alert history entry
type AlertHistoryEntry struct {
        ID          uint                   `json:"id"`
        AlertID     uint                   `json:"alert_id"`
        TriggeredAt *CustomTime            `json:"triggered_at"`
        ResolvedAt  *CustomTime            `json:"resolved_at,omitempty"`
        Status      string                 `json:"status"`
        Value       float64                `json:"value"`
        Threshold   float64                `json:"threshold"`
        Message     string                 `json:"message"`
        Details     map[string]interface{} `json:"details,omitempty"`
}

// AlertTestResult represents the result of an alert test
type AlertTestResult struct {
        Success   bool                   `json:"success"`
        Triggered bool                   `json:"triggered"`
        Message   string                 `json:"message"`
        Value     float64                `json:"value,omitempty"`
        Threshold float64                `json:"threshold,omitempty"`
        Details   map[string]interface{} `json:"details,omitempty"`
        Errors    []string               `json:"errors,omitempty"`
}

// ListChannels retrieves all notification channels for an organization
func (s *AlertsService) ListChannels(ctx context.Context, opts *ListOptions) ([]*AlertChannel, *PaginationMeta, error) <span class="cov8" title="3">{
        var resp PaginatedResponse
        var channels []*AlertChannel
        resp.Data = &amp;channels

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/alerts/channels",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov8" title="3">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov5" title="2">return channels, resp.Meta, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// AnalyticsService handles analytics-related operations
// All analytics endpoints use the /v2/analytics prefix
type AnalyticsService struct {
        client *Client
}

// AI Analytics Methods
// These methods provide AI-powered insights and analysis

// GetCapabilities retrieves available AI analytics features
// Authentication: JWT Token required
// Endpoint: GET /v2/analytics/ai/capabilities
// Returns: Available AI features and their status
func (s *AnalyticsService) GetCapabilities(ctx context.Context) (*AICapabilities, error) <span class="cov10" title="2">{
        var resp struct {
                Data    *AICapabilities `json:"data"`
                Status  string          `json:"status"`
                Message string          `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v2/analytics/ai/capabilities",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// AnalyzeMetrics analyzes metrics using AI
// Authentication: JWT Token required
// Endpoint: POST /v2/analytics/ai/analyze
// Parameters:
//   - req: Analysis request with metrics data and context parameters
// Returns: AI-powered analysis results with insights and recommendations
func (s *AnalyticsService) AnalyzeMetrics(ctx context.Context, req *AIAnalysisRequest) (*AIAnalysisResult, error) <span class="cov10" title="2">{
        var resp struct {
                Data    *AIAnalysisResult `json:"data"`
                Status  string            `json:"status"`
                Message string            `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v2/analytics/ai/analyze",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// GetServiceStatus retrieves AI service health status
// Authentication: JWT Token required
// Endpoint: GET /v2/analytics/ai/status
// Returns: AI service health and availability status
func (s *AnalyticsService) GetServiceStatus(ctx context.Context) (*AIServiceStatus, error) <span class="cov10" title="2">{
        var resp struct {
                Data    *AIServiceStatus `json:"data"`
                Status  string           `json:"status"`
                Message string           `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v2/analytics/ai/status",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// Hardware Analytics Methods
// These methods provide hardware health, trends, and predictions

// GetHardwareTrends retrieves historical hardware trends for a server
// Authentication: JWT Token required
// Endpoint: GET /v2/analytics/hardware/trends/{uuid}
// Parameters:
//   - serverUUID: Server UUID
//   - startTime: Start of time range (RFC3339 format)
//   - endTime: End of time range (RFC3339 format)
//   - metricTypes: Optional comma-separated metric types (cpu, memory, disk, network)
// Returns: Historical trends with aggregated metrics
func (s *AnalyticsService) GetHardwareTrends(ctx context.Context, serverUUID, startTime, endTime string, metricTypes ...string) (*HardwareTrends, error) <span class="cov10" title="2">{
        var resp struct {
                Data    *HardwareTrends `json:"data"`
                Status  string          `json:"status"`
                Message string          `json:"message"`
        }

        query := map[string]string{
                "start_time": startTime,
                "end_time":   endTime,
        }
        if len(metricTypes) &gt; 0 </span><span class="cov1" title="1">{
                query["metric_types"] = metricTypes[0]
        }</span>

        <span class="cov10" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v2/analytics/hardware/trends/" + serverUUID,
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// GetHardwareHealth retrieves current hardware health score and diagnostics
// Authentication: JWT Token required
// Endpoint: GET /v2/analytics/hardware/health/{uuid}
// Parameters:
//   - serverUUID: Server UUID
// Returns: Current health score, diagnostics, and component status
func (s *AnalyticsService) GetHardwareHealth(ctx context.Context, serverUUID string) (*HardwareHealth, error) <span class="cov10" title="2">{
        var resp struct {
                Data    *HardwareHealth `json:"data"`
                Status  string          `json:"status"`
                Message string          `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v2/analytics/hardware/health/" + serverUUID,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// GetHardwarePredictions retrieves predictive analytics for hardware failures
// Authentication: JWT Token required
// Endpoint: GET /v2/analytics/hardware/predictions/{uuid}
// Parameters:
//   - serverUUID: Server UUID
//   - horizon: Optional prediction horizon in days (default: 30)
// Returns: Predicted failure probabilities and recommended actions
func (s *AnalyticsService) GetHardwarePredictions(ctx context.Context, serverUUID string, horizon int) (*HardwarePrediction, error) <span class="cov10" title="2">{
        var resp struct {
                Data    *HardwarePrediction `json:"data"`
                Status  string              `json:"status"`
                Message string              `json:"message"`
        }

        query := make(map[string]string)
        if horizon &gt; 0 </span><span class="cov10" title="2">{
                query["horizon"] = fmt.Sprintf("%d", horizon)
        }</span>

        <span class="cov10" title="2">req := &amp;Request{
                Method: "GET",
                Path:   "/v2/analytics/hardware/predictions/" + serverUUID,
                Result: &amp;resp,
        }
        if len(query) &gt; 0 </span><span class="cov10" title="2">{
                req.Query = query
        }</span>

        <span class="cov10" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// Fleet Analytics Methods
// These methods provide organization-wide fleet statistics and metrics

// GetFleetOverview retrieves organization-wide fleet statistics
// Authentication: JWT Token required
// Endpoint: GET /v2/analytics/fleet/overview
// Parameters: Optional query parameters for filtering and aggregation
// Returns: Fleet-wide statistics including server counts, health distribution, resource utilization
func (s *AnalyticsService) GetFleetOverview(ctx context.Context) (*FleetOverview, error) <span class="cov10" title="2">{
        var resp struct {
                Data    *FleetOverview `json:"data"`
                Status  string         `json:"status"`
                Message string         `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v2/analytics/fleet/overview",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// GetOrganizationDashboard retrieves comprehensive dashboard data
// Authentication: JWT Token required
// Endpoint: GET /v2/analytics/fleet/dashboard
// Returns: Comprehensive dashboard with aggregated metrics, server health distribution,
//          alerts summary, and trending data
func (s *AnalyticsService) GetOrganizationDashboard(ctx context.Context) (*OrganizationDashboard, error) <span class="cov10" title="2">{
        var resp struct {
                Data    *OrganizationDashboard `json:"data"`
                Status  string                 `json:"status"`
                Message string                 `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v2/analytics/fleet/dashboard",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// Advanced Analytics Methods
// These methods provide correlation analysis and dependency graphs

// AnalyzeCorrelations analyzes metric correlations across servers
// Authentication: JWT Token required
// Endpoint: POST /v2/analytics/correlation/analyze
// Parameters:
//   - req: Correlation analysis request with metric selection and time ranges
// Returns: Correlation results showing relationships between metrics
func (s *AnalyticsService) AnalyzeCorrelations(ctx context.Context, req *CorrelationAnalysisRequest) (*CorrelationResult, error) <span class="cov10" title="2">{
        var resp struct {
                Data    *CorrelationResult `json:"data"`
                Status  string             `json:"status"`
                Message string             `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v2/analytics/correlation/analyze",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// BuildDependencyGraph builds dependency graph for infrastructure
// Authentication: JWT Token required
// Endpoint: GET /v2/analytics/graph/dependencies
// Parameters: Optional query parameters for graph visualization
// Returns: Dependency graph showing relationships between servers, services, and components
func (s *AnalyticsService) BuildDependencyGraph(ctx context.Context) (*DependencyGraph, error) <span class="cov10" title="2">{
        var resp struct {
                Data    *DependencyGraph `json:"data"`
                Status  string           `json:"status"`
                Message string           `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v2/analytics/graph/dependencies",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// =============================================================================
// Unified API Keys Service
// =============================================================================

// CreateUnified creates a new unified API key
func (s *APIKeysService) CreateUnified(ctx context.Context, req *CreateUnifiedAPIKeyRequest) (*CreateUnifiedAPIKeyResponse, error) <span class="cov10" title="4">{
        var resp StandardResponse
        result := &amp;CreateUnifiedAPIKeyResponse{}
        resp.Data = result

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v2/api-keys",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="4">return result, nil</span>
}

// GetUnified retrieves a unified API key by ID
func (s *APIKeysService) GetUnified(ctx context.Context, keyID string) (*UnifiedAPIKey, error) <span class="cov8" title="3">{
        var resp StandardResponse
        resp.Data = &amp;UnifiedAPIKey{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v2/api-keys/%s", keyID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">if key, ok := resp.Data.(*UnifiedAPIKey); ok </span><span class="cov8" title="3">{
                return key, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ListUnified retrieves a list of unified API keys
func (s *APIKeysService) ListUnified(ctx context.Context, opts *ListUnifiedAPIKeysOptions) ([]*UnifiedAPIKey, *PaginationMeta, error) <span class="cov8" title="3">{
        var resp PaginatedResponse
        var keys []*UnifiedAPIKey
        resp.Data = &amp;keys

        req := &amp;Request{
                Method: "GET",
                Path:   "/v2/api-keys",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov8" title="3">{
                req.Query = opts.ListOptions.ToQuery()
                
                // Add unified-specific query parameters
                if opts.Type != "" </span><span class="cov5" title="2">{
                        req.Query["type"] = string(opts.Type)
                }</span>
                <span class="cov8" title="3">if opts.Status != "" </span><span class="cov5" title="2">{
                        req.Query["status"] = string(opts.Status)
                }</span>
                <span class="cov8" title="3">if opts.UserID != 0 </span><span class="cov0" title="0">{
                        req.Query["user_id"] = fmt.Sprintf("%d", opts.UserID)
                }</span>
                <span class="cov8" title="3">if opts.AgentType != "" </span><span class="cov0" title="0">{
                        req.Query["agent_type"] = opts.AgentType
                }</span>
                <span class="cov8" title="3">if opts.RegionCode != "" </span><span class="cov0" title="0">{
                        req.Query["region_code"] = opts.RegionCode
                }</span>
                <span class="cov8" title="3">if opts.Namespace != "" </span><span class="cov0" title="0">{
                        req.Query["namespace"] = opts.Namespace
                }</span>
                <span class="cov8" title="3">if opts.Capability != "" </span><span class="cov0" title="0">{
                        req.Query["capability"] = opts.Capability
                }</span>
                <span class="cov8" title="3">if opts.Tag != "" </span><span class="cov0" title="0">{
                        req.Query["tag"] = opts.Tag
                }</span>
        }

        <span class="cov8" title="3">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="3">return keys, resp.Meta, nil</span>
}

// UpdateUnified updates a unified API key
func (s *APIKeysService) UpdateUnified(ctx context.Context, keyID string, req *UpdateUnifiedAPIKeyRequest) (*UnifiedAPIKey, error) <span class="cov5" title="2">{
        var resp StandardResponse
        resp.Data = &amp;UnifiedAPIKey{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v2/api-keys/%s", keyID),
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="2">if key, ok := resp.Data.(*UnifiedAPIKey); ok </span><span class="cov5" title="2">{
                return key, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// DeleteUnified deletes a unified API key
func (s *APIKeysService) DeleteUnified(ctx context.Context, keyID string) error <span class="cov1" title="1">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v2/api-keys/%s", keyID),
                Result: &amp;resp,
        })
        return err
}</span>

// RevokeUnified revokes a unified API key
func (s *APIKeysService) RevokeUnified(ctx context.Context, keyID string) error <span class="cov1" title="1">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v2/api-keys/%s/revoke", keyID),
                Result: &amp;resp,
        })
        return err
}</span>

// RegenerateUnified regenerates a unified API key
func (s *APIKeysService) RegenerateUnified(ctx context.Context, keyID string) (*CreateUnifiedAPIKeyResponse, error) <span class="cov1" title="1">{
        var resp StandardResponse
        result := &amp;CreateUnifiedAPIKeyResponse{}
        resp.Data = result

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v2/api-keys/%s/regenerate", keyID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// =============================================================================
// Organization-scoped API Key operations
// =============================================================================

// CreateForOrganization creates a new API key for a specific organization
func (s *APIKeysService) CreateForOrganization(ctx context.Context, orgID string, req *CreateUnifiedAPIKeyRequest) (*CreateUnifiedAPIKeyResponse, error) <span class="cov1" title="1">{
        var resp StandardResponse
        result := &amp;CreateUnifiedAPIKeyResponse{}
        resp.Data = result

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v2/organizations/%s/api-keys", orgID),
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// ListForOrganization retrieves API keys for a specific organization
func (s *APIKeysService) ListForOrganization(ctx context.Context, orgID string, opts *ListUnifiedAPIKeysOptions) ([]*UnifiedAPIKey, *PaginationMeta, error) <span class="cov5" title="2">{
        var resp PaginatedResponse
        var keys []*UnifiedAPIKey
        resp.Data = &amp;keys

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v2/organizations/%s/api-keys", orgID),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ListOptions.ToQuery()
                
                // Add unified-specific query parameters
                if opts.Type != "" </span><span class="cov1" title="1">{
                        req.Query["type"] = string(opts.Type)
                }</span>
                <span class="cov1" title="1">if opts.Status != "" </span><span class="cov0" title="0">{
                        req.Query["status"] = string(opts.Status)
                }</span>
                <span class="cov1" title="1">if opts.UserID != 0 </span><span class="cov0" title="0">{
                        req.Query["user_id"] = fmt.Sprintf("%d", opts.UserID)
                }</span>
                <span class="cov1" title="1">if opts.AgentType != "" </span><span class="cov0" title="0">{
                        req.Query["agent_type"] = opts.AgentType
                }</span>
                <span class="cov1" title="1">if opts.RegionCode != "" </span><span class="cov0" title="0">{
                        req.Query["region_code"] = opts.RegionCode
                }</span>
                <span class="cov1" title="1">if opts.Namespace != "" </span><span class="cov0" title="0">{
                        req.Query["namespace"] = opts.Namespace
                }</span>
                <span class="cov1" title="1">if opts.Capability != "" </span><span class="cov0" title="0">{
                        req.Query["capability"] = opts.Capability
                }</span>
                <span class="cov1" title="1">if opts.Tag != "" </span><span class="cov0" title="0">{
                        req.Query["tag"] = opts.Tag
                }</span>
        }

        <span class="cov5" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov5" title="2">return keys, resp.Meta, nil</span>
}

// =============================================================================
// Admin API Key operations
// =============================================================================

// AdminCreateUnified creates a new unified API key with admin privileges
func (s *APIKeysService) AdminCreateUnified(ctx context.Context, req *CreateUnifiedAPIKeyRequest) (*CreateUnifiedAPIKeyResponse, error) <span class="cov8" title="3">{
        var resp StandardResponse
        result := &amp;CreateUnifiedAPIKeyResponse{}
        resp.Data = result

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v2/admin/api-keys",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">return result, nil</span>
}

// AdminListUnified retrieves all unified API keys (admin only)
func (s *APIKeysService) AdminListUnified(ctx context.Context, opts *ListUnifiedAPIKeysOptions) ([]*UnifiedAPIKey, *PaginationMeta, error) <span class="cov5" title="2">{
        var resp PaginatedResponse
        var keys []*UnifiedAPIKey
        resp.Data = &amp;keys

        req := &amp;Request{
                Method: "GET",
                Path:   "/v2/admin/api-keys",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ListOptions.ToQuery()
                
                // Add unified-specific query parameters
                if opts.Type != "" </span><span class="cov1" title="1">{
                        req.Query["type"] = string(opts.Type)
                }</span>
                <span class="cov1" title="1">if opts.Status != "" </span><span class="cov0" title="0">{
                        req.Query["status"] = string(opts.Status)
                }</span>
                <span class="cov1" title="1">if opts.UserID != 0 </span><span class="cov0" title="0">{
                        req.Query["user_id"] = fmt.Sprintf("%d", opts.UserID)
                }</span>
                <span class="cov1" title="1">if opts.AgentType != "" </span><span class="cov0" title="0">{
                        req.Query["agent_type"] = opts.AgentType
                }</span>
                <span class="cov1" title="1">if opts.RegionCode != "" </span><span class="cov0" title="0">{
                        req.Query["region_code"] = opts.RegionCode
                }</span>
                <span class="cov1" title="1">if opts.Namespace != "" </span><span class="cov0" title="0">{
                        req.Query["namespace"] = opts.Namespace
                }</span>
                <span class="cov1" title="1">if opts.Capability != "" </span><span class="cov0" title="0">{
                        req.Query["capability"] = opts.Capability
                }</span>
                <span class="cov1" title="1">if opts.Tag != "" </span><span class="cov0" title="0">{
                        req.Query["tag"] = opts.Tag
                }</span>
        }

        <span class="cov5" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov5" title="2">return keys, resp.Meta, nil</span>
}

// =============================================================================
// Legacy API Key operations (backward compatibility)
// =============================================================================

// Create creates a new API key (legacy interface)
func (s *APIKeysService) Create(ctx context.Context, apiKey *APIKey) (*APIKey, error) <span class="cov1" title="1">{
        // Convert legacy APIKey to CreateUnifiedAPIKeyRequest
        req := &amp;CreateUnifiedAPIKeyRequest{
                Name:         apiKey.Name,
                Description:  apiKey.Description,
                Type:         APIKeyTypeUser, // Default to user type for legacy keys
                Capabilities: apiKey.Scopes,  // Map scopes to capabilities
        }

        // Create the unified key
        resp, err := s.CreateUnified(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Key, nil</span>
}

// Get retrieves an API key by ID (legacy interface)
func (s *APIKeysService) Get(ctx context.Context, id string) (*APIKey, error) <span class="cov1" title="1">{
        return s.GetUnified(ctx, id)
}</span>

// List retrieves a list of API keys (legacy interface)
func (s *APIKeysService) List(ctx context.Context, opts *ListOptions) ([]*APIKey, *PaginationMeta, error) <span class="cov0" title="0">{
        unifiedOpts := &amp;ListUnifiedAPIKeysOptions{
                ListOptions: *opts,
        }
        
        return s.ListUnified(ctx, unifiedOpts)
}</span>

// Update updates an API key (legacy interface)
func (s *APIKeysService) Update(ctx context.Context, id string, apiKey *APIKey) (*APIKey, error) <span class="cov1" title="1">{
        req := &amp;UpdateUnifiedAPIKeyRequest{
                Name:         &amp;apiKey.Name,
                Description:  &amp;apiKey.Description,
                Capabilities: apiKey.Scopes, // Map scopes to capabilities
        }
        
        return s.UpdateUnified(ctx, id, req)
}</span>

// Delete deletes an API key (legacy interface)
func (s *APIKeysService) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        return s.DeleteUnified(ctx, id)
}</span>

// Revoke revokes an API key (legacy interface)
func (s *APIKeysService) Revoke(ctx context.Context, id string) error <span class="cov0" title="0">{
        return s.RevokeUnified(ctx, id)
}</span>

// Regenerate regenerates an API key (legacy interface)
func (s *APIKeysService) Regenerate(ctx context.Context, id string) (*APIKey, error) <span class="cov0" title="0">{
        resp, err := s.RegenerateUnified(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return resp.Key, nil</span>
}

// =============================================================================
// Specialized key creation helpers
// =============================================================================

// CreateUserKey creates a new user API key with standard user capabilities
func (s *APIKeysService) CreateUserKey(ctx context.Context, name, description string, capabilities []string) (*CreateUnifiedAPIKeyResponse, error) <span class="cov1" title="1">{
        req := NewUserAPIKey(name, description, capabilities)
        return s.CreateUnified(ctx, req)
}</span>

// CreateAdminKey creates a new admin API key with elevated capabilities
func (s *APIKeysService) CreateAdminKey(ctx context.Context, name, description string, capabilities []string, orgID uint) (*CreateUnifiedAPIKeyResponse, error) <span class="cov1" title="1">{
        req := NewAdminAPIKey(name, description, capabilities, orgID)
        return s.AdminCreateUnified(ctx, req)
}</span>

// CreateMonitoringAgentKey creates a new monitoring agent key
func (s *APIKeysService) CreateMonitoringAgentKey(ctx context.Context, name, description, namespace, agentType, regionCode string, allowedScopes []string) (*CreateUnifiedAPIKeyResponse, error) <span class="cov1" title="1">{
        req := NewMonitoringAgentKey(name, description, namespace, agentType, regionCode, allowedScopes)
        return s.CreateUnified(ctx, req)
}</span>

// CreateRegistrationKey creates a new server registration key
func (s *APIKeysService) CreateRegistrationKey(ctx context.Context, name, description string, orgID uint) (*CreateUnifiedAPIKeyResponse, error) <span class="cov1" title="1">{
        req := NewRegistrationKey(name, description, orgID)
        return s.AdminCreateUnified(ctx, req)
}</span>

// =============================================================================
// Key validation and information helpers
// =============================================================================

// ValidateKey validates a key and returns its information
func (s *APIKeysService) ValidateKey(ctx context.Context, keyID string) (*UnifiedAPIKey, error) <span class="cov1" title="1">{
        key, err := s.GetUnified(ctx, keyID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if !key.IsActive() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API key is not active")
        }</span>

        <span class="cov1" title="1">return key, nil</span>
}

// GetKeysByType retrieves all keys of a specific type
func (s *APIKeysService) GetKeysByType(ctx context.Context, keyType APIKeyType, opts *ListOptions) ([]*UnifiedAPIKey, *PaginationMeta, error) <span class="cov1" title="1">{
        unifiedOpts := &amp;ListUnifiedAPIKeysOptions{
                ListOptions: *opts,
                Type:        keyType,
        }
        
        return s.ListUnified(ctx, unifiedOpts)
}</span>

// GetActiveKeys retrieves all active keys
func (s *APIKeysService) GetActiveKeys(ctx context.Context, opts *ListOptions) ([]*UnifiedAPIKey, *PaginationMeta, error) <span class="cov1" title="1">{
        unifiedOpts := &amp;ListUnifiedAPIKeysOptions{
                ListOptions: *opts,
                Status:      APIKeyStatusActive,
        }
        
        return s.ListUnified(ctx, unifiedOpts)
}</span>

// GetMonitoringAgentKeys retrieves all monitoring agent keys for an organization
func (s *APIKeysService) GetMonitoringAgentKeys(ctx context.Context, orgID string, opts *ListOptions) ([]*UnifiedAPIKey, *PaginationMeta, error) <span class="cov1" title="1">{
        unifiedOpts := &amp;ListUnifiedAPIKeysOptions{
                ListOptions: *opts,
                Type:        APIKeyTypeMonitoringAgent,
        }
        
        return s.ListForOrganization(ctx, orgID, unifiedOpts)
}</span>

// GetRegistrationKeys retrieves all registration keys (admin only)
func (s *APIKeysService) GetRegistrationKeys(ctx context.Context, opts *ListOptions) ([]*UnifiedAPIKey, *PaginationMeta, error) <span class="cov1" title="1">{
        unifiedOpts := &amp;ListUnifiedAPIKeysOptions{
                ListOptions: *opts,
                Type:        APIKeyTypeRegistration,
        }
        
        return s.AdminListUnified(ctx, unifiedOpts)
}</pre>
		
		<pre class="file" id="file4" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// AuditService handles audit log operations and compliance tracking
type AuditService struct {
        client *Client
}

// GetAuditLogs retrieves audit logs with comprehensive filtering
// Authentication: JWT Token required
// Endpoint: GET /v1/audit/logs
// Parameters:
//   - opts: Optional pagination options
//   - filters: Optional filters (user_id, action, resource_type, start_date, end_date, severity)
// Returns: Array of AuditLog objects with pagination metadata
func (s *AuditService) GetAuditLogs(ctx context.Context, opts *PaginationOptions, filters map[string]interface{}) ([]AuditLog, *PaginationMeta, error) <span class="cov10" title="6">{
        var resp struct {
                Data []AuditLog      `json:"data"`
                Meta *PaginationMeta `json:"meta"`
        }

        queryParams := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }

        // Add filter parameters
        <span class="cov10" title="6">if filters != nil </span><span class="cov4" title="2">{
                if userID, ok := filters["user_id"].(uint); ok &amp;&amp; userID &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["user_id"] = fmt.Sprintf("%d", userID)
                }</span>
                <span class="cov4" title="2">if action, ok := filters["action"].(string); ok &amp;&amp; action != "" </span><span class="cov4" title="2">{
                        queryParams["action"] = action
                }</span>
                <span class="cov4" title="2">if resourceType, ok := filters["resource_type"].(string); ok &amp;&amp; resourceType != "" </span><span class="cov1" title="1">{
                        queryParams["resource_type"] = resourceType
                }</span>
                <span class="cov4" title="2">if resourceID, ok := filters["resource_id"].(string); ok &amp;&amp; resourceID != "" </span><span class="cov0" title="0">{
                        queryParams["resource_id"] = resourceID
                }</span>
                <span class="cov4" title="2">if startDate, ok := filters["start_date"].(string); ok &amp;&amp; startDate != "" </span><span class="cov1" title="1">{
                        queryParams["start_date"] = startDate
                }</span>
                <span class="cov4" title="2">if endDate, ok := filters["end_date"].(string); ok &amp;&amp; endDate != "" </span><span class="cov0" title="0">{
                        queryParams["end_date"] = endDate
                }</span>
                <span class="cov4" title="2">if severity, ok := filters["severity"].(string); ok &amp;&amp; severity != "" </span><span class="cov1" title="1">{
                        queryParams["severity"] = severity
                }</span>
                <span class="cov4" title="2">if ipAddress, ok := filters["ip_address"].(string); ok &amp;&amp; ipAddress != "" </span><span class="cov0" title="0">{
                        queryParams["ip_address"] = ipAddress
                }</span>
        }

        <span class="cov10" title="6">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/audit/logs",
                Result: &amp;resp,
        }
        if len(queryParams) &gt; 0 </span><span class="cov4" title="2">{
                req.Query = queryParams
        }</span>

        <span class="cov10" title="6">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov7" title="4">{
                return nil, nil, err
        }</span>

        <span class="cov4" title="2">return resp.Data, resp.Meta, nil</span>
}

// GetAuditLog retrieves a specific audit log entry by ID
// Authentication: JWT Token required
// Endpoint: GET /v1/audit/logs/{id}
// Parameters:
//   - id: Audit log ID
// Returns: AuditLog object with full details
func (s *AuditService) GetAuditLog(ctx context.Context, id uint) (*AuditLog, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *AuditLog `json:"data"`
                Status  string    `json:"status"`
                Message string    `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/audit/logs/%d", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// ExportAuditLogs exports audit logs in the specified format
// Authentication: JWT Token required
// Endpoint: POST /v1/audit/logs/export
// Parameters:
//   - format: Export format (csv, json, pdf)
//   - filters: Optional filters (same as GetAuditLogs)
// Returns: Exported audit logs as byte array
func (s *AuditService) ExportAuditLogs(ctx context.Context, format string, filters map[string]interface{}) ([]byte, error) <span class="cov1" title="1">{
        body := map[string]interface{}{
                "format": format,
        }

        // Add filters to request body
        if filters != nil </span><span class="cov1" title="1">{
                if userID, ok := filters["user_id"].(uint); ok &amp;&amp; userID &gt; 0 </span><span class="cov0" title="0">{
                        body["user_id"] = userID
                }</span>
                <span class="cov1" title="1">if action, ok := filters["action"].(string); ok &amp;&amp; action != "" </span><span class="cov1" title="1">{
                        body["action"] = action
                }</span>
                <span class="cov1" title="1">if resourceType, ok := filters["resource_type"].(string); ok &amp;&amp; resourceType != "" </span><span class="cov0" title="0">{
                        body["resource_type"] = resourceType
                }</span>
                <span class="cov1" title="1">if startDate, ok := filters["start_date"].(string); ok &amp;&amp; startDate != "" </span><span class="cov0" title="0">{
                        body["start_date"] = startDate
                }</span>
                <span class="cov1" title="1">if endDate, ok := filters["end_date"].(string); ok &amp;&amp; endDate != "" </span><span class="cov0" title="0">{
                        body["end_date"] = endDate
                }</span>
                <span class="cov1" title="1">if severity, ok := filters["severity"].(string); ok &amp;&amp; severity != "" </span><span class="cov0" title="0">{
                        body["severity"] = severity
                }</span>
        }

        <span class="cov1" title="1">resp, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/audit/logs/export",
                Body:   body,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Body, nil</span>
}

// GetAuditStatistics retrieves comprehensive audit activity statistics
// Authentication: JWT Token required
// Endpoint: GET /v1/audit/statistics
// Parameters:
//   - startDate: Optional start date filter (ISO 8601 format)
//   - endDate: Optional end date filter (ISO 8601 format)
// Returns: AuditStatistics object with activity breakdown
func (s *AuditService) GetAuditStatistics(ctx context.Context, startDate string, endDate string) (*AuditStatistics, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *AuditStatistics `json:"data"`
                Status  string           `json:"status"`
                Message string           `json:"message"`
        }

        queryParams := make(map[string]string)
        if startDate != "" </span><span class="cov0" title="0">{
                queryParams["start_date"] = startDate
        }</span>
        <span class="cov1" title="1">if endDate != "" </span><span class="cov0" title="0">{
                queryParams["end_date"] = endDate
        }</span>

        <span class="cov1" title="1">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/audit/statistics",
                Result: &amp;resp,
        }
        if len(queryParams) &gt; 0 </span><span class="cov0" title="0">{
                req.Query = queryParams
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// GetUserAuditHistory retrieves audit history for a specific user
// Authentication: JWT Token required
// Endpoint: GET /v1/audit/users/{userID}/history
// Parameters:
//   - userID: User ID
//   - opts: Optional pagination options
//   - startDate: Optional start date filter
//   - endDate: Optional end date filter
// Returns: Array of AuditLog objects with pagination metadata
func (s *AuditService) GetUserAuditHistory(ctx context.Context, userID uint, opts *PaginationOptions, startDate string, endDate string) ([]AuditLog, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp struct {
                Data []AuditLog      `json:"data"`
                Meta *PaginationMeta `json:"meta"`
        }

        queryParams := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }
        <span class="cov1" title="1">if startDate != "" </span><span class="cov0" title="0">{
                queryParams["start_date"] = startDate
        }</span>
        <span class="cov1" title="1">if endDate != "" </span><span class="cov0" title="0">{
                queryParams["end_date"] = endDate
        }</span>

        <span class="cov1" title="1">req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/audit/users/%d/history", userID),
                Result: &amp;resp,
        }
        if len(queryParams) &gt; 0 </span><span class="cov1" title="1">{
                req.Query = queryParams
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, resp.Meta, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
        "net/http"
        "time"
)

// DebugAuthHeaders performs test requests to validate authentication headers
// This helps diagnose authentication issues by testing both header formats
func (c *Client) DebugAuthHeaders(ctx context.Context) error <span class="cov0" title="0">{
        fmt.Println("=== Nexmonyx SDK Authentication Debug ===")
        fmt.Printf("SDK Version: %s\n", Version)
        fmt.Printf("Base URL: %s\n", c.config.BaseURL)
        fmt.Println()

        // Check current authentication configuration
        fmt.Println("Current Authentication Configuration:")
        if c.config.Auth.Token != "" </span><span class="cov0" title="0">{
                fmt.Println("  Auth Type: JWT Token")
        }</span> else<span class="cov0" title="0"> if c.config.Auth.APIKey != "" &amp;&amp; c.config.Auth.APISecret != "" </span><span class="cov0" title="0">{
                fmt.Println("  Auth Type: API Key/Secret")
                fmt.Printf("  API Key: %s\n", c.config.Auth.APIKey)
        }</span> else<span class="cov0" title="0"> if c.config.Auth.ServerUUID != "" &amp;&amp; c.config.Auth.ServerSecret != "" </span><span class="cov0" title="0">{
                fmt.Println("  Auth Type: Server Credentials")
                fmt.Printf("  Server UUID: %s\n", c.config.Auth.ServerUUID)
        }</span> else<span class="cov0" title="0"> if c.config.Auth.MonitoringKey != "" </span><span class="cov0" title="0">{
                fmt.Println("  Auth Type: Monitoring Key")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("  Auth Type: None (no authentication configured)")
        }</span>
        <span class="cov0" title="0">fmt.Println()

        // Only proceed with header tests if we have server credentials
        if c.config.Auth.ServerUUID == "" || c.config.Auth.ServerSecret == "" </span><span class="cov0" title="0">{
                fmt.Println("Skipping header format tests - no server credentials configured")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Println("Testing Authentication Header Formats:")
        fmt.Println("----------------------------------------")

        // Test 1: Current SDK format (X-Server-UUID, X-Server-Secret)
        fmt.Println("\nTest 1: Headers with X- prefix (SDK default)")
        err1 := c.testAuthRequest(ctx, map[string]string{
                "X-Server-UUID":   c.config.Auth.ServerUUID,
                "X-Server-Secret": c.config.Auth.ServerSecret,
        })
        if err1 != nil </span><span class="cov0" title="0">{
                fmt.Printf("  Result: FAILED - %v\n", err1)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("  Result: SUCCESS")
        }</span>

        // Test 2: Without X- prefix (Server-UUID, Server-Secret)
        <span class="cov0" title="0">fmt.Println("\nTest 2: Headers without X- prefix")
        err2 := c.testAuthRequest(ctx, map[string]string{
                "Server-UUID":   c.config.Auth.ServerUUID,
                "Server-Secret": c.config.Auth.ServerSecret,
        })
        if err2 != nil </span><span class="cov0" title="0">{
                fmt.Printf("  Result: FAILED - %v\n", err2)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("  Result: SUCCESS")
        }</span>

        <span class="cov0" title="0">fmt.Println("\n========================================")

        // Summary
        if err1 == nil &amp;&amp; err2 != nil </span><span class="cov0" title="0">{
                fmt.Println("CONCLUSION: API expects headers WITH 'X-' prefix (current SDK format is correct)")
                return nil
        }</span> else<span class="cov0" title="0"> if err1 != nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                fmt.Println("CONCLUSION: API expects headers WITHOUT 'X-' prefix")
                fmt.Println("ACTION REQUIRED: SDK needs to be updated to use 'Server-UUID' instead of 'X-Server-UUID'")
                return fmt.Errorf("header format mismatch detected")
        }</span> else<span class="cov0" title="0"> if err1 == nil &amp;&amp; err2 == nil </span><span class="cov0" title="0">{
                fmt.Println("CONCLUSION: API accepts both header formats")
                return nil
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("CONCLUSION: Neither header format worked - authentication issue may be elsewhere")
                return fmt.Errorf("authentication failed with both header formats")
        }</span>
}

// testAuthRequest performs a test request with custom headers
func (c *Client) testAuthRequest(ctx context.Context, headers map[string]string) error <span class="cov0" title="0">{
        // Create a custom HTTP client for this test
        client := &amp;http.Client{
                Timeout: 10 * time.Second,
        }

        // Create request
        req, err := http.NewRequestWithContext(ctx, "POST", c.config.BaseURL+"/v1/heartbeat", nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Set standard headers
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "application/json")
        req.Header.Set("User-Agent", userAgent)

        // Set custom auth headers
        for k, v := range headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
                if k == "X-Server-Secret" || k == "Server-Secret" </span><span class="cov0" title="0">{
                        fmt.Printf("  Setting %s: [REDACTED]\n", k)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("  Setting %s: %s\n", k, v)
                }</span>
        }

        // Execute request
        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        fmt.Printf("  Response Status: %d %s\n", resp.StatusCode, resp.Status)

        // Read response body for error details
        if resp.StatusCode != http.StatusOK &amp;&amp; resp.StatusCode != http.StatusNoContent </span><span class="cov0" title="0">{
                body := make([]byte, 1024)
                n, _ := resp.Body.Read(body)
                if n &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("  Error Details: %s\n", string(body[:n]))
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("request failed with status %d", resp.StatusCode)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// CreateJob creates a new background job
func (s *BackgroundJobsService) CreateJob(ctx context.Context, req *CreateBackgroundJobRequest) (*BackgroundJob, *Response, error) <span class="cov8" title="4">{
        var resp StandardResponse
        resp.Data = &amp;BackgroundJob{}

        apiResp, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/background-jobs",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="4">if job, ok := resp.Data.(*BackgroundJob); ok </span><span class="cov8" title="4">{
                return job, apiResp, nil
        }</span>
        <span class="cov0" title="0">return nil, apiResp, fmt.Errorf("unexpected response type")</span>
}

// Get retrieves a background job by ID
func (s *BackgroundJobsService) Get(ctx context.Context, jobID uint) (*BackgroundJob, *Response, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;BackgroundJob{}

        apiResp, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/background-jobs/%d", jobID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">if job, ok := resp.Data.(*BackgroundJob); ok </span><span class="cov1" title="1">{
                return job, apiResp, nil
        }</span>
        <span class="cov0" title="0">return nil, apiResp, fmt.Errorf("unexpected response type")</span>
}

// List retrieves a list of background jobs
func (s *BackgroundJobsService) List(ctx context.Context, opts *ListJobsOptions) ([]*BackgroundJob, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp PaginatedResponse
        var jobs []*BackgroundJob
        resp.Data = &amp;jobs

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/background-jobs",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return jobs, resp.Meta, nil</span>
}

// Cancel cancels a background job
func (s *BackgroundJobsService) Cancel(ctx context.Context, jobID uint) (*Response, error) <span class="cov1" title="1">{
        var resp StandardResponse

        apiResp, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/background-jobs/%d/cancel", jobID),
                Result: &amp;resp,
        })
        return apiResp, err
}</span>

// Retry retries a failed background job
func (s *BackgroundJobsService) Retry(ctx context.Context, jobID string) (*BackgroundJob, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;BackgroundJob{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/background-jobs/%s/retry", jobID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if job, ok := resp.Data.(*BackgroundJob); ok </span><span class="cov1" title="1">{
                return job, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetStatus retrieves the status of a background job
func (s *BackgroundJobsService) GetStatus(ctx context.Context, jobID string) (*JobStatus, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;JobStatus{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/background-jobs/%s/status", jobID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if status, ok := resp.Data.(*JobStatus); ok </span><span class="cov1" title="1">{
                return status, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// BackgroundJob represents a background job
type BackgroundJob struct {
        ID             uint                   `json:"id"`
        Type           string                 `json:"type"`
        Status         string                 `json:"status"`   // pending, running, completed, failed, cancelled
        Progress       int                    `json:"progress"` // 0-100
        Priority       int                    `json:"priority"` // 1 (low), 2 (normal), 3 (high)
        ProgressText   string                 `json:"progress_text,omitempty"`
        OrganizationID uint                   `json:"organization_id"`
        UserID         uint                   `json:"user_id"`
        CreatedAt      *CustomTime            `json:"created_at"`
        StartedAt      *CustomTime            `json:"started_at,omitempty"`
        CompletedAt    *CustomTime            `json:"completed_at,omitempty"`
        FailedAt       *CustomTime            `json:"failed_at,omitempty"`
        RetryCount     int                    `json:"retry_count"`
        MaxRetries     int                    `json:"max_retries"`
        Payload        map[string]interface{} `json:"payload,omitempty"`
        Result         map[string]interface{} `json:"result,omitempty"`
        Error          string                 `json:"error,omitempty"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// CreateBackgroundJobRequest represents a request to create a background job
type CreateBackgroundJobRequest struct {
        Type       string                 `json:"type"`
        Priority   int                    `json:"priority"` // 1 (low), 2 (normal), 3 (high)
        Payload    map[string]interface{} `json:"payload,omitempty"`
        MaxRetries int                    `json:"max_retries,omitempty"`
        ScheduleAt *CustomTime            `json:"schedule_at,omitempty"`
        Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

// ListJobsOptions represents options for listing background jobs
type ListJobsOptions struct {
        Page   int    `url:"page,omitempty"`
        Limit  int    `url:"limit,omitempty"`
        Type   string `url:"type,omitempty"`
        Status string `url:"status,omitempty"`
        UserID uint   `url:"user_id,omitempty"`
}

// ToQuery converts ListJobsOptions to query parameters
func (o *ListJobsOptions) ToQuery() map[string]string <span class="cov4" title="2">{
        params := make(map[string]string)
        if o.Page &gt; 0 </span><span class="cov4" title="2">{
                params["page"] = fmt.Sprintf("%d", o.Page)
        }</span>
        <span class="cov4" title="2">if o.Limit &gt; 0 </span><span class="cov4" title="2">{
                params["limit"] = fmt.Sprintf("%d", o.Limit)
        }</span>
        <span class="cov4" title="2">if o.Type != "" </span><span class="cov4" title="2">{
                params["type"] = o.Type
        }</span>
        <span class="cov4" title="2">if o.Status != "" </span><span class="cov1" title="1">{
                params["status"] = o.Status
        }</span>
        <span class="cov4" title="2">if o.UserID &gt; 0 </span><span class="cov1" title="1">{
                params["user_id"] = fmt.Sprintf("%d", o.UserID)
        }</span>
        <span class="cov4" title="2">return params</span>
}

// JobStatus represents the status of a background job
type JobStatus struct {
        ID        string                 `json:"id"`
        Status    string                 `json:"status"`
        Progress  int                    `json:"progress"`
        Message   string                 `json:"message,omitempty"`
        Steps     []JobStep              `json:"steps,omitempty"`
        Metrics   map[string]interface{} `json:"metrics,omitempty"`
        UpdatedAt *CustomTime            `json:"updated_at"`
}

// JobStep represents a step in a background job
type JobStep struct {
        Name      string      `json:"name"`
        Status    string      `json:"status"`
        StartedAt *CustomTime `json:"started_at"`
        EndedAt   *CustomTime `json:"ended_at,omitempty"`
        Duration  float64     `json:"duration,omitempty"` // seconds
        Error     string      `json:"error,omitempty"`
}

// IsComplete returns true if the job is complete (succeeded or failed)
func (j *BackgroundJob) IsComplete() bool <span class="cov10" title="5">{
        return j.Status == "completed" || j.Status == "failed" || j.Status == "cancelled"
}</span>

// IsRunning returns true if the job is currently running
func (j *BackgroundJob) IsRunning() bool <span class="cov4" title="2">{
        return j.Status == "running"
}</span>

// IsFailed returns true if the job failed
func (j *BackgroundJob) IsFailed() bool <span class="cov4" title="2">{
        return j.Status == "failed"
}</span>

// CreateDataExportJob creates a data export background job
func (s *BackgroundJobsService) CreateDataExportJob(ctx context.Context, organizationID uint, exportFormat string, dataTypes []string) (*BackgroundJob, *Response, error) <span class="cov1" title="1">{
        return s.CreateJob(ctx, &amp;CreateBackgroundJobRequest{
                Type:     "data_export",
                Priority: 2,
                Payload: map[string]interface{}{
                        "organization_id": organizationID,
                        "export_format":   exportFormat,
                        "data_types":      dataTypes,
                },
        })
}</span>

// CreateReportGenerationJob creates a report generation background job
func (s *BackgroundJobsService) CreateReportGenerationJob(ctx context.Context, organizationID uint, reportType string, period string, serverIDs []uint) (*BackgroundJob, *Response, error) <span class="cov1" title="1">{
        payload := map[string]interface{}{
                "organization_id": organizationID,
                "report_type":     reportType,
                "period":          period,
                "server_ids":      serverIDs,
        }

        return s.CreateJob(ctx, &amp;CreateBackgroundJobRequest{
                Type:     "report_generation",
                Priority: 2,
                Payload:  payload,
        })
}</span>

// CreateAlertDigestJob creates an alert digest background job
func (s *BackgroundJobsService) CreateAlertDigestJob(ctx context.Context, organizationID uint, period string, recipientEmails []string) (*BackgroundJob, *Response, error) <span class="cov1" title="1">{
        return s.CreateJob(ctx, &amp;CreateBackgroundJobRequest{
                Type:     "alert_digest",
                Priority: 1,
                Payload: map[string]interface{}{
                        "organization_id":  organizationID,
                        "period":           period,
                        "recipient_emails": recipientEmails,
                },
        })
}</span>

// UpdateJobStatus updates the status of a background job
func (s *BackgroundJobsService) UpdateJobStatus(ctx context.Context, jobID uint, req *BackgroundJobStatusUpdateRequest) (*BackgroundJob, *Response, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;BackgroundJob{}

        apiResp, err := s.client.Do(ctx, &amp;Request{
                Method: "PATCH",
                Path:   fmt.Sprintf("/v1/background-jobs/%d/status", jobID),
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">if job, ok := resp.Data.(*BackgroundJob); ok </span><span class="cov1" title="1">{
                return job, apiResp, nil
        }</span>
        <span class="cov0" title="0">return nil, apiResp, fmt.Errorf("unexpected response type")</span>
}

// UpdateJobProgress updates the progress of a background job
func (s *BackgroundJobsService) UpdateJobProgress(ctx context.Context, jobID uint, req *BackgroundJobProgressUpdateRequest) (*BackgroundJob, *Response, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;BackgroundJob{}

        apiResp, err := s.client.Do(ctx, &amp;Request{
                Method: "PATCH",
                Path:   fmt.Sprintf("/v1/background-jobs/%d/progress", jobID),
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">if job, ok := resp.Data.(*BackgroundJob); ok </span><span class="cov1" title="1">{
                return job, apiResp, nil
        }</span>
        <span class="cov0" title="0">return nil, apiResp, fmt.Errorf("unexpected response type")</span>
}

// CompleteJob marks a background job as completed
func (s *BackgroundJobsService) CompleteJob(ctx context.Context, jobID uint, result map[string]interface{}) (*BackgroundJob, *Response, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;BackgroundJob{}

        apiResp, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/background-jobs/%d/complete", jobID),
                Body: map[string]interface{}{
                        "result": result,
                },
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">if job, ok := resp.Data.(*BackgroundJob); ok </span><span class="cov1" title="1">{
                return job, apiResp, nil
        }</span>
        <span class="cov0" title="0">return nil, apiResp, fmt.Errorf("unexpected response type")</span>
}

// FailJob marks a background job as failed
func (s *BackgroundJobsService) FailJob(ctx context.Context, jobID uint, errorMessage string) (*BackgroundJob, *Response, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;BackgroundJob{}

        apiResp, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/background-jobs/%d/fail", jobID),
                Body: map[string]interface{}{
                        "error": errorMessage,
                },
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">if job, ok := resp.Data.(*BackgroundJob); ok </span><span class="cov1" title="1">{
                return job, apiResp, nil
        }</span>
        <span class="cov0" title="0">return nil, apiResp, fmt.Errorf("unexpected response type")</span>
}

// GetPendingJobs retrieves pending background jobs
func (s *BackgroundJobsService) GetPendingJobs(ctx context.Context, opts *GetPendingJobsOptions) ([]*BackgroundJob, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp PaginatedResponse
        var jobs []*BackgroundJob
        resp.Data = &amp;jobs

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/background-jobs/pending",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return jobs, resp.Meta, nil</span>
}

// BackgroundJobStatusUpdateRequest represents a request to update job status
type BackgroundJobStatusUpdateRequest struct {
        Status string `json:"status"`
}

// BackgroundJobProgressUpdateRequest represents a request to update job progress
type BackgroundJobProgressUpdateRequest struct {
        Progress     int    `json:"progress"`
        ProgressText string `json:"progress_text,omitempty"`
}

// GetPendingJobsOptions represents options for retrieving pending jobs
type GetPendingJobsOptions struct {
        Limit         int  `url:"limit,omitempty"`
        ImmediateOnly bool `url:"immediate_only,omitempty"`
}

// ToQuery converts GetPendingJobsOptions to query parameters
func (o *GetPendingJobsOptions) ToQuery() map[string]string <span class="cov4" title="2">{
        params := make(map[string]string)
        if o.Limit &gt; 0 </span><span class="cov4" title="2">{
                params["limit"] = fmt.Sprintf("%d", o.Limit)
        }</span>
        <span class="cov4" title="2">if o.ImmediateOnly </span><span class="cov4" title="2">{
                params["immediate_only"] = "true"
        }</span>
        <span class="cov4" title="2">return params</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// GetBillingInfo retrieves billing information for an organization
func (s *BillingService) GetBillingInfo(ctx context.Context, organizationID string) (*BillingInfo, error) <span class="cov8" title="4">{
        var resp StandardResponse
        resp.Data = &amp;BillingInfo{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/organizations/%s/billing", organizationID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov7" title="3">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if billing, ok := resp.Data.(*BillingInfo); ok </span><span class="cov1" title="1">{
                return billing, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetSubscription retrieves subscription details
func (s *BillingService) GetSubscription(ctx context.Context, organizationID string) (*Subscription, error) <span class="cov7" title="3">{
        var resp StandardResponse
        resp.Data = &amp;Subscription{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/organizations/%s/subscription", organizationID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="2">if sub, ok := resp.Data.(*Subscription); ok </span><span class="cov4" title="2">{
                return sub, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ListInvoices retrieves invoices for an organization
func (s *BillingService) ListInvoices(ctx context.Context, organizationID string, opts *ListOptions) ([]*Invoice, *PaginationMeta, error) <span class="cov8" title="4">{
        var resp PaginatedResponse
        var invoices []*Invoice
        resp.Data = &amp;invoices

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/organizations/%s/invoices", organizationID),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov8" title="4">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov8" title="4">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov7" title="3">return invoices, resp.Meta, nil</span>
}

// UpdatePaymentMethod updates the payment method for an organization
func (s *BillingService) UpdatePaymentMethod(ctx context.Context, organizationID string, paymentMethod *PaymentMethod) error <span class="cov10" title="5">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/organizations/%s/payment-method", organizationID),
                Body:   paymentMethod,
                Result: &amp;resp,
        })
        return err
}</span>

// BillingInfo represents billing information
type BillingInfo struct {
        OrganizationID   uint                   `json:"organization_id"`
        StripeCustomerID string                 `json:"stripe_customer_id"`
        CurrentBalance   float64                `json:"current_balance"`
        Credits          float64                `json:"credits"`
        PaymentMethod    *PaymentMethod         `json:"payment_method,omitempty"`
        BillingAddress   *BillingAddress        `json:"billing_address,omitempty"`
        TaxInfo          *TaxInfo               `json:"tax_info,omitempty"`
        NextBillingDate  *CustomTime            `json:"next_billing_date,omitempty"`
        BillingCycle     string                 `json:"billing_cycle"`
        Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// Subscription represents a subscription
type Subscription struct {
        ID                 string                 `json:"id"`
        OrganizationID     uint                   `json:"organization_id"`
        PlanID             string                 `json:"plan_id"`
        PlanName           string                 `json:"plan_name"`
        Status             string                 `json:"status"`
        CurrentPeriodStart *CustomTime            `json:"current_period_start"`
        CurrentPeriodEnd   *CustomTime            `json:"current_period_end"`
        TrialStart         *CustomTime            `json:"trial_start,omitempty"`
        TrialEnd           *CustomTime            `json:"trial_end,omitempty"`
        CancelAtPeriodEnd  bool                   `json:"cancel_at_period_end"`
        CanceledAt         *CustomTime            `json:"canceled_at,omitempty"`
        Quantity           int                    `json:"quantity"`
        AddOns             []SubscriptionAddOn    `json:"add_ons,omitempty"`
        Metadata           map[string]interface{} `json:"metadata,omitempty"`
}

// Invoice represents an invoice
type Invoice struct {
        ID             string                 `json:"id"`
        OrganizationID uint                   `json:"organization_id"`
        InvoiceNumber  string                 `json:"invoice_number"`
        Status         string                 `json:"status"`
        Amount         float64                `json:"amount"`
        Currency       string                 `json:"currency"`
        DueDate        *CustomTime            `json:"due_date"`
        PaidAt         *CustomTime            `json:"paid_at,omitempty"`
        PeriodStart    *CustomTime            `json:"period_start"`
        PeriodEnd      *CustomTime            `json:"period_end"`
        LineItems      []InvoiceLineItem      `json:"line_items"`
        PDFURL         string                 `json:"pdf_url,omitempty"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// PaymentMethod represents a payment method
type PaymentMethod struct {
        ID          string      `json:"id"`
        Type        string      `json:"type"` // card, bank_account
        Last4       string      `json:"last4"`
        Brand       string      `json:"brand,omitempty"` // For cards
        ExpiryMonth int         `json:"expiry_month,omitempty"`
        ExpiryYear  int         `json:"expiry_year,omitempty"`
        BankName    string      `json:"bank_name,omitempty"` // For bank accounts
        IsDefault   bool        `json:"is_default"`
        CreatedAt   *CustomTime `json:"created_at"`
}

// BillingAddress represents a billing address
type BillingAddress struct {
        Line1      string `json:"line1"`
        Line2      string `json:"line2,omitempty"`
        City       string `json:"city"`
        State      string `json:"state"`
        PostalCode string `json:"postal_code"`
        Country    string `json:"country"`
}

// TaxInfo represents tax information
type TaxInfo struct {
        TaxID           string `json:"tax_id"`
        TaxType         string `json:"tax_type"` // vat, gst, etc.
        CompanyName     string `json:"company_name"`
        TaxExempt       bool   `json:"tax_exempt"`
        TaxExemptReason string `json:"tax_exempt_reason,omitempty"`
}

// SubscriptionAddOn represents an add-on to a subscription
type SubscriptionAddOn struct {
        ID       string  `json:"id"`
        Name     string  `json:"name"`
        Quantity int     `json:"quantity"`
        Price    float64 `json:"price"`
}

// InvoiceLineItem represents a line item on an invoice
type InvoiceLineItem struct {
        Description string  `json:"description"`
        Quantity    int     `json:"quantity"`
        UnitPrice   float64 `json:"unit_price"`
        Amount      float64 `json:"amount"`
        Type        string  `json:"type"` // subscription, usage, add_on
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
        "time"
)

// GetMyCurrentUsage retrieves the current usage metrics for the authenticated user's organization
// Authentication: JWT Token required
// Endpoint: GET /v1/billing/usage/current
func (s *BillingUsageService) GetMyCurrentUsage(ctx context.Context) (*OrganizationUsageMetrics, error) <span class="cov10" title="5">{
        var resp StandardResponse
        resp.Data = &amp;OrganizationUsageMetrics{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/billing/usage/current",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov8" title="4">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if usage, ok := resp.Data.(*OrganizationUsageMetrics); ok </span><span class="cov1" title="1">{
                return usage, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetMyUsageHistory retrieves historical usage metrics for the authenticated user's organization
// Authentication: JWT Token required
// Endpoint: GET /v1/billing/usage/history
// Parameters:
//   - startDate: Start of the time range (default: 30 days ago)
//   - endDate: End of the time range (default: now)
//   - interval: Aggregation interval - "hourly", "daily", or "monthly" (default: "daily")
func (s *BillingUsageService) GetMyUsageHistory(ctx context.Context, startDate, endDate time.Time, interval string) ([]UsageMetricsHistory, error) <span class="cov4" title="2">{
        var resp StandardResponse
        var history []UsageMetricsHistory
        resp.Data = &amp;history

        // Build query parameters
        query := make(map[string]string)
        if !startDate.IsZero() </span><span class="cov1" title="1">{
                query["start_date"] = startDate.Format(time.RFC3339)
        }</span>
        <span class="cov4" title="2">if !endDate.IsZero() </span><span class="cov1" title="1">{
                query["end_date"] = endDate.Format(time.RFC3339)
        }</span>
        <span class="cov4" title="2">if interval != "" </span><span class="cov1" title="1">{
                query["interval"] = interval
        }</span>

        <span class="cov4" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/billing/usage/history",
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return history, nil</span>
}

// GetMyUsageSummary retrieves aggregated usage summary for the authenticated user's organization
// Authentication: JWT Token required
// Endpoint: GET /v1/billing/usage/summary
// Parameters:
//   - startDate: Start of the time range (default: 1 month ago)
//   - endDate: End of the time range (default: now)
func (s *BillingUsageService) GetMyUsageSummary(ctx context.Context, startDate, endDate time.Time) (*UsageSummary, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;UsageSummary{}

        // Build query parameters
        query := make(map[string]string)
        if !startDate.IsZero() </span><span class="cov1" title="1">{
                query["start_date"] = startDate.Format(time.RFC3339)
        }</span>
        <span class="cov1" title="1">if !endDate.IsZero() </span><span class="cov1" title="1">{
                query["end_date"] = endDate.Format(time.RFC3339)
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/billing/usage/summary",
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if summary, ok := resp.Data.(*UsageSummary); ok </span><span class="cov1" title="1">{
                return summary, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetOrgCurrentUsage retrieves the current usage metrics for a specific organization (admin only)
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/billing/organizations/:id/usage
// Parameters:
//   - orgID: Organization ID to retrieve usage for
func (s *BillingUsageService) GetOrgCurrentUsage(ctx context.Context, orgID uint) (*OrganizationUsageMetrics, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;OrganizationUsageMetrics{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/billing/organizations/%d/usage", orgID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if usage, ok := resp.Data.(*OrganizationUsageMetrics); ok </span><span class="cov1" title="1">{
                return usage, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetOrgUsageHistory retrieves historical usage metrics for a specific organization (admin only)
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/billing/organizations/:id/usage/history
// Parameters:
//   - orgID: Organization ID to retrieve usage for
//   - startDate: Start of the time range (default: 30 days ago)
//   - endDate: End of the time range (default: now)
//   - interval: Aggregation interval - "hourly", "daily", or "monthly" (default: "daily")
func (s *BillingUsageService) GetOrgUsageHistory(ctx context.Context, orgID uint, startDate, endDate time.Time, interval string) ([]UsageMetricsHistory, error) <span class="cov4" title="2">{
        var resp StandardResponse
        var history []UsageMetricsHistory
        resp.Data = &amp;history

        // Build query parameters
        query := make(map[string]string)
        if !startDate.IsZero() </span><span class="cov1" title="1">{
                query["start_date"] = startDate.Format(time.RFC3339)
        }</span>
        <span class="cov4" title="2">if !endDate.IsZero() </span><span class="cov1" title="1">{
                query["end_date"] = endDate.Format(time.RFC3339)
        }</span>
        <span class="cov4" title="2">if interval != "" </span><span class="cov4" title="2">{
                query["interval"] = interval
        }</span>

        <span class="cov4" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/billing/organizations/%d/usage/history", orgID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return history, nil</span>
}

// GetOrgUsageSummary retrieves aggregated usage summary for a specific organization (admin only)
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/billing/organizations/:id/usage/summary
// Parameters:
//   - orgID: Organization ID to retrieve usage for
//   - startDate: Start of the time range (default: 30 days ago)
//   - endDate: End of the time range (default: now)
func (s *BillingUsageService) GetOrgUsageSummary(ctx context.Context, orgID uint, startDate, endDate time.Time) (*UsageSummary, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;UsageSummary{}

        // Build query parameters
        query := make(map[string]string)
        if !startDate.IsZero() </span><span class="cov1" title="1">{
                query["start_date"] = startDate.Format(time.RFC3339)
        }</span>
        <span class="cov1" title="1">if !endDate.IsZero() </span><span class="cov1" title="1">{
                query["end_date"] = endDate.Format(time.RFC3339)
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/billing/organizations/%d/usage/summary", orgID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if summary, ok := resp.Data.(*UsageSummary); ok </span><span class="cov1" title="1">{
                return summary, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetAllUsageOverview retrieves usage overview for all organizations (admin only)
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/billing/usage/overview
// Parameters:
//   - opts: Pagination options (page, limit)
//
// Returns organization usage metrics with pagination metadata.
func (s *BillingUsageService) GetAllUsageOverview(ctx context.Context, opts *ListOptions) (*OrganizationUsageOverview, *PaginationMeta, error) <span class="cov4" title="2">{
        var resp struct {
                Status     string                      `json:"status"`
                Message    string                      `json:"message"`
                Data       *OrganizationUsageOverview  `json:"data"`
                Pagination *PaginationMeta             `json:"pagination"`
        }

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/admin/billing/usage/overview",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov4" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov4" title="2">return resp.Data, resp.Pagination, nil</span>
}

// RecordUsageMetrics records usage metrics for an organization (admin/controller only)
// Authentication: Admin JWT Token or API Key required
// Endpoint: POST /v1/admin/usage-metrics/record
// Parameters:
//   - metrics: Usage metrics to record
//
// This method is used by org-management-controller to submit usage metrics
// to the API. It records both current and historical metrics in a single call.
func (s *BillingUsageService) RecordUsageMetrics(ctx context.Context, metrics *UsageMetricsRecordRequest) error <span class="cov1" title="1">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/admin/usage-metrics/record",
                Body:   metrics,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetOrgAgentCounts retrieves agent counts for an organization (admin only)
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/usage-metrics/:org_id/agent-counts
// Parameters:
//   - orgID: Organization ID to retrieve agent counts for
//
// Returns active and total agent counts used for billing calculations.
func (s *BillingUsageService) GetOrgAgentCounts(ctx context.Context, orgID uint) (*AgentCountsResponse, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;AgentCountsResponse{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/usage-metrics/%d/agent-counts", orgID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if counts, ok := resp.Data.(*AgentCountsResponse); ok </span><span class="cov1" title="1">{
                return counts, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetOrgStorageUsage calculates storage usage for an organization (admin only)
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/usage-metrics/:org_id/storage
// Parameters:
//   - orgID: Organization ID to calculate storage for
//
// Returns storage usage in bytes and GB used for billing calculations.
func (s *BillingUsageService) GetOrgStorageUsage(ctx context.Context, orgID uint) (*StorageUsageResponse, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;StorageUsageResponse{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/usage-metrics/%d/storage", orgID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if storage, ok := resp.Data.(*StorageUsageResponse); ok </span><span class="cov1" title="1">{
                return storage, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package nexmonyx

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "time"

        "github.com/go-resty/resty/v2"
)

const (
        // Version is the current version of the SDK
        Version = "2.3.1"

        defaultTimeout = 30 * time.Second
        defaultBaseURL = "https://api.nexmonyx.com"
        userAgent      = "nexmonyx-go-sdk/" + Version
)

// Client is the main entry point for the Nexmonyx SDK
type Client struct {
        // HTTP client
        client *resty.Client

        // Configuration
        config *Config

        // Service clients
        Organizations         *OrganizationsService
        Servers               *ServersService
        Users                 *UsersService
        Metrics               *MetricsService
        Monitoring            *MonitoringService
        Billing               *BillingService
        BillingUsage          *BillingUsageService
        QuotaHistory          *QuotaHistoryService
        Settings              *SettingsService
        Alerts                *AlertsService
        ProbeAlerts           *ProbeAlertsService
        Admin                 *AdminService
        StatusPages           *StatusPagesService
        Providers             *ProvidersService
        Jobs                  *JobsService
        BackgroundJobs        *BackgroundJobsService
        APIKeys               *APIKeysService
        System                *SystemService
        Terms                 *TermsService
        EmailQueue            *EmailQueueService
        Public                *PublicService
        Distros               *DistrosService
        AgentDownload         *AgentDownloadService
        Controllers           *ControllersService
        HardwareInventory     *HardwareInventoryService
        IPMI                  *IPMIService
        Systemd               *SystemdService
        NetworkHardware       *NetworkHardwareService
        MonitoringDeployments *MonitoringDeploymentsService
        NamespaceDeployments  *NamespaceDeploymentsService
        MonitoringAgentKeys   *MonitoringAgentKeysService
        RemoteClusters        *RemoteClustersService
        Health                *HealthService
        ServiceMonitoring     *ServiceMonitoringService
        Probes                *ProbesService
        Incidents             *IncidentsService
        AgentVersions         *AgentVersionsService
        DiskIO                *DiskIOService
        SmartHealth           *SmartHealthService
        Filesystem            *FilesystemService
        Tags                  *TagsService
        Analytics             *AnalyticsService
        ML                    *MLService
        VMs                   *VMsService
        Reporting             *ReportingService
        ServerGroups          *ServerGroupsService
        Search                *SearchService
        Audit                 *AuditService
        Tasks                 *TasksService
        Clusters              *ClustersService
        Packages              *PackagesService
        Notifications         *NotificationsService
        WebSocket             *WebSocketServiceImpl
        ProbeController       *ProbeControllerService
        Database              *DatabaseService
}

// Config holds the configuration for the client
type Config struct {
        // Base URL of the Nexmonyx API
        BaseURL string

        // Authentication configuration
        Auth AuthConfig

        // HTTP client configuration
        HTTPClient *http.Client

        // Request timeout
        Timeout time.Duration

        // Custom headers to add to all requests
        Headers map[string]string

        // Debug mode enables request/response logging
        Debug bool

        // Retry configuration
        RetryCount    int
        RetryWaitTime time.Duration
        RetryMaxWait  time.Duration
}

// AuthConfig holds authentication configuration
type AuthConfig struct {
        // JWT Token (for user authentication via Auth0)
        Token string

        // Unified API Key authentication (preferred method)
        UnifiedAPIKey string // Complete token for bearer auth or key for key/secret auth
        APIKeySecret  string // Secret part when using key/secret authentication

        // Legacy API Key authentication (deprecated, use UnifiedAPIKey instead)
        APIKey    string
        APISecret string

        // Server authentication (for agents) - will be migrated to unified keys
        ServerUUID   string
        ServerSecret string

        // Monitoring key authentication (deprecated, use UnifiedAPIKey instead)
        MonitoringKey string

        // Registration key authentication (for server registration)
        RegistrationKey string
}

// NewClient creates a new Nexmonyx API client
func NewClient(config *Config) (*Client, error) <span class="cov9" title="736">{
        if config == nil </span><span class="cov1" title="1">{
                config = &amp;Config{}
        }</span>

        // Set defaults
        <span class="cov9" title="736">if config.BaseURL == "" </span><span class="cov5" title="33">{
                config.BaseURL = defaultBaseURL
        }</span>
        <span class="cov9" title="736">if config.Timeout == 0 </span><span class="cov9" title="727">{
                config.Timeout = defaultTimeout
        }</span>
        <span class="cov9" title="736">if config.RetryCount == 0 </span><span class="cov9" title="727">{
                config.RetryCount = 3
        }</span>
        <span class="cov9" title="736">if config.RetryWaitTime == 0 </span><span class="cov9" title="727">{
                config.RetryWaitTime = 1 * time.Second
        }</span>
        <span class="cov9" title="736">if config.RetryMaxWait == 0 </span><span class="cov9" title="727">{
                config.RetryMaxWait = 30 * time.Second
        }</span>

        // Create HTTP client if not provided
        <span class="cov9" title="736">httpClient := config.HTTPClient
        if httpClient == nil </span><span class="cov9" title="723">{
                httpClient = &amp;http.Client{
                        Timeout: config.Timeout,
                }
        }</span>

        // Create resty client
        <span class="cov9" title="736">restyClient := resty.NewWithClient(httpClient)
        restyClient.SetBaseURL(config.BaseURL)
        restyClient.SetTimeout(config.Timeout)
        restyClient.SetHeader("User-Agent", userAgent)
        restyClient.SetHeader("Content-Type", "application/json")
        restyClient.SetHeader("Accept", "application/json")

        // Set authentication headers (priority order: JWT Token, Unified API Key, Legacy methods)
        if config.Auth.Token != "" </span><span class="cov8" title="450">{
                // JWT Token authentication (highest priority)
                restyClient.SetAuthToken(config.Auth.Token)
        }</span> else<span class="cov8" title="286"> if config.Auth.UnifiedAPIKey != "" </span><span class="cov3" title="7">{
                // Unified API Key authentication (preferred method)
                if config.Auth.APIKeySecret != "" </span><span class="cov2" title="3">{
                        // Key/Secret authentication
                        restyClient.SetHeader("Access-Key", config.Auth.UnifiedAPIKey)
                        restyClient.SetHeader("Access-Secret", config.Auth.APIKeySecret)
                }</span> else<span class="cov2" title="4"> {
                        // Bearer token authentication (for monitoring agents, etc.)
                        restyClient.SetAuthToken(config.Auth.UnifiedAPIKey)
                }</span>
        } else<span class="cov8" title="279"> if config.Auth.RegistrationKey != "" </span><span class="cov2" title="4">{
                // Registration key authentication (for server registration)
                restyClient.SetHeader("X-Registration-Key", config.Auth.RegistrationKey)
        }</span> else<span class="cov8" title="275"> if config.Auth.APIKey != "" &amp;&amp; config.Auth.APISecret != "" </span><span class="cov5" title="32">{
                // Legacy API Key authentication (deprecated)
                restyClient.SetHeader("Access-Key", config.Auth.APIKey)
                restyClient.SetHeader("Access-Secret", config.Auth.APISecret)
        }</span> else<span class="cov8" title="243"> if config.Auth.ServerUUID != "" &amp;&amp; config.Auth.ServerSecret != "" </span><span class="cov6" title="49">{
                // Server authentication (for agents) - will be migrated to unified keys
                // Note: Server authentication uses X- prefix headers while API Key/Secret uses Access- prefix
                // This inconsistency should be addressed in future API standardization
                restyClient.SetHeader("X-Server-UUID", config.Auth.ServerUUID)
                restyClient.SetHeader("X-Server-Secret", config.Auth.ServerSecret)
        }</span> else<span class="cov7" title="194"> if config.Auth.MonitoringKey != "" </span><span class="cov5" title="32">{
                // Legacy monitoring key authentication (deprecated)
                restyClient.SetAuthToken(config.Auth.MonitoringKey)
        }</span>

        // Set custom headers
        <span class="cov9" title="736">for k, v := range config.Headers </span><span class="cov1" title="2">{
                restyClient.SetHeader(k, v)
        }</span>

        // Configure retry
        <span class="cov9" title="736">restyClient.SetRetryCount(config.RetryCount)
        restyClient.SetRetryWaitTime(config.RetryWaitTime)
        restyClient.SetRetryMaxWaitTime(config.RetryMaxWait)
        restyClient.AddRetryCondition(func(r *resty.Response, err error) bool </span><span class="cov10" title="1041">{
                return err != nil || r.StatusCode() &gt;= 500 || r.StatusCode() == 429
        }</span>)

        // Set debug mode
        <span class="cov9" title="736">restyClient.SetDebug(config.Debug)

        // Create client
        client := &amp;Client{
                client: restyClient,
                config: config,
        }

        // Initialize service clients
        client.Organizations = &amp;OrganizationsService{client: client}
        client.Servers = &amp;ServersService{client: client}
        client.Users = &amp;UsersService{client: client}
        client.Metrics = &amp;MetricsService{client: client}
        client.Monitoring = &amp;MonitoringService{client: client}
        client.Billing = &amp;BillingService{client: client}
        client.BillingUsage = &amp;BillingUsageService{client: client}
        client.QuotaHistory = &amp;QuotaHistoryService{client: client}
        client.Settings = &amp;SettingsService{client: client}
        client.Alerts = &amp;AlertsService{client: client}
        client.ProbeAlerts = &amp;ProbeAlertsService{client: client}
        client.Admin = &amp;AdminService{client: client}
        client.StatusPages = &amp;StatusPagesService{client: client}
        client.Providers = &amp;ProvidersService{client: client}
        client.Jobs = &amp;JobsService{client: client}
        client.BackgroundJobs = &amp;BackgroundJobsService{client: client}
        client.APIKeys = &amp;APIKeysService{client: client}
        client.System = &amp;SystemService{client: client}
        client.Terms = &amp;TermsService{client: client}
        client.EmailQueue = &amp;EmailQueueService{client: client}
        client.Public = &amp;PublicService{client: client}
        client.Distros = &amp;DistrosService{client: client}
        client.AgentDownload = &amp;AgentDownloadService{client: client}
        client.Controllers = &amp;ControllersService{client: client}
        client.HardwareInventory = &amp;HardwareInventoryService{client: client}
        client.IPMI = &amp;IPMIService{client: client}
        client.Systemd = &amp;SystemdService{client: client}
        client.NetworkHardware = &amp;NetworkHardwareService{client: client}
        client.MonitoringDeployments = &amp;MonitoringDeploymentsService{client: client}
        client.NamespaceDeployments = &amp;NamespaceDeploymentsService{client: client}
        client.MonitoringAgentKeys = &amp;MonitoringAgentKeysService{client: client}
        client.RemoteClusters = &amp;RemoteClustersService{client: client}
        client.Health = &amp;HealthService{client: client}
        client.ServiceMonitoring = &amp;ServiceMonitoringService{client: client}
        client.Probes = &amp;ProbesService{client: client}
        client.Incidents = &amp;IncidentsService{client: client}
        client.AgentVersions = &amp;AgentVersionsService{client: client}
        client.DiskIO = &amp;DiskIOService{client: client}
        client.SmartHealth = &amp;SmartHealthService{client: client}
        client.Filesystem = &amp;FilesystemService{client: client}
        client.Tags = &amp;TagsService{client: client}
        client.Analytics = &amp;AnalyticsService{client: client}
        client.ML = &amp;MLService{client: client}
        client.VMs = &amp;VMsService{client: client}
        client.Reporting = &amp;ReportingService{client: client}
        client.ServerGroups = &amp;ServerGroupsService{client: client}
        client.Search = &amp;SearchService{client: client}
        client.Audit = &amp;AuditService{client: client}
        client.Tasks = &amp;TasksService{client: client}
        client.Clusters = &amp;ClustersService{client: client}
        client.Packages = &amp;PackagesService{client: client}
        client.Notifications = &amp;NotificationsService{client: client}
        client.ProbeController = &amp;ProbeControllerService{client: client}
        client.Database = &amp;DatabaseService{client: client}

        // Note: WebSocket service requires separate initialization via NewWebSocketService()
        // to ensure proper server credentials validation and connection management
        client.WebSocket = nil

        return client, nil</span>
}

// WithToken creates a new client with the specified authentication token
func (c *Client) WithToken(token string) *Client <span class="cov1" title="1">{
        newConfig := *c.config
        newConfig.Auth.Token = token
        newConfig.Auth.UnifiedAPIKey = ""
        newConfig.Auth.APIKeySecret = ""
        newConfig.Auth.APIKey = ""
        newConfig.Auth.APISecret = ""
        newConfig.Auth.ServerUUID = ""
        newConfig.Auth.ServerSecret = ""
        newConfig.Auth.MonitoringKey = ""
        newConfig.Auth.RegistrationKey = ""

        newClient, _ := NewClient(&amp;newConfig)
        return newClient
}</span>

// WithUnifiedAPIKey creates a new client with unified API key authentication (bearer token)
func (c *Client) WithUnifiedAPIKey(key string) *Client <span class="cov1" title="1">{
        newConfig := *c.config
        newConfig.Auth.Token = ""
        newConfig.Auth.UnifiedAPIKey = key
        newConfig.Auth.APIKeySecret = ""
        newConfig.Auth.APIKey = ""
        newConfig.Auth.APISecret = ""
        newConfig.Auth.ServerUUID = ""
        newConfig.Auth.ServerSecret = ""
        newConfig.Auth.MonitoringKey = ""
        newConfig.Auth.RegistrationKey = ""

        newClient, _ := NewClient(&amp;newConfig)
        return newClient
}</span>

// WithUnifiedAPIKeyAndSecret creates a new client with unified API key authentication (key/secret)
func (c *Client) WithUnifiedAPIKeyAndSecret(key, secret string) *Client <span class="cov1" title="1">{
        newConfig := *c.config
        newConfig.Auth.Token = ""
        newConfig.Auth.UnifiedAPIKey = key
        newConfig.Auth.APIKeySecret = secret
        newConfig.Auth.APIKey = ""
        newConfig.Auth.APISecret = ""
        newConfig.Auth.ServerUUID = ""
        newConfig.Auth.ServerSecret = ""
        newConfig.Auth.MonitoringKey = ""
        newConfig.Auth.RegistrationKey = ""

        newClient, _ := NewClient(&amp;newConfig)
        return newClient
}</span>

// WithRegistrationKey creates a new client with registration key authentication
func (c *Client) WithRegistrationKey(key string) *Client <span class="cov1" title="1">{
        newConfig := *c.config
        newConfig.Auth.Token = ""
        newConfig.Auth.UnifiedAPIKey = ""
        newConfig.Auth.APIKeySecret = ""
        newConfig.Auth.APIKey = ""
        newConfig.Auth.APISecret = ""
        newConfig.Auth.ServerUUID = ""
        newConfig.Auth.ServerSecret = ""
        newConfig.Auth.MonitoringKey = ""
        newConfig.Auth.RegistrationKey = key

        newClient, _ := NewClient(&amp;newConfig)
        return newClient
}</span>

// WithAPIKey creates a new client with API key authentication (legacy method)
func (c *Client) WithAPIKey(key, secret string) *Client <span class="cov1" title="1">{
        newConfig := *c.config
        newConfig.Auth.Token = ""
        newConfig.Auth.UnifiedAPIKey = ""
        newConfig.Auth.APIKeySecret = ""
        newConfig.Auth.APIKey = key
        newConfig.Auth.APISecret = secret
        newConfig.Auth.ServerUUID = ""
        newConfig.Auth.ServerSecret = ""
        newConfig.Auth.MonitoringKey = ""
        newConfig.Auth.RegistrationKey = ""

        newClient, _ := NewClient(&amp;newConfig)
        return newClient
}</span>

// WithServerCredentials creates a new client with server authentication
func (c *Client) WithServerCredentials(uuid, secret string) *Client <span class="cov1" title="1">{
        newConfig := *c.config
        newConfig.Auth.Token = ""
        newConfig.Auth.UnifiedAPIKey = ""
        newConfig.Auth.APIKeySecret = ""
        newConfig.Auth.APIKey = ""
        newConfig.Auth.APISecret = ""
        newConfig.Auth.ServerUUID = uuid
        newConfig.Auth.ServerSecret = secret
        newConfig.Auth.MonitoringKey = ""
        newConfig.Auth.RegistrationKey = ""

        newClient, _ := NewClient(&amp;newConfig)
        return newClient
}</span>

// WithMonitoringKey creates a new client with monitoring key authentication (legacy method)
func (c *Client) WithMonitoringKey(key string) *Client <span class="cov1" title="2">{
        newConfig := *c.config
        newConfig.Auth.Token = ""
        newConfig.Auth.UnifiedAPIKey = ""
        newConfig.Auth.APIKeySecret = ""
        newConfig.Auth.APIKey = ""
        newConfig.Auth.APISecret = ""
        newConfig.Auth.ServerUUID = ""
        newConfig.Auth.ServerSecret = ""
        newConfig.Auth.MonitoringKey = key
        newConfig.Auth.RegistrationKey = ""

        newClient, _ := NewClient(&amp;newConfig)
        return newClient
}</span>

// NewMonitoringAgentClient creates a new client specifically for monitoring agents
func NewMonitoringAgentClient(config *Config) (*Client, error) <span class="cov3" title="6">{
        if config == nil </span><span class="cov1" title="1">{
                config = &amp;Config{}
        }</span>

        // Validate that monitoring key is provided
        <span class="cov3" title="6">if config.Auth.MonitoringKey == "" </span><span class="cov2" title="3">{
                return nil, fmt.Errorf("monitoring key is required for monitoring agent client")
        }</span>

        // Ensure no other auth methods are set
        <span class="cov2" title="3">config.Auth.Token = ""
        config.Auth.APIKey = ""
        config.Auth.APISecret = ""
        config.Auth.ServerUUID = ""
        config.Auth.ServerSecret = ""

        return NewClient(config)</span>
}

// Do performs a raw HTTP request
func (c *Client) Do(ctx context.Context, req *Request) (*Response, error) <span class="cov9" title="719">{
        // Build resty request
        r := c.client.R().SetContext(ctx)

        // Set body if provided
        if req.Body != nil </span><span class="cov8" title="285">{
                r.SetBody(req.Body)
        }</span>

        // Set query parameters
        <span class="cov9" title="719">if req.Query != nil </span><span class="cov7" title="138">{
                r.SetQueryParams(req.Query)
        }</span>

        // Set additional headers
        <span class="cov9" title="719">for k, v := range req.Headers </span><span class="cov3" title="9">{
                r.SetHeader(k, v)
        }</span>

        // Set result and error objects
        <span class="cov9" title="719">if req.Result != nil </span><span class="cov9" title="672">{
                r.SetResult(req.Result)
        }</span>
        <span class="cov9" title="719">if req.Error != nil </span><span class="cov0" title="0">{
                r.SetError(req.Error)
        }</span>

        // Debug logging for authentication headers
        <span class="cov9" title="719">if c.config.Debug </span><span class="cov4" title="11">{
                fmt.Printf("[DEBUG] Request: %s %s\n", req.Method, req.Path)
                fmt.Printf("[DEBUG] Headers being sent:\n")
                for k, v := range r.Header </span><span class="cov0" title="0">{
                        // Mask sensitive headers for security
                        if k == "Server-Secret" || k == "X-Server-Secret" || k == "X-Api-Secret" || k == "Authorization" </span><span class="cov0" title="0">{
                                fmt.Printf("[DEBUG]   %s: [REDACTED]\n", k)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("[DEBUG]   %s: %v\n", k, v)
                        }</span>
                }
                <span class="cov4" title="11">if req.Body != nil </span><span class="cov2" title="3">{
                        fmt.Printf("[DEBUG] Request has body (type: %T)\n", req.Body)
                }</span>
        }

        // Execute request
        <span class="cov9" title="719">resp, err := r.Execute(req.Method, req.Path)
        if err != nil </span><span class="cov5" title="33">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>

        // Handle errors
        <span class="cov9" title="686">if resp.IsError() </span><span class="cov8" title="223">{
                return nil, c.handleError(resp)
        }</span>

        <span class="cov8" title="463">return &amp;Response{
                StatusCode: resp.StatusCode(),
                Headers:    resp.Header(),
                Body:       resp.Body(),
        }, nil</span>
}

// handleError converts HTTP errors to SDK error types
func (c *Client) handleError(resp *resty.Response) error <span class="cov8" title="223">{
        // Debug logging for error responses
        if c.config.Debug </span><span class="cov3" title="9">{
                fmt.Printf("[DEBUG] Error Response: Status=%d\n", resp.StatusCode())
                fmt.Printf("[DEBUG] Error Body: %s\n", string(resp.Body()))
                fmt.Printf("[DEBUG] Response Headers:\n")
                for k, v := range resp.Header() </span><span class="cov5" title="28">{
                        fmt.Printf("[DEBUG]   %s: %v\n", k, v)
                }</span>
        }

        <span class="cov8" title="223">var apiErr APIError
        if err := json.Unmarshal(resp.Body(), &amp;apiErr); err == nil &amp;&amp; apiErr.ErrorType != "" </span><span class="cov4" title="19">{
                return &amp;apiErr
        }</span>

        // Try to parse error message from response body
        <span class="cov7" title="204">errorMessage := string(resp.Body())

        switch resp.StatusCode() </span>{
        case 400:<span class="cov4" title="20">
                return &amp;ValidationError{
                        StatusCode: resp.StatusCode(),
                        Message:    errorMessage,
                }</span>
        case 401:<span class="cov5" title="37">
                // Use actual error message from API if available
                if errorMessage != "" &amp;&amp; errorMessage != "{}" </span><span class="cov5" title="36">{
                        return &amp;UnauthorizedError{
                                Message: errorMessage,
                        }
                }</span>
                <span class="cov1" title="1">return &amp;UnauthorizedError{
                        Message: "authentication required",
                }</span>
        case 403:<span class="cov4" title="16">
                if errorMessage != "" &amp;&amp; errorMessage != "{}" </span><span class="cov4" title="15">{
                        return &amp;ForbiddenError{
                                Message: errorMessage,
                        }
                }</span>
                <span class="cov1" title="1">return &amp;ForbiddenError{
                        Message: "insufficient permissions",
                }</span>
        case 404:<span class="cov6" title="62">
                return &amp;NotFoundError{
                        Message: "resource not found",
                }</span>
        case 429:<span class="cov1" title="2">
                return &amp;RateLimitError{
                        RetryAfter: resp.Header().Get("Retry-After"),
                        Message:    "rate limit exceeded",
                }</span>
        case 500, 502, 503, 504:<span class="cov6" title="64">
                return &amp;InternalServerError{
                        StatusCode: resp.StatusCode(),
                        Message:    "internal server error",
                        RequestID:  resp.Header().Get("X-Request-ID"),
                }</span>
        default:<span class="cov2" title="3">
                return &amp;APIError{
                        Status:    "error",
                        ErrorCode: fmt.Sprintf("HTTP_%d", resp.StatusCode()),
                        Message:   errorMessage,
                }</span>
        }
}

// HealthCheck performs a lightweight health check on the API
// This is a convenience method that calls Health.GetHealth() and returns only the error.
// It's designed for use in readiness probes and health checks where you only need to know
// if the API is reachable and healthy.
func (c *Client) HealthCheck(ctx context.Context) error <span class="cov3" title="8">{
        health, err := c.Health.GetHealth(ctx)
        if err != nil </span><span class="cov2" title="3">{
                return err
        }</span>

        // If the healthy boolean is explicitly true, consider it healthy
        <span class="cov3" title="5">if health.Healthy </span><span class="cov1" title="1">{
                return nil
        }</span>

        // If the healthy field is false/missing, check if status indicates health
        // Some APIs may return status="healthy" but omit the healthy boolean field
        <span class="cov2" title="4">if health.Status == "healthy" || health.Status == "operational" || health.Status == "ok" </span><span class="cov1" title="2">{
                return nil
        }</span>

        // API is definitively unhealthy
        <span class="cov1" title="2">if health.Status != "" </span><span class="cov1" title="1">{
                return fmt.Errorf("API is unhealthy: %s", health.Status)
        }</span>
        <span class="cov1" title="1">return fmt.Errorf("API is unhealthy")</span>
}

// Request represents an API request
type Request struct {
        Method  string
        Path    string
        Headers map[string]string
        Query   map[string]string
        Body    interface{}
        Result  interface{}
        Error   interface{}
}

// Response represents an API response
type Response struct {
        StatusCode int
        Headers    http.Header
        Body       []byte
}

// Service structs for each API domain
type OrganizationsService struct{ client *Client }
type ServersService struct{ client *Client }
type UsersService struct{ client *Client }
type MetricsService struct{ client *Client }
type MonitoringService struct{ client *Client }
type BillingService struct{ client *Client }
type BillingUsageService struct{ client *Client }
type SettingsService struct{ client *Client }
type AlertsService struct{ client *Client }
type AdminService struct{ client *Client }
type StatusPagesService struct{ client *Client }
type ProvidersService struct{ client *Client }
type JobsService struct{ client *Client }
type BackgroundJobsService struct{ client *Client }
type APIKeysService struct{ client *Client }
type SystemService struct{ client *Client }
type TermsService struct{ client *Client }
type EmailQueueService struct{ client *Client }
type PublicService struct{ client *Client }
type DistrosService struct{ client *Client }
type AgentDownloadService struct{ client *Client }
type ControllersService struct{ client *Client }
type HardwareInventoryService struct{ client *Client }
type IPMIService struct{ client *Client }
type SystemdService struct{ client *Client }
type MonitoringDeploymentsService struct{ client *Client }
type NamespaceDeploymentsService struct{ client *Client }
type MonitoringAgentKeysService struct{ client *Client }
type RemoteClustersService struct{ client *Client }
type HealthService struct{ client *Client }
type ProbesService struct{ client *Client }
type IncidentsService struct{ client *Client }
type AgentVersionsService struct{ client *Client }

// getAuthMethod returns a string describing the authentication method being used
func (c *Client) getAuthMethod() string <span class="cov3" title="10">{
        if c.config.Auth.Token != "" </span><span class="cov2" title="3">{
                return "JWT Token"
        }</span>
        <span class="cov3" title="7">if c.config.Auth.UnifiedAPIKey != "" </span><span class="cov1" title="2">{
                if c.config.Auth.APIKeySecret != "" </span><span class="cov1" title="1">{
                        return "Unified API Key (Key/Secret)"
                }</span>
                <span class="cov1" title="1">return "Unified API Key (Bearer)"</span>
        }
        <span class="cov3" title="5">if c.config.Auth.RegistrationKey != "" </span><span class="cov1" title="1">{
                return "Registration Key"
        }</span>
        <span class="cov2" title="4">if c.config.Auth.APIKey != "" &amp;&amp; c.config.Auth.APISecret != "" </span><span class="cov1" title="1">{
                return "API Key/Secret (Legacy)"
        }</span>
        <span class="cov2" title="3">if c.config.Auth.ServerUUID != "" &amp;&amp; c.config.Auth.ServerSecret != "" </span><span class="cov1" title="1">{
                return "Server Credentials"
        }</span>
        <span class="cov1" title="2">if c.config.Auth.MonitoringKey != "" </span><span class="cov1" title="1">{
                return "Monitoring Key (Legacy)"
        }</span>
        <span class="cov1" title="1">return "None"</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// ClustersService handles Kubernetes cluster management and monitoring
type ClustersService struct {
        client *Client
}

// CreateCluster creates a new Kubernetes cluster for monitoring
// Authentication: JWT Token required (admin)
// Endpoint: POST /v1/admin/clusters
// Parameters:
//   - req: Cluster configuration including API server URL and credentials
// Returns: Created Cluster object
func (s *ClustersService) CreateCluster(ctx context.Context, req *ClusterCreateRequest) (*Cluster, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *Cluster `json:"data"`
                Status  string   `json:"status"`
                Message string   `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/admin/clusters",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// ListClusters retrieves a list of clusters with pagination
// Authentication: JWT Token required (admin)
// Endpoint: GET /v1/admin/clusters
// Parameters:
//   - opts: Optional pagination options
// Returns: Array of Cluster objects with pagination metadata
func (s *ClustersService) ListClusters(ctx context.Context, opts *PaginationOptions) ([]Cluster, *PaginationMeta, error) <span class="cov10" title="5">{
        var resp struct {
                Data []Cluster        `json:"data"`
                Meta *PaginationMeta `json:"meta"`
        }

        queryParams := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }

        <span class="cov10" title="5">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/admin/clusters",
                Result: &amp;resp,
        }
        if len(queryParams) &gt; 0 </span><span class="cov1" title="1">{
                req.Query = queryParams
        }</span>

        <span class="cov10" title="5">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov8" title="4">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, resp.Meta, nil</span>
}

// GetCluster retrieves a specific cluster by ID
// Authentication: JWT Token required (admin)
// Endpoint: GET /v1/admin/clusters/{id}
// Parameters:
//   - clusterID: Cluster ID
// Returns: Cluster object with full details including connection status
func (s *ClustersService) GetCluster(ctx context.Context, clusterID uint) (*Cluster, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *Cluster `json:"data"`
                Status  string   `json:"status"`
                Message string   `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/clusters/%d", clusterID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// UpdateCluster updates an existing cluster's configuration
// Authentication: JWT Token required (admin)
// Endpoint: PUT /v1/admin/clusters/{id}
// Parameters:
//   - clusterID: Cluster ID
//   - req: Updated cluster configuration
// Returns: Updated Cluster object
func (s *ClustersService) UpdateCluster(ctx context.Context, clusterID uint, req *ClusterUpdateRequest) (*Cluster, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *Cluster `json:"data"`
                Status  string   `json:"status"`
                Message string   `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/admin/clusters/%d", clusterID),
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// DeleteCluster removes a cluster from monitoring
// Authentication: JWT Token required (admin)
// Endpoint: DELETE /v1/admin/clusters/{id}
// Parameters:
//   - clusterID: Cluster ID
// Returns: Error if deletion fails
func (s *ClustersService) DeleteCluster(ctx context.Context, clusterID uint) error <span class="cov1" title="1">{
        var resp struct {
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/admin/clusters/%d", clusterID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// ControllersService handles communication with controller-related endpoints
// This service provides methods for controller health monitoring, heartbeat functionality,
// and controller registration with the Nexmonyx API.

// SendHeartbeat sends a heartbeat from a controller to the API
func (s *ControllersService) SendHeartbeat(ctx context.Context, req *ControllerHeartbeatRequest) error <span class="cov10" title="4">{
        if req.ControllerName == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("controller name is required")
        }</span>
        
        <span class="cov8" title="3">_, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/controllers/%s/heartbeat", req.ControllerName),
                Body:   req,
        })
        return err</span>
}

// RegisterController registers a new controller with the API
func (s *ControllersService) RegisterController(ctx context.Context, controllerID, version string) error <span class="cov8" title="3">{
        req := map[string]interface{}{
                "controller_id": controllerID,
                "version":       version,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/controllers/register",
                Body:   req,
        })
        return err
}</span>

// GetControllerStatus retrieves the status of a specific controller
func (s *ControllersService) GetControllerStatus(ctx context.Context, controllerID string) (*ControllerHealthInfo, error) <span class="cov8" title="3">{
        var resp StandardResponse
        resp.Data = &amp;ControllerHealthInfo{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/controllers/%s/status", controllerID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if status, ok := resp.Data.(*ControllerHealthInfo); ok </span><span class="cov1" title="1">{
                return status, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ListControllers retrieves a list of all registered controllers
func (s *ControllersService) ListControllers(ctx context.Context) ([]ControllerHealthInfo, error) <span class="cov5" title="2">{
        var resp StandardResponse
        var controllers []ControllerHealthInfo
        resp.Data = &amp;controllers

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/controllers",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if data, ok := resp.Data.(*[]ControllerHealthInfo); ok </span><span class="cov1" title="1">{
                return *data, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// UpdateControllerStatus updates the status of a specific controller
func (s *ControllersService) UpdateControllerStatus(ctx context.Context, controllerID string, status string) error <span class="cov5" title="2">{
        req := map[string]interface{}{
                "status": status,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/controllers/%s/status", controllerID),
                Body:   req,
        })
        return err
}</span>

// DeregisterController removes a controller from the API registry
func (s *ControllersService) DeregisterController(ctx context.Context, controllerID string) error <span class="cov5" title="2">{
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/controllers/%s", controllerID),
        })
        return err
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
        "net/http"
)

// DatabaseService handles database schema management operations
type DatabaseService struct {
        client *Client
}

// SchemaResponse represents the response from schema operations
type SchemaResponse struct {
        SchemaName string `json:"schema_name"`
        Exists     bool   `json:"exists"`
        Message    string `json:"message"`
}

// CreateOrganizationSchema creates a database schema for an organization
//
// This creates a PostgreSQL schema (org_{id}) for single-tenant services like
// alert-controller, probe-controller, tag-controller, and job-controller.
//
// Parameters:
//   - ctx: Context for request cancellation and deadlines
//   - orgID: Organization ID for which to create the schema
//
// Returns:
//   - *SchemaResponse: Information about the created schema
//   - error: Any error that occurred during the operation
//
// Example:
//
//        response, err := client.Database.CreateOrganizationSchema(ctx, 123)
//        if err != nil {
//            log.Fatalf("Failed to create schema: %v", err)
//        }
//        fmt.Printf("Schema created: %s\n", response.SchemaName)
func (s *DatabaseService) CreateOrganizationSchema(ctx context.Context, orgID uint) (*SchemaResponse, error) <span class="cov8" title="3">{
        schemaName := fmt.Sprintf("org_%d", orgID)

        requestBody := map[string]interface{}{
                "organization_id": orgID,
                "schema_name":     schemaName,
        }

        var response struct {
                Status string          `json:"status"`
                Data   *SchemaResponse `json:"data"`
        }

        resp, err := s.client.client.R().
                SetContext(ctx).
                SetBody(requestBody).
                SetResult(&amp;response).
                Post("/v1/admin/database/schemas")

        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create schema: %w", err)
        }</span>

        <span class="cov5" title="2">if resp.StatusCode() != http.StatusOK </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create schema: HTTP %d", resp.StatusCode())
        }</span>

        <span class="cov1" title="1">return response.Data, nil</span>
}

// DeleteOrganizationSchema drops a database schema for an organization
//
// This removes the PostgreSQL schema (org_{id}) and all its contents (CASCADE).
// Used during organization deletion or cleanup operations.
//
// Parameters:
//   - ctx: Context for request cancellation and deadlines
//   - orgID: Organization ID for which to delete the schema
//
// Returns:
//   - *SchemaResponse: Information about the deleted schema
//   - error: Any error that occurred during the operation
//
// Example:
//
//        response, err := client.Database.DeleteOrganizationSchema(ctx, 123)
//        if err != nil {
//            log.Fatalf("Failed to delete schema: %v", err)
//        }
//        fmt.Printf("Schema deleted: %s\n", response.SchemaName)
func (s *DatabaseService) DeleteOrganizationSchema(ctx context.Context, orgID uint) (*SchemaResponse, error) <span class="cov8" title="3">{
        schemaName := fmt.Sprintf("org_%d", orgID)

        var response struct {
                Status string          `json:"status"`
                Data   *SchemaResponse `json:"data"`
        }

        resp, err := s.client.client.R().
                SetContext(ctx).
                SetResult(&amp;response).
                Delete(fmt.Sprintf("/v1/admin/database/schemas/%s", schemaName))

        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to delete schema: %w", err)
        }</span>

        <span class="cov5" title="2">if resp.StatusCode() != http.StatusOK </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to delete schema: HTTP %d", resp.StatusCode())
        }</span>

        <span class="cov1" title="1">return response.Data, nil</span>
}

// CheckSchemaExists checks if an organization's database schema exists
//
// This queries whether the PostgreSQL schema (org_{id}) exists in the database.
//
// Parameters:
//   - ctx: Context for request cancellation and deadlines
//   - orgID: Organization ID for which to check the schema
//
// Returns:
//   - bool: True if the schema exists, false otherwise
//   - error: Any error that occurred during the operation
//
// Example:
//
//        exists, err := client.Database.CheckSchemaExists(ctx, 123)
//        if err != nil {
//            log.Fatalf("Failed to check schema: %v", err)
//        }
//        if exists {
//            fmt.Println("Schema exists")
//        }
func (s *DatabaseService) CheckSchemaExists(ctx context.Context, orgID uint) (bool, error) <span class="cov10" title="4">{
        schemaName := fmt.Sprintf("org_%d", orgID)

        var response struct {
                Status string          `json:"status"`
                Data   *SchemaResponse `json:"data"`
        }

        resp, err := s.client.client.R().
                SetContext(ctx).
                SetResult(&amp;response).
                Get(fmt.Sprintf("/v1/admin/database/schemas/%s", schemaName))

        if err != nil </span><span class="cov1" title="1">{
                return false, fmt.Errorf("failed to check schema: %w", err)
        }</span>

        <span class="cov8" title="3">if resp.StatusCode() != http.StatusOK </span><span class="cov1" title="1">{
                return false, fmt.Errorf("failed to check schema: HTTP %d", resp.StatusCode())
        }</span>

        <span class="cov5" title="2">return response.Data.Exists, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package nexmonyx

import (
        "context"
        "time"

        "github.com/google/uuid"
)

// DiskIOService handles disk I/O metrics operations
type DiskIOService struct {
        client *Client
}

// DiskIOMetricsSubmission represents the payload for submitting disk I/O metrics
type DiskIOMetricsSubmission struct {
        ServerUUID uuid.UUID                `json:"server_uuid"`
        Timestamp  time.Time                `json:"timestamp"`
        Devices    []DiskIODeviceMetrics    `json:"devices"`
}

// DiskIODeviceMetrics represents I/O metrics for a single device
type DiskIODeviceMetrics struct {
        DeviceName string `json:"device_name"`
        
        // Core I/O counters
        ReadsCompleted  int64 `json:"reads_completed"`
        ReadsMerged     int64 `json:"reads_merged"`
        SectorsRead     int64 `json:"sectors_read"`
        ReadTimeMs      int64 `json:"read_time_ms"`
        
        WritesCompleted int64 `json:"writes_completed"`
        WritesMerged    int64 `json:"writes_merged"`
        SectorsWritten  int64 `json:"sectors_written"`
        WriteTimeMs     int64 `json:"write_time_ms"`
        
        IOInProgress     int   `json:"io_in_progress"`
        IOTimeMs         int64 `json:"io_time_ms"`
        WeightedIOTimeMs int64 `json:"weighted_io_time_ms"`
        
        // Optional calculated metrics
        ReadBytesPerSec    *int64   `json:"read_bytes_per_sec,omitempty"`
        WriteBytesPerSec   *int64   `json:"write_bytes_per_sec,omitempty"`
        ReadOpsPerSec      *float64 `json:"read_ops_per_sec,omitempty"`
        WriteOpsPerSec     *float64 `json:"write_ops_per_sec,omitempty"`
        UtilizationPercent *float64 `json:"utilization_percent,omitempty"`
        
        // Device metadata
        DeviceType   *string `json:"device_type,omitempty"`
        DeviceSize   *int64  `json:"device_size_bytes,omitempty"`
        DeviceModel  *string `json:"device_model,omitempty"`
        DeviceSerial *string `json:"device_serial,omitempty"`
}

// Submit submits disk I/O metrics to the API
func (s *DiskIOService) Submit(ctx context.Context, submission *DiskIOMetricsSubmission) error <span class="cov10" title="5">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v2/metrics/disk-io",
                Body:   submission,
                Result: &amp;resp,
        })
        return err
}</pre>
		
		<pre class="file" id="file14" style="display: none">package nexmonyx

import (
        "fmt"
)

// APIError represents an error response from the Nexmonyx API
type APIError struct {
        Status    string `json:"status"`
        ErrorType string `json:"error"`
        ErrorCode string `json:"error_code"`
        Message   string `json:"message"`
        Details   string `json:"details,omitempty"`
        RequestID string `json:"request_id,omitempty"`
}

// Error implements the error interface
func (e *APIError) Error() string <span class="cov10" title="7">{
        if e.Details != "" </span><span class="cov4" title="2">{
                return fmt.Sprintf("%s: %s (%s)", e.ErrorCode, e.Message, e.Details)
        }</span>
        <span class="cov8" title="5">if e.ErrorCode != "" </span><span class="cov4" title="2">{
                return fmt.Sprintf("%s: %s", e.ErrorCode, e.Message)
        }</span>
        <span class="cov6" title="3">return e.Message</span>
}

// RateLimitError represents a rate limit error
type RateLimitError struct {
        RetryAfter string
        Message    string
        Limit      int
        Remaining  int
        Reset      int64
}

// Error implements the error interface
func (e *RateLimitError) Error() string <span class="cov7" title="4">{
        if e.RetryAfter != "" </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s (retry after: %s)", e.Message, e.RetryAfter)
        }</span>
        <span class="cov6" title="3">return e.Message</span>
}

// ValidationError represents a validation error
type ValidationError struct {
        StatusCode int
        Message    string
        Errors     map[string][]string `json:"errors,omitempty"`
}

// Error implements the error interface
func (e *ValidationError) Error() string <span class="cov9" title="6">{
        if len(e.Errors) &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Sprintf("validation error: %s", e.Message)
        }</span>
        <span class="cov8" title="5">return e.Message</span>
}

// NotFoundError represents a 404 error
type NotFoundError struct {
        Resource string
        ID       string
        Message  string
}

// Error implements the error interface
func (e *NotFoundError) Error() string <span class="cov9" title="6">{
        if e.Resource != "" &amp;&amp; e.ID != "" </span><span class="cov4" title="2">{
                return fmt.Sprintf("%s with ID %s not found", e.Resource, e.ID)
        }</span>
        <span class="cov7" title="4">if e.Message != "" </span><span class="cov1" title="1">{
                return e.Message
        }</span>
        <span class="cov6" title="3">return "resource not found"</span>
}

// UnauthorizedError represents a 401 error
type UnauthorizedError struct {
        Message string
}

// Error implements the error interface
func (e *UnauthorizedError) Error() string <span class="cov4" title="2">{
        if e.Message != "" </span><span class="cov1" title="1">{
                return e.Message
        }</span>
        <span class="cov1" title="1">return "unauthorized"</span>
}

// ForbiddenError represents a 403 error
type ForbiddenError struct {
        Resource string
        Action   string
        Message  string
}

// Error implements the error interface
func (e *ForbiddenError) Error() string <span class="cov8" title="5">{
        if e.Resource != "" &amp;&amp; e.Action != "" </span><span class="cov1" title="1">{
                return fmt.Sprintf("forbidden: cannot %s %s", e.Action, e.Resource)
        }</span>
        <span class="cov7" title="4">if e.Message != "" </span><span class="cov1" title="1">{
                return e.Message
        }</span>
        <span class="cov6" title="3">return "forbidden"</span>
}

// InternalServerError represents a 500 error
type InternalServerError struct {
        StatusCode int
        Message    string
        RequestID  string
}

// Error implements the error interface
func (e *InternalServerError) Error() string <span class="cov6" title="3">{
        if e.RequestID != "" </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s (request ID: %s)", e.Message, e.RequestID)
        }</span>
        <span class="cov4" title="2">return e.Message</span>
}

// ConflictError represents a 409 error
type ConflictError struct {
        Resource string
        Message  string
}

// Error implements the error interface
func (e *ConflictError) Error() string <span class="cov6" title="3">{
        if e.Resource != "" </span><span class="cov1" title="1">{
                return fmt.Sprintf("conflict: %s already exists", e.Resource)
        }</span>
        <span class="cov4" title="2">return e.Message</span>
}

// ServiceUnavailableError represents a 503 error
type ServiceUnavailableError struct {
        Message   string
        RetryTime int
}

// Error implements the error interface
func (e *ServiceUnavailableError) Error() string <span class="cov6" title="3">{
        if e.RetryTime &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Sprintf("%s (retry in %d seconds)", e.Message, e.RetryTime)
        }</span>
        <span class="cov4" title="2">return e.Message</span>
}

// IsNotFound returns true if the error is a NotFoundError
func IsNotFound(err error) bool <span class="cov8" title="5">{
        _, ok := err.(*NotFoundError)
        return ok
}</span>

// IsRateLimit returns true if the error is a RateLimitError
func IsRateLimit(err error) bool <span class="cov8" title="5">{
        _, ok := err.(*RateLimitError)
        return ok
}</span>

// IsUnauthorized returns true if the error is an UnauthorizedError
func IsUnauthorized(err error) bool <span class="cov7" title="4">{
        _, ok := err.(*UnauthorizedError)
        return ok
}</span>

// IsForbidden returns true if the error is a ForbiddenError
func IsForbidden(err error) bool <span class="cov7" title="4">{
        _, ok := err.(*ForbiddenError)
        return ok
}</span>

// IsValidation returns true if the error is a ValidationError
func IsValidation(err error) bool <span class="cov8" title="5">{
        _, ok := err.(*ValidationError)
        return ok
}</span>

// IsConflict returns true if the error is a ConflictError
func IsConflict(err error) bool <span class="cov7" title="4">{
        _, ok := err.(*ConflictError)
        return ok
}</span>

// IsServerError returns true if the error is a server error (5xx)
func IsServerError(err error) bool <span class="cov8" title="5">{
        _, ok := err.(*InternalServerError)
        if ok </span><span class="cov1" title="1">{
                return true
        }</span>
        <span class="cov7" title="4">_, ok = err.(*ServiceUnavailableError)
        return ok</span>
}

// Common error variables
var (
        // ErrUnexpectedResponse is returned when the API returns an unexpected response format
        ErrUnexpectedResponse = fmt.Errorf("unexpected response format from API")
)
</pre>
		
		<pre class="file" id="file15" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// ExampleServerDetailsUpdateWithHardware demonstrates how to use the enhanced
// ServerDetailsUpdateRequest to send detailed hardware information to the API
func ExampleServerDetailsUpdateWithHardware() <span class="cov0" title="0">{
        // Create a client (replace with your actual configuration)
        client, err := NewClient(&amp;Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create client: %v\n", err)
                return
        }</span>

        // Create a comprehensive server details update request
        <span class="cov0" title="0">req := NewServerDetailsUpdateRequest().
                // Basic server information
                WithBasicInfo("web-server-01", "192.168.1.100", "production", "datacenter-east", "web-server").
                // System information
                WithSystemInfo("linux", "Ubuntu 22.04.3 LTS", "x86_64", "SRV-001-ABC123", "00:50:56:c0:00:08").
                // Legacy hardware fields (for backward compatibility)
                WithLegacyHardware("Intel Xeon E5-2680 v4", 2, 28, 67108864, 2000000000000).
                // Enhanced hardware details
                WithCPUs([]ServerCPUInfo{
                        {
                                PhysicalID:       "0",
                                Manufacturer:     "Intel",
                                ModelName:        "Intel(R) Xeon(R) CPU E5-2680 v4 @ 2.40GHz",
                                Family:           "6",
                                Model:            "79",
                                Architecture:     "x86_64",
                                SocketType:       "LGA2011-3",
                                BaseSpeed:        2400.0,
                                MaxSpeed:         3300.0,
                                PhysicalCores:    14,
                                LogicalCores:     28,
                                L1Cache:          32,
                                L2Cache:          256,
                                L3Cache:          35840,
                                Virtualization:   "VT-x",
                        },
                        {
                                PhysicalID:       "1",
                                Manufacturer:     "Intel",
                                ModelName:        "Intel(R) Xeon(R) CPU E5-2680 v4 @ 2.40GHz",
                                Family:           "6",
                                Model:            "79",
                                Architecture:     "x86_64",
                                SocketType:       "LGA2011-3",
                                BaseSpeed:        2400.0,
                                MaxSpeed:         3300.0,
                                PhysicalCores:    14,
                                LogicalCores:     28,
                                L1Cache:          32,
                                L2Cache:          256,
                                L3Cache:          35840,
                                Virtualization:   "VT-x",
                        },
                }).
                WithMemory(&amp;ServerMemoryInfo{
                        TotalSize:     68719476736, // 64GB
                        AvailableSize: 34359738368, // 32GB
                        UsedSize:      34359738368, // 32GB
                        MemoryType:    "DDR4",
                        Speed:         2400,
                        ModuleCount:   8,
                        ECCSupported:  true,
                }).
                WithNetworkInterfaces([]ServerNetworkInterfaceInfo{
                        {
                                Name:          "eth0",
                                HardwareAddr:  "00:50:56:c0:00:08",
                                MTU:           1500,
                                Flags:         "up|broadcast|running|multicast",
                                Addrs:         "192.168.1.100/24",
                                SpeedMbps:     1000,
                                IsUp:          true,
                                IsWireless:    false,
                        },
                        {
                                Name:          "eth1",
                                HardwareAddr:  "00:50:56:c0:00:09",
                                MTU:           1500,
                                Flags:         "up|broadcast|running|multicast",
                                Addrs:         "10.0.1.100/24",
                                SpeedMbps:     1000,
                                IsUp:          true,
                                IsWireless:    false,
                        },
                }).
                WithDisks([]ServerDiskInfo{
                        {
                                Device:       "/dev/sda",
                                DiskModel:    "Samsung SSD 980 PRO",
                                SerialNumber: "S5P2NS0R123456",
                                Size:         1000204886016, // ~1TB
                                Type:         "NVMe",
                                Vendor:       "Samsung",
                        },
                        {
                                Device:       "/dev/sdb",
                                DiskModel:    "WD Red Plus WD40EFPX",
                                SerialNumber: "WD-WX12345678901",
                                Size:         4000787030016, // ~4TB
                                Type:         "HDD",
                                Vendor:       "Western Digital",
                        },
                })

        // Send the update to the API
        ctx := context.Background()
        server, err := client.Servers.UpdateDetails(ctx, "your-server-uuid", req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update server details: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Successfully updated server: %s (ID: %d)\n", server.Hostname, server.ID)</span>
}

// ExampleDiskOnlyUpdate demonstrates how to send just disk information
// This is the primary use case for collecting individual disk metrics
func ExampleDiskOnlyUpdate() <span class="cov0" title="0">{
        client, err := NewClient(&amp;Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
                Debug: true, // Enable debug logging to see detailed hardware info in logs
        })
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create client: %v\n", err)
                return
        }</span>

        // Create a minimal request with just disk information
        <span class="cov0" title="0">req := NewServerDetailsUpdateRequest().
                WithDisks([]ServerDiskInfo{
                        {
                                Device:       "/dev/nvme0n1",
                                DiskModel:    "Samsung SSD 980 PRO 1TB",
                                SerialNumber: "S5P2NS0R789012",
                                Size:         1000204886016,
                                Type:         "NVMe",
                                Vendor:       "Samsung",
                        },
                        {
                                Device:       "/dev/nvme1n1",
                                DiskModel:    "WD Black SN750 2TB",
                                SerialNumber: "WD-WX98765432109",
                                Size:         2000398934016,
                                Type:         "NVMe",
                                Vendor:       "Western Digital",
                        },
                })

        // Check if the request has the required disk information
        if !req.HasDisks() </span><span class="cov0" title="0">{
                fmt.Println("No disk information to send")
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Sending disk information for %d disks\n", len(req.Hardware.Disks))

        // Send the update
        ctx := context.Background()
        server, err := client.Servers.UpdateDetails(ctx, "your-server-uuid", req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update server with disk details: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Successfully updated server with disk information: %s\n", server.Hostname)</span>
}

// ExampleBackwardCompatibility demonstrates that legacy hardware fields still work
func ExampleBackwardCompatibility() <span class="cov0" title="0">{
        client, err := NewClient(&amp;Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create client: %v\n", err)
                return
        }</span>

        // Create a request using only legacy fields
        <span class="cov0" title="0">req := NewServerDetailsUpdateRequest().
                WithBasicInfo("legacy-server", "192.168.1.200", "staging", "datacenter-west", "database").
                WithSystemInfo("linux", "CentOS 7", "x86_64", "SRV-002-XYZ789", "00:50:56:c0:00:10").
                WithLegacyHardware("AMD EPYC 7742", 1, 128, 134217728, 8000000000000) // 128GB RAM, 8TB storage

        // This request will work without any enhanced hardware details
        if req.HasHardwareDetails() </span><span class="cov0" title="0">{
                fmt.Println("Has enhanced hardware details")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Using legacy hardware fields only")
        }</span>

        <span class="cov0" title="0">ctx := context.Background()
        server, err := client.Servers.UpdateDetails(ctx, "your-server-uuid", req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update server with legacy details: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Successfully updated server using legacy fields: %s\n", server.Hostname)</span>
}

// ExampleDynamicHardwareCollection shows how to programmatically build hardware information
func ExampleDynamicHardwareCollection() <span class="cov0" title="0">{
        client, err := NewClient(&amp;Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to create client: %v\n", err)
                return
        }</span>

        // Start with a basic request
        <span class="cov0" title="0">req := NewServerDetailsUpdateRequest().
                WithBasicInfo("dynamic-server", "192.168.1.300", "production", "datacenter-central", "compute")

        // Simulate collecting disk information from system
        disks := []ServerDiskInfo{}
        
        // Example: add disks based on detection logic
        detectedDisks := []string{"/dev/sda", "/dev/sdb", "/dev/nvme0n1"}
        for i, device := range detectedDisks </span><span class="cov0" title="0">{
                disk := ServerDiskInfo{
                        Device: device,
                }
                
                // Simulate disk detection logic
                if device[:8] == "/dev/nvm" </span><span class="cov0" title="0">{
                        disk.Type = "NVMe"
                        disk.DiskModel = fmt.Sprintf("NVMe SSD %d", i+1)
                        disk.Size = 1000204886016 // 1TB
                        disk.Vendor = "Generic NVMe"
                }</span> else<span class="cov0" title="0"> {
                        disk.Type = "SATA"
                        disk.DiskModel = fmt.Sprintf("SATA Drive %d", i+1)
                        disk.Size = 2000398934016 // 2TB
                        disk.Vendor = "Generic SATA"
                }</span>
                <span class="cov0" title="0">disk.SerialNumber = fmt.Sprintf("SN%06d", 100000+i)
                
                disks = append(disks, disk)</span>
        }

        // Add the collected disks to the request
        <span class="cov0" title="0">req = req.WithDisks(disks)

        fmt.Printf("Collected %d disks dynamically\n", len(disks))

        // Send the update
        ctx := context.Background()
        server, err := client.Servers.UpdateDetails(ctx, "your-server-uuid", req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to update server with dynamic hardware: %v\n", err)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Successfully updated server with dynamically collected hardware: %s\n", server.Hostname)</span>
}</pre>
		
		<pre class="file" id="file16" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "os"

        nexmonyx "github.com/nexmonyx/go-sdk/v2"
)

func main() <span class="cov0" title="0">{
        // Command line flags
        var (
                apiURL       = flag.String("api", "https://api.nexmonyx.com", "API endpoint URL")
                serverUUID   = flag.String("uuid", "", "Server UUID")
                serverSecret = flag.String("secret", "", "Server Secret")
                debug        = flag.Bool("debug", false, "Enable debug mode")
                testAuth     = flag.Bool("test-auth", false, "Run authentication header tests")
        )
        flag.Parse()

        // Check for environment variables if flags not provided
        if *serverUUID == "" </span><span class="cov0" title="0">{
                *serverUUID = os.Getenv("NEXMONYX_SERVER_UUID")
        }</span>
        <span class="cov0" title="0">if *serverSecret == "" </span><span class="cov0" title="0">{
                *serverSecret = os.Getenv("NEXMONYX_SERVER_SECRET")
        }</span>

        // Validate required parameters
        <span class="cov0" title="0">if *serverUUID == "" || *serverSecret == "" </span><span class="cov0" title="0">{
                fmt.Println("Usage: auth_debug -uuid &lt;SERVER_UUID&gt; -secret &lt;SERVER_SECRET&gt; [-api &lt;API_URL&gt;] [-debug] [-test-auth]")
                fmt.Println("\nAlternatively, set environment variables:")
                fmt.Println("  NEXMONYX_SERVER_UUID")
                fmt.Println("  NEXMONYX_SERVER_SECRET")
                os.Exit(1)
        }</span>

        // Create client with server credentials
        <span class="cov0" title="0">client, err := nexmonyx.NewClient(&amp;nexmonyx.Config{
                BaseURL: *apiURL,
                Auth: nexmonyx.AuthConfig{
                        ServerUUID:   *serverUUID,
                        ServerSecret: *serverSecret,
                },
                Debug: *debug,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Run authentication header tests if requested
        if *testAuth </span><span class="cov0" title="0">{
                fmt.Println("Running authentication header tests...")
                if err := client.DebugAuthHeaders(ctx); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Authentication test failed: %v", err)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // Test heartbeat endpoint
        <span class="cov0" title="0">fmt.Println("Testing heartbeat endpoint with SDK...")
        fmt.Printf("Server UUID: %s\n", *serverUUID)
        fmt.Printf("API URL: %s\n", *apiURL)
        fmt.Println()

        // Enable debug mode to see headers
        if !*debug </span><span class="cov0" title="0">{
                fmt.Println("Tip: Use -debug flag to see request headers")
                fmt.Println()
        }</span>

        // Attempt to send heartbeat
        <span class="cov0" title="0">err = client.Servers.Heartbeat(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf(" Heartbeat failed: %v\n", err)

                // Provide diagnostic information
                fmt.Println("\nDiagnostic Information:")
                fmt.Println("- Ensure the server UUID and secret are correct")
                fmt.Println("- Verify the API endpoint is accessible")
                fmt.Println("- Run with -test-auth flag to test different header formats")
                fmt.Println("- Run with -debug flag to see request details")

                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println(" Heartbeat successful!")
        fmt.Println("\nAuthentication is working correctly.")</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "os"

        nexmonyx "github.com/nexmonyx/go-sdk/v2"
)

func main() <span class="cov0" title="0">{
        // Command line flags
        var (
                apiURL       = flag.String("api", "https://api.nexmonyx.com", "API endpoint URL")
                serverUUID   = flag.String("uuid", "", "Server UUID")
                serverSecret = flag.String("secret", "", "Server Secret")
                testType     = flag.String("test", "heartbeat", "Test type: heartbeat, update-details, update-info, get-heartbeat")
        )
        flag.Parse()

        // Check for environment variables if flags not provided
        if *serverUUID == "" </span><span class="cov0" title="0">{
                *serverUUID = os.Getenv("NEXMONYX_SERVER_UUID")
        }</span>
        <span class="cov0" title="0">if *serverSecret == "" </span><span class="cov0" title="0">{
                *serverSecret = os.Getenv("NEXMONYX_SERVER_SECRET")
        }</span>

        // Validate required parameters
        <span class="cov0" title="0">if *serverUUID == "" || *serverSecret == "" </span><span class="cov0" title="0">{
                fmt.Println("Usage: debug_heartbeat -uuid &lt;SERVER_UUID&gt; -secret &lt;SERVER_SECRET&gt; [-api &lt;API_URL&gt;] [-test &lt;TYPE&gt;]")
                fmt.Println("\nAlternatively, set environment variables:")
                fmt.Println("  NEXMONYX_SERVER_UUID")
                fmt.Println("  NEXMONYX_SERVER_SECRET")
                fmt.Println("\nTest types:")
                fmt.Println("  heartbeat       - Test basic heartbeat")
                fmt.Println("  update-details  - Test server details update")
                fmt.Println("  update-info     - Test server info update")
                fmt.Println("  get-heartbeat   - Test heartbeat retrieval")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("========================================")
        fmt.Println("Nexmonyx SDK Debug Test")
        fmt.Println("========================================")
        fmt.Printf("API URL: %s\n", *apiURL)
        fmt.Printf("Server UUID: %s\n", *serverUUID)
        fmt.Printf("Test Type: %s\n", *testType)
        fmt.Println("Debug Mode: ENABLED")
        fmt.Println("========================================")

        // Create client with debug mode enabled
        client, err := nexmonyx.NewClient(&amp;nexmonyx.Config{
                BaseURL: *apiURL,
                Auth: nexmonyx.AuthConfig{
                        ServerUUID:   *serverUUID,
                        ServerSecret: *serverSecret,
                },
                Debug: true, // Enable debug logging
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        switch *testType </span>{
        case "heartbeat":<span class="cov0" title="0">
                testHeartbeat(ctx, client)</span>
        case "update-details":<span class="cov0" title="0">
                testUpdateDetails(ctx, client, *serverUUID)</span>
        case "update-info":<span class="cov0" title="0">
                testUpdateInfo(ctx, client, *serverUUID)</span>
        default:<span class="cov0" title="0">
                log.Fatalf("Unknown test type: %s", *testType)</span>
        }
}

func testHeartbeat(ctx context.Context, client *nexmonyx.Client) <span class="cov0" title="0">{
        fmt.Println("\n=== Testing Heartbeat ===")

        // Test basic heartbeat
        err := client.Servers.Heartbeat(ctx)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("\n Heartbeat failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\n Heartbeat successful!\n")
        }</span>

        // Test heartbeat with version
        <span class="cov0" title="0">fmt.Println("\n=== Testing Heartbeat with Version ===")
        err = client.Servers.HeartbeatWithVersion(ctx, "v1.0.0")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("\n Heartbeat with version failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\n Heartbeat with version successful!\n")
        }</span>
}

func testUpdateDetails(ctx context.Context, client *nexmonyx.Client, serverUUID string) <span class="cov0" title="0">{
        fmt.Println("\n=== Testing Update Details ===")

        details := &amp;nexmonyx.ServerDetailsUpdateRequest{
                Hostname:     "debug-test-server",
                OS:           "Ubuntu 22.04 LTS",
                OSVersion:    "5.15.0-88-generic",
                OSArch:       "x86_64",
                CPUModel:     "Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz",
                CPUCores:     8,
                MemoryTotal:  16384 * 1024 * 1024,      // Convert MB to bytes
                StorageTotal: 500 * 1024 * 1024 * 1024, // Convert GB to bytes
        }

        server, err := client.Servers.UpdateDetails(ctx, serverUUID, details)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("\n Update details failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\n Update details successful!\n")
                if server != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Server ID: %d\n", server.ID)
                        fmt.Printf("Server UUID: %s\n", server.ServerUUID)
                        fmt.Printf("Server Hostname: %s\n", server.Hostname)
                }</span>
        }
}

func testUpdateInfo(ctx context.Context, client *nexmonyx.Client, serverUUID string) <span class="cov0" title="0">{
        fmt.Println("\n=== Testing Update Info ===")

        info := &amp;nexmonyx.ServerDetailsUpdateRequest{
                Hostname:     "debug-test-server-info",
                OS:           "Ubuntu 22.04 LTS",
                OSVersion:    "5.15.0-88-generic",
                OSArch:       "x86_64",
                CPUModel:     "Intel(R) Core(TM) i7-9700K CPU @ 3.60GHz",
                CPUCores:     8,
                MemoryTotal:  16384 * 1024 * 1024,      // Convert MB to bytes
                StorageTotal: 500 * 1024 * 1024 * 1024, // Convert GB to bytes
        }

        server, err := client.Servers.UpdateInfo(ctx, serverUUID, info)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("\n Update info failed: %v\n", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\n Update info successful!\n")
                if server != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Server ID: %d\n", server.ID)
                        fmt.Printf("Server UUID: %s\n", server.ServerUUID)
                        fmt.Printf("Server Hostname: %s\n", server.Hostname)
                }</span>
        }
}

</pre>
		
		<pre class="file" id="file18" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "time"

        "github.com/google/uuid"
        nexmonyx "github.com/nexmonyx/go-sdk/v2"
)

func main() <span class="cov0" title="0">{
        // Create client
        client, err := nexmonyx.NewClient(&amp;nexmonyx.Config{
                BaseURL: "https://api-dev.nexmonyx.com",
                Auth: nexmonyx.AuthConfig{
                        ServerUUID:   os.Getenv("SERVER_UUID"),
                        ServerSecret: os.Getenv("SERVER_SECRET"),
                },
                Debug: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">serverUUID, err := uuid.Parse(os.Getenv("SERVER_UUID"))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Invalid SERVER_UUID: %v", err)
        }</span>

        // Example 1: Submit ZFS pool metrics
        <span class="cov0" title="0">fmt.Println("=== Testing ZFS Pool Metrics ===")
        err = testZFSMetrics(client, serverUUID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ZFS test failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(" ZFS metrics submitted successfully")
        }</span>

        // Example 2: Submit RAID array metrics
        <span class="cov0" title="0">fmt.Println("\n=== Testing RAID Array Metrics ===")
        err = testRAIDMetrics(client, serverUUID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("RAID test failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(" RAID metrics submitted successfully")
        }</span>

        // Example 3: Submit LVM volume metrics
        <span class="cov0" title="0">fmt.Println("\n=== Testing LVM Volume Metrics ===")
        err = testLVMMetrics(client, serverUUID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("LVM test failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(" LVM metrics submitted successfully")
        }</span>

        // Example 4: Submit general filesystem metrics
        <span class="cov0" title="0">fmt.Println("\n=== Testing General Filesystem Metrics ===")
        err = testGeneralFilesystemMetrics(client, serverUUID)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("General filesystem test failed: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println(" General filesystem metrics submitted successfully")
        }</span>
}

func testZFSMetrics(client *nexmonyx.Client, serverUUID uuid.UUID) error <span class="cov0" title="0">{
        zfsMetrics := []nexmonyx.ZFSPoolMetrics{
                {
                        PoolName:                "zfspool",
                        TotalBytes:              ptrInt64(159175803469824),
                        UsedBytes:               ptrInt64(95505482081894),
                        AvailableBytes:          ptrInt64(63670321387930),
                        UsagePercent:            ptrFloat64(60.0),
                        Health:                  ptrString("ONLINE"),
                        State:                   ptrString("ACTIVE"),
                        CompressionRatio:        ptrFloat64(1.45),
                        DedupRatio:              ptrFloat64(1.0),
                        FragmentationPercent:    ptrFloat64(15.2),
                        AllocatedBytes:          ptrInt64(95505482081894),
                        ReferencedBytes:         ptrInt64(89234567890123),
                        SnapshotsCount:          ptrInt(12),
                        SnapshotSizeBytes:       ptrInt64(6270914191771),
                        ScrubState:              ptrString("completed"),
                        ScrubPercentComplete:    ptrFloat64(100.0),
                        ReadErrors:              ptrInt64(0),
                        WriteErrors:             ptrInt64(0),
                        ChecksumErrors:          ptrInt64(0),
                        OverallHealth:           "HEALTHY",
                        HealthScore:             ptrFloat64(98.5),
                        WarningCount:            0,
                        ErrorCount:              0,
                },
        }

        return client.Filesystem.SubmitZFS(context.Background(), serverUUID, zfsMetrics)
}</span>

func testRAIDMetrics(client *nexmonyx.Client, serverUUID uuid.UUID) error <span class="cov0" title="0">{
        raidMetrics := []nexmonyx.RAIDArrayMetrics{
                {
                        DeviceName:     "/dev/md0",
                        TotalBytes:     ptrInt64(2000398934016),
                        UsedBytes:      ptrInt64(1200239360409),
                        AvailableBytes: ptrInt64(800159573607),
                        UsagePercent:   ptrFloat64(60.0),
                        Level:          ptrString("raid1"),
                        State:          ptrString("clean"),
                        TotalDevices:   ptrInt(2),
                        ActiveDevices:  ptrInt(2),
                        SpareDevices:   ptrInt(0),
                        FailedDevices:  ptrInt(0),
                        ChunkSizeKB:    ptrInt(512),
                        OverallHealth:  "HEALTHY",
                        HealthScore:    ptrFloat64(100.0),
                        WarningCount:   0,
                        ErrorCount:     0,
                },
        }

        return client.Filesystem.SubmitRAID(context.Background(), serverUUID, raidMetrics)
}</span>

func testLVMMetrics(client *nexmonyx.Client, serverUUID uuid.UUID) error <span class="cov0" title="0">{
        lvmMetrics := []nexmonyx.LVMVolumeMetrics{
                {
                        LogicalVolumeName:         "root",
                        VolumeGroupName:          "vg0",
                        DevicePath:               ptrString("/dev/mapper/vg0-root"),
                        TotalBytes:               ptrInt64(107374182400),
                        UsedBytes:                ptrInt64(75161927680),
                        AvailableBytes:           ptrInt64(32212254720),
                        UsagePercent:             ptrFloat64(70.0),
                        PhysicalVolumeCount:      ptrInt(1),
                        LogicalVolumeCount:       ptrInt(3),
                        PhysicalExtentSize:       ptrInt64(4194304),
                        TotalPhysicalExtents:     ptrInt(25600),
                        FreePhysicalExtents:      ptrInt(7680),
                        AllocatedPhysicalExtents: ptrInt(17920),
                        VolumeGroupStatus:        ptrString("available"),
                        LogicalVolumeStatus:      ptrString("available"),
                        Attributes:               ptrString("-wi-ao----"),
                        OverallHealth:            "HEALTHY",
                        HealthScore:              ptrFloat64(95.0),
                        WarningCount:             0,
                        ErrorCount:               0,
                },
        }

        return client.Filesystem.SubmitLVM(context.Background(), serverUUID, lvmMetrics)
}</span>

func testGeneralFilesystemMetrics(client *nexmonyx.Client, serverUUID uuid.UUID) error <span class="cov0" title="0">{
        submission := &amp;nexmonyx.FilesystemMetricsSubmission{
                ServerUUID: serverUUID,
                Timestamp:  time.Now(),
                Filesystems: []nexmonyx.FilesystemMetricsData{
                        {
                                FilesystemName:   "/dev/sda1",
                                FilesystemType:   "ext4",
                                MountPoint:       ptrString("/boot"),
                                TotalBytes:       ptrInt64(1073741824),
                                UsedBytes:        ptrInt64(536870912),
                                AvailableBytes:   ptrInt64(536870912),
                                UsagePercent:     ptrFloat64(50.0),
                                ReadOpsPerSec:    ptrFloat64(10.5),
                                WriteOpsPerSec:   ptrFloat64(5.2),
                                ReadBytesPerSec:  ptrInt64(2097152),
                                WriteBytesPerSec: ptrInt64(1048576),
                                OverallHealth:    "HEALTHY",
                                HealthScore:      ptrFloat64(100.0),
                                WarningCount:     0,
                                ErrorCount:       0,
                        },
                },
        }

        return client.Filesystem.Submit(context.Background(), submission)
}</span>

// Helper functions for creating pointers
func ptrString(s string) *string <span class="cov0" title="0">{ return &amp;s }</span>
func ptrInt(i int) *int <span class="cov0" title="0">{ return &amp;i }</span>
func ptrInt64(i int64) *int64 <span class="cov0" title="0">{ return &amp;i }</span>
func ptrFloat64(f float64) *float64 <span class="cov0" title="0">{ return &amp;f }</pre>
		
		<pre class="file" id="file19" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "time"

        nexmonyx "github.com/nexmonyx/go-sdk/v2"
)

// DemoHardwareInventorySubmit demonstrates how to submit hardware inventory data
func DemoHardwareInventorySubmit() <span class="cov0" title="0">{
        // Create client with server credentials (used by agents)
        client, err := nexmonyx.NewClient(&amp;nexmonyx.Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: nexmonyx.AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Prepare hardware inventory data
        <span class="cov0" title="0">inventory := &amp;nexmonyx.HardwareInventoryRequest{
                ServerUUID:       "your-server-uuid",
                CollectedAt:      time.Now(),
                CollectionMethod: "dmidecode",
                Hardware: nexmonyx.HardwareInventoryInfo{
                        System: &amp;nexmonyx.SystemHardwareInfo{
                                Manufacturer: "Dell Inc.",
                                ProductName:  "PowerEdge R740",
                                SerialNumber: "ABC123DEF",
                                UUID:         "4C4C4544-0056-3810-8056-B8C04F303932",
                        },

                        // Motherboard
                        Motherboard: &amp;nexmonyx.MotherboardInfo{
                                Manufacturer: "Dell Inc.",
                                ProductName:  "0Y7WYT",
                                SerialNumber: "MB123456",
                                BIOS: &amp;nexmonyx.BIOSInfo{
                                        Vendor:      "Dell Inc.",
                                        Version:     "2.12.2",
                                        ReleaseDate: "05/07/2021",
                                },
                        },

                        // CPUs
                        CPUs: []nexmonyx.CPUInfo{
                                {
                                        Manufacturer: "Intel",
                                        Model:        "Xeon Gold 6230",
                                        Cores:        20,
                                        Threads:      40,
                                        BaseSpeedMHz: 2100,
                                        MaxSpeedMHz:  3900,
                                        CacheSizeKB:  28160, // 27.5MB
                                        Architecture: "x86_64",
                                        Socket:       "Socket 0",
                                },
                                {
                                        Manufacturer: "Intel",
                                        Model:        "Xeon Gold 6230",
                                        Cores:        20,
                                        Threads:      40,
                                        BaseSpeedMHz: 2100,
                                        MaxSpeedMHz:  3900,
                                        CacheSizeKB:  28160,
                                        Architecture: "x86_64",
                                        Socket:       "Socket 1",
                                },
                        },

                        // Memory
                        Memory: &amp;nexmonyx.MemoryInfo{
                                TotalSizeGB:   256,
                                TotalSlots:    24,
                                UsedSlots:     8,
                                MaxCapacityGB: 1536, // 64GB per slot * 24 slots
                                Modules: []nexmonyx.MemoryModuleInfo{
                                        {
                                                Slot:         "DIMM_A1",
                                                Manufacturer: "Samsung",
                                                PartNumber:   "M393A4K40CB2-CTD",
                                                SizeGB:       32,
                                                Type:         "DDR4",
                                                SpeedMHz:     2666,
                                                FormFactor:   "DIMM",
                                                SerialNumber: "00CE0123",
                                        },
                                        // Add more memory modules as needed
                                },
                        },

                        // Storage
                        Storage: []nexmonyx.StorageDeviceInfo{
                                {
                                        Model:           "SSD 860 EVO",
                                        Vendor:          "Samsung",
                                        SerialNumber:    "S3Y2NB0K123456",
                                        SizeGB:          931.5, // ~1TB
                                        Type:            "SSD",
                                        Interface:       "SATA",
                                        FirmwareVersion: "RVT04B6Q",
                                        SmartStatus:     "Good",
                                        PowerOnHours:    8760, // 1 year
                                },
                                {
                                        Model:           "970 EVO Plus",
                                        Vendor:          "Samsung",
                                        SerialNumber:    "S4EVNF0M123456",
                                        SizeGB:          465.8, // ~500GB
                                        Type:            "NVMe",
                                        Interface:       "NVMe",
                                        FirmwareVersion: "2B2QEXM7",
                                        SmartStatus:     "Good",
                                        Temperature:     42,
                                },
                        },

                        // Network Cards
                        Network: []nexmonyx.NetworkCardInfo{
                                {
                                        Model:         "Ethernet Controller X710 for 10GbE SFP+",
                                        Vendor:        "Intel Corporation",
                                        MACAddress:    "00:1B:21:AB:CD:EF",
                                        SpeedMbps:     10000, // 10Gbps
                                        PortCount:     4,
                                        Driver:        "i40e",
                                        DriverVersion: "2.17.15",
                                },
                        },

                        // GPUs (if present)
                        GPUs: []nexmonyx.GPUInfo{
                                {
                                        Model:         "Tesla V100-PCIE-32GB",
                                        Vendor:        "NVIDIA",
                                        MemoryGB:      32,
                                        Driver:        "nvidia",
                                        DriverVersion: "525.60.13",
                                        BusID:         "0000:3b:00.0",
                                        Temperature:   42,
                                },
                        },

                        // Power Supplies
                        PowerSupplies: []nexmonyx.PowerSupplyInfo{
                                {
                                        Model:         "EPP-1100-3AEEA",
                                        Manufacturer:  "Dell",
                                        SerialNumber:  "CN1797231B00EL",
                                        MaxPowerWatts: 1100,
                                        Type:          "AC",
                                        Status:        "OK",
                                        Efficiency:    "94% (Titanium)",
                                },
                                {
                                        Model:         "EPP-1100-3AEEA",
                                        Manufacturer:  "Dell",
                                        SerialNumber:  "CN1797231B00EM",
                                        MaxPowerWatts: 1100,
                                        Type:          "AC",
                                        Status:        "OK",
                                        Efficiency:    "94% (Titanium)",
                                },
                        },
                },
        }

        // Submit the hardware inventory
        response, err := client.HardwareInventory.Submit(context.Background(), inventory)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Hardware inventory submitted successfully!\n")
        fmt.Printf("Server UUID: %s\n", response.ServerUUID)
        fmt.Printf("Timestamp: %s\n", response.Timestamp)
        fmt.Printf("Component counts:\n")
        for component, count := range response.ComponentCounts </span><span class="cov0" title="0">{
                fmt.Printf("  %s: %d\n", component, count)
        }</span>
}

// DemoHardwareInventoryGet demonstrates how to get hardware inventory
func DemoHardwareInventoryGet() <span class="cov0" title="0">{
        // Create client with JWT token (for UI/admin access)
        client, err := nexmonyx.NewClient(&amp;nexmonyx.Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: nexmonyx.AuthConfig{
                        Token: "your-jwt-token",
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Get the hardware inventory for a server
        <span class="cov0" title="0">serverUUID := "your-server-uuid"
        inventory, err := client.HardwareInventory.Get(context.Background(), serverUUID)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Display system information
        <span class="cov0" title="0">if inventory.System != nil </span><span class="cov0" title="0">{
                fmt.Printf("Server: %s %s\n", inventory.System.Manufacturer, inventory.System.ProductName)
                fmt.Printf("Serial Number: %s\n", inventory.System.SerialNumber)
        }</span>

        // Display CPU information
        <span class="cov0" title="0">fmt.Printf("\nCPUs (%d):\n", len(inventory.CPUs))
        for i, cpu := range inventory.CPUs </span><span class="cov0" title="0">{
                fmt.Printf("  CPU %d: %s %s (%d cores, %d threads)\n",
                        i+1, cpu.Manufacturer, cpu.Model, cpu.Cores, cpu.Threads)
        }</span>

        // Display memory information
        <span class="cov0" title="0">if inventory.Memory != nil </span><span class="cov0" title="0">{
                fmt.Printf("\nMemory:\n")
                fmt.Printf("  Total Capacity: %.2f GB\n", inventory.Memory.TotalSizeGB)
                fmt.Printf("  Slots Used: %d/%d\n", inventory.Memory.UsedSlots, inventory.Memory.TotalSlots)
        }</span>

        // Display storage devices
        <span class="cov0" title="0">fmt.Printf("\nStorage Devices (%d):\n", len(inventory.Storage))
        for _, storage := range inventory.Storage </span><span class="cov0" title="0">{
                fmt.Printf("  %s %s (%.2f GB, %s)\n",
                        storage.Vendor, storage.Model, storage.SizeGB, storage.Type)
        }</span>

        // Display GPUs if present
        <span class="cov0" title="0">if len(inventory.GPUs) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nGPUs (%d):\n", len(inventory.GPUs))
                for _, gpu := range inventory.GPUs </span><span class="cov0" title="0">{
                        fmt.Printf("  %s %s (%.0f GB VRAM)\n",
                                gpu.Vendor, gpu.Model, gpu.MemoryGB)
                }</span>
        }
}

// DemoHardwareInventoryList demonstrates how to list hardware inventory history
func DemoHardwareInventoryList() <span class="cov0" title="0">{
        // Create client
        client, err := nexmonyx.NewClient(&amp;nexmonyx.Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: nexmonyx.AuthConfig{
                        Token: "your-jwt-token",
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // List hardware inventory with options
        <span class="cov0" title="0">opts := &amp;nexmonyx.ListOptions{
                Page:      1,
                Limit:     100,
                StartDate: time.Now().AddDate(0, 0, -30).Format(time.RFC3339),
                EndDate:   time.Now().Format(time.RFC3339),
        }

        inventories, meta, err := client.HardwareInventory.List(context.Background(), opts)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d hardware inventory records (page %d of %d)\n",
                len(inventories), meta.Page, meta.TotalPages)

        // Display inventory summaries
        for _, inventory := range inventories </span><span class="cov0" title="0">{
                if inventory.System != nil </span><span class="cov0" title="0">{
                        fmt.Printf("\nSystem: %s %s\n", inventory.System.Manufacturer, inventory.System.ProductName)
                }</span>
                <span class="cov0" title="0">fmt.Printf("  CPUs: %d\n", len(inventory.CPUs))
                if inventory.Memory != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  Memory: %.2f GB\n", inventory.Memory.TotalSizeGB)
                }</span>
                <span class="cov0" title="0">fmt.Printf("  Storage Devices: %d\n", len(inventory.Storage))
                fmt.Printf("  GPUs: %d\n", len(inventory.GPUs))</span>
        }
}

// DemoHardwareInventorySearch demonstrates how to search hardware
func DemoHardwareInventorySearch() <span class="cov0" title="0">{
        // Create client
        client, err := nexmonyx.NewClient(&amp;nexmonyx.Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: nexmonyx.AuthConfig{
                        Token: "your-jwt-token",
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        // Search for specific hardware
        <span class="cov0" title="0">search := &amp;nexmonyx.HardwareSearch{
                Manufacturer:  "Dell",
                Model:         "PowerEdge",
                ComponentType: "server",
        }

        inventories, meta, err := client.HardwareInventory.Search(context.Background(), search)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Found %d matching systems (page %d of %d)\n",
                len(inventories), meta.Page, meta.TotalPages)

        // Display search results
        for _, inventory := range inventories </span><span class="cov0" title="0">{
                if inventory.System != nil </span><span class="cov0" title="0">{
                        fmt.Printf("\nSystem: %s %s (S/N: %s)\n",
                                inventory.System.Manufacturer,
                                inventory.System.ProductName,
                                inventory.System.SerialNumber)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/nexmonyx/go-sdk/v2"
)

// AdvancedMonitoringAgent demonstrates a more realistic monitoring agent
// with concurrent probe execution, proper error handling, and graceful shutdown
type AdvancedMonitoringAgent struct {
        client           *nexmonyx.Client
        region           string
        agentID          string
        probes           []*nexmonyx.ProbeAssignment
        probeMutex       sync.RWMutex
        ctx              context.Context
        cancel           context.CancelFunc
        wg               sync.WaitGroup
        heartbeatTicker  *time.Ticker
        probeRefreshTicker *time.Ticker
        
        // Statistics
        stats struct {
                sync.RWMutex
                probesExecuted   int64
                probesSuccessful int64
                probesFailed     int64
                totalResponseTime int64
        }
}

func main() <span class="cov0" title="0">{
        // Get configuration from environment
        monitoringKey := os.Getenv("NEXMONYX_MONITORING_KEY")
        if monitoringKey == "" </span><span class="cov0" title="0">{
                log.Fatal("NEXMONYX_MONITORING_KEY environment variable is required")
        }</span>

        <span class="cov0" title="0">apiEndpoint := os.Getenv("NEXMONYX_API_ENDPOINT")
        if apiEndpoint == "" </span><span class="cov0" title="0">{
                apiEndpoint = "https://api.nexmonyx.com"
        }</span>

        <span class="cov0" title="0">region := os.Getenv("NEXMONYX_REGION")
        if region == "" </span><span class="cov0" title="0">{
                region = "us-east-1"
        }</span>

        <span class="cov0" title="0">agentID := os.Getenv("NEXMONYX_AGENT_ID")
        if agentID == "" </span><span class="cov0" title="0">{
                agentID = fmt.Sprintf("advanced-agent-%d", time.Now().Unix())
        }</span>

        // Create monitoring agent client
        <span class="cov0" title="0">client, err := nexmonyx.NewMonitoringAgentClient(&amp;nexmonyx.Config{
                BaseURL: apiEndpoint,
                Auth: nexmonyx.AuthConfig{
                        MonitoringKey: monitoringKey,
                },
                Debug:         os.Getenv("DEBUG") == "true",
                RetryCount:    3,
                RetryWaitTime: 2 * time.Second,
                RetryMaxWait:  30 * time.Second,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create monitoring agent client: %v", err)
        }</span>

        // Create agent instance
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        agent := &amp;AdvancedMonitoringAgent{
                client:             client,
                region:             region,
                agentID:            agentID,
                ctx:                ctx,
                cancel:             cancel,
                heartbeatTicker:    time.NewTicker(30 * time.Second),
                probeRefreshTicker: time.NewTicker(5 * time.Minute),
        }

        fmt.Printf("Starting advanced monitoring agent [ID: %s, Region: %s]\n", agentID, region)

        // Test authentication
        if err := client.HealthCheck(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Authentication failed: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(" Authentication successful")

        // Setup graceful shutdown
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        // Start agent
        agent.start()

        // Wait for shutdown signal
        &lt;-sigChan
        fmt.Println("\nReceived shutdown signal, stopping agent...")
        agent.stop()
        fmt.Println("Agent stopped gracefully")</span>
}

// start begins the agent's operation
func (a *AdvancedMonitoringAgent) start() <span class="cov0" title="0">{
        // Initial probe fetch
        if err := a.refreshProbes(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to fetch initial probes: %v", err)
        }</span>

        // Send initial heartbeat
        <span class="cov0" title="0">a.sendHeartbeat()

        // Start background routines
        a.wg.Add(3)
        go a.heartbeatLoop()
        go a.probeRefreshLoop()
        go a.probeExecutionLoop()

        fmt.Printf(" Agent started with %d probes\n", len(a.probes))</span>
}

// stop gracefully shuts down the agent
func (a *AdvancedMonitoringAgent) stop() <span class="cov0" title="0">{
        a.cancel()
        a.heartbeatTicker.Stop()
        a.probeRefreshTicker.Stop()
        
        // Send final heartbeat with unhealthy status
        nodeInfo := a.createNodeInfo()
        nodeInfo.Status = "stopping"
        if err := a.client.Monitoring.Heartbeat(context.Background(), nodeInfo); err != nil </span><span class="cov0" title="0">{
                // Log error but continue shutdown
                fmt.Printf("Warning: Failed to send final heartbeat: %v\n", err)
        }</span>
        
        <span class="cov0" title="0">a.wg.Wait()</span>
}

// heartbeatLoop sends periodic heartbeats
func (a *AdvancedMonitoringAgent) heartbeatLoop() <span class="cov0" title="0">{
        defer a.wg.Done()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-a.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-a.heartbeatTicker.C:<span class="cov0" title="0">
                        a.sendHeartbeat()</span>
                }
        }
}

// probeRefreshLoop periodically refreshes the probe assignments
func (a *AdvancedMonitoringAgent) probeRefreshLoop() <span class="cov0" title="0">{
        defer a.wg.Done()
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-a.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-a.probeRefreshTicker.C:<span class="cov0" title="0">
                        if err := a.refreshProbes(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("Failed to refresh probes: %v", err)
                        }</span>
                }
        }
}

// probeExecutionLoop executes probes based on their intervals
func (a *AdvancedMonitoringAgent) probeExecutionLoop() <span class="cov0" title="0">{
        defer a.wg.Done()
        
        ticker := time.NewTicker(10 * time.Second) // Check every 10 seconds
        defer ticker.Stop()
        
        lastExecution := make(map[uint]time.Time)
        
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-a.ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        a.probeMutex.RLock()
                        probes := make([]*nexmonyx.ProbeAssignment, len(a.probes))
                        copy(probes, a.probes)
                        a.probeMutex.RUnlock()
                        
                        now := time.Now()
                        var results []nexmonyx.ProbeExecutionResult
                        
                        for _, probe := range probes </span><span class="cov0" title="0">{
                                if !probe.Enabled </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                
                                <span class="cov0" title="0">lastExec, exists := lastExecution[probe.ProbeID]
                                if !exists || now.Sub(lastExec) &gt;= time.Duration(probe.Interval)*time.Second </span><span class="cov0" title="0">{
                                        result := a.executeProbe(probe)
                                        results = append(results, result)
                                        lastExecution[probe.ProbeID] = now
                                }</span>
                        }
                        
                        <span class="cov0" title="0">if len(results) &gt; 0 </span><span class="cov0" title="0">{
                                a.submitResults(results)
                        }</span>
                }
        }
}

// refreshProbes fetches the latest probe assignments
func (a *AdvancedMonitoringAgent) refreshProbes() error <span class="cov0" title="0">{
        probes, err := a.client.Monitoring.GetAssignedProbes(a.ctx, a.region)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov0" title="0">a.probeMutex.Lock()
        a.probes = probes
        a.probeMutex.Unlock()
        
        fmt.Printf(" Refreshed probes: %d assigned\n", len(probes))
        return nil</span>
}

// sendHeartbeat sends a heartbeat with current node information
func (a *AdvancedMonitoringAgent) sendHeartbeat() <span class="cov0" title="0">{
        nodeInfo := a.createNodeInfo()
        
        if err := a.client.Monitoring.Heartbeat(a.ctx, nodeInfo); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to send heartbeat: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf(" Heartbeat sent [Probes: %d, Success Rate: %.1f%%]\n", 
                        nodeInfo.ProbesAssigned, nodeInfo.SuccessRate)
        }</span>
}

// createNodeInfo creates current node information
func (a *AdvancedMonitoringAgent) createNodeInfo() nexmonyx.NodeInfo <span class="cov0" title="0">{
        a.stats.RLock()
        executed := a.stats.probesExecuted
        successful := a.stats.probesSuccessful
        failed := a.stats.probesFailed
        totalResponseTime := a.stats.totalResponseTime
        a.stats.RUnlock()
        
        a.probeMutex.RLock()
        probesAssigned := len(a.probes)
        a.probeMutex.RUnlock()
        
        var successRate float64
        if executed &gt; 0 </span><span class="cov0" title="0">{
                successRate = float64(successful) / float64(executed) * 100
        }</span>
        
        <span class="cov0" title="0">var avgResponseTime float64
        if successful &gt; 0 </span><span class="cov0" title="0">{
                avgResponseTime = float64(totalResponseTime) / float64(successful)
        }</span>
        
        <span class="cov0" title="0">hostname, _ := os.Hostname()
        
        return nexmonyx.NodeInfo{
                AgentID:            a.agentID,
                AgentVersion:       "1.0.0",
                Region:             a.region,
                Hostname:           hostname,
                IPAddress:          "10.0.1.100", // Mock IP
                Status:             "healthy",
                Uptime:             time.Since(time.Now().Add(-time.Hour)), // Mock uptime
                LastSeen:           time.Now(),
                ProbesAssigned:     probesAssigned,
                ProbesExecuted:     executed,
                ProbesSuccessful:   successful,
                ProbesFailed:       failed,
                SuccessRate:        successRate,
                AvgResponseTime:    avgResponseTime,
                MaxConcurrency:     10,
                SupportedTypes:     []string{"http", "https", "tcp", "icmp"},
                Capabilities:       []string{"tls_validation", "content_matching", "redirects"},
                Environment:        "production",
                Metadata: map[string]interface{}{
                        "go_version": "1.24",
                        "sdk_version": "1.2.0",
                },
        }</span>
}

// executeProbe executes a single probe and returns the result
func (a *AdvancedMonitoringAgent) executeProbe(probe *nexmonyx.ProbeAssignment) nexmonyx.ProbeExecutionResult <span class="cov0" title="0">{
        start := time.Now()
        
        // Simulate probe execution based on type
        var result nexmonyx.ProbeExecutionResult
        
        switch probe.Type </span>{
        case "http", "https":<span class="cov0" title="0">
                result = a.executeHTTPProbe(probe)</span>
        case "tcp":<span class="cov0" title="0">
                result = a.executeTCPProbe(probe)</span>
        case "icmp":<span class="cov0" title="0">
                result = a.executeICMPProbe(probe)</span>
        default:<span class="cov0" title="0">
                result = nexmonyx.ProbeExecutionResult{
                        ProbeID:    probe.ProbeID,
                        ProbeUUID:  probe.ProbeUUID,
                        ExecutedAt: start,
                        Region:     probe.Region,
                        Status:     "error",
                        Error:      fmt.Sprintf("unsupported probe type: %s", probe.Type),
                }</span>
        }
        
        // Update statistics
        <span class="cov0" title="0">a.stats.Lock()
        a.stats.probesExecuted++
        if result.Status == "success" </span><span class="cov0" title="0">{
                a.stats.probesSuccessful++
                a.stats.totalResponseTime += int64(result.ResponseTime)
        }</span> else<span class="cov0" title="0"> {
                a.stats.probesFailed++
        }</span>
        <span class="cov0" title="0">a.stats.Unlock()
        
        return result</span>
}

// executeHTTPProbe simulates HTTP/HTTPS probe execution
func (a *AdvancedMonitoringAgent) executeHTTPProbe(probe *nexmonyx.ProbeAssignment) nexmonyx.ProbeExecutionResult <span class="cov0" title="0">{
        // Simulate HTTP request timing
        // Safe conversion: uint  int for modulo operation (ProbeID is always &lt; max int)
        // #nosec G115 - Safe conversion in example code: modulo operation ensures value fits in int
        responseTime := 50 + int(probe.ProbeID%200) // Mock response time
        
        result := nexmonyx.ProbeExecutionResult{
                ProbeID:       probe.ProbeID,
                ProbeUUID:     probe.ProbeUUID,
                ExecutedAt:    time.Now(),
                Region:        probe.Region,
                Status:        "success",
                ResponseTime:  responseTime,
                StatusCode:    200,
                DNSTime:       10,
                ConnectTime:   20,
                TLSTime:       15,
                FirstByteTime: responseTime - 30,
                TotalTime:     responseTime,
                ResponseSize:  2048,
                ContentMatch:  &amp;[]bool{true}[0],
        }
        
        // Simulate occasional failures
        if probe.ProbeID%13 == 0 </span><span class="cov0" title="0">{
                result.Status = "failed"
                result.StatusCode = 500
                result.Error = "Internal server error"
                result.ContentMatch = &amp;[]bool{false}[0]
        }</span>
        
        <span class="cov0" title="0">return result</span>
}

// executeTCPProbe simulates TCP probe execution
func (a *AdvancedMonitoringAgent) executeTCPProbe(probe *nexmonyx.ProbeAssignment) nexmonyx.ProbeExecutionResult <span class="cov0" title="0">{
        // Safe conversion: perform modulo before conversion to avoid overflow
        // #nosec G115 - Safe conversion in example code: modulo operation ensures value fits in int
        responseTime := 20 + int(probe.ProbeID%50)
        
        return nexmonyx.ProbeExecutionResult{
                ProbeID:     probe.ProbeID,
                ProbeUUID:   probe.ProbeUUID,
                ExecutedAt:  time.Now(),
                Region:      probe.Region,
                Status:      "success",
                ResponseTime: responseTime,
                ConnectTime: responseTime,
                TotalTime:   responseTime,
        }
}</span>

// executeICMPProbe simulates ICMP probe execution
func (a *AdvancedMonitoringAgent) executeICMPProbe(probe *nexmonyx.ProbeAssignment) nexmonyx.ProbeExecutionResult <span class="cov0" title="0">{
        // Safe conversion: perform modulo before conversion to avoid overflow
        // #nosec G115 - Safe conversion in example code: modulo operation ensures value fits in int
        responseTime := 5 + int(probe.ProbeID%20)
        
        return nexmonyx.ProbeExecutionResult{
                ProbeID:      probe.ProbeID,
                ProbeUUID:    probe.ProbeUUID,
                ExecutedAt:   time.Now(),
                Region:       probe.Region,
                Status:       "success",
                ResponseTime: responseTime,
                TotalTime:    responseTime,
        }
}</span>

// submitResults submits probe execution results
func (a *AdvancedMonitoringAgent) submitResults(results []nexmonyx.ProbeExecutionResult) <span class="cov0" title="0">{
        if err := a.client.Monitoring.SubmitResults(a.ctx, results); err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to submit probe results: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf(" Submitted %d probe results\n", len(results))
        }</span>
}</pre>
		
		<pre class="file" id="file21" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"
        "time"

        "github.com/nexmonyx/go-sdk/v2"
)

// BasicMonitoringAgent demonstrates the basic functionality of a monitoring agent
// using the Nexmonyx Go SDK with MON_ key authentication
func main() <span class="cov0" title="0">{
        // Get monitoring key from environment
        monitoringKey := os.Getenv("NEXMONYX_MONITORING_KEY")
        if monitoringKey == "" </span><span class="cov0" title="0">{
                log.Fatal("NEXMONYX_MONITORING_KEY environment variable is required")
        }</span>

        // Get API endpoint (defaults to production if not set)
        <span class="cov0" title="0">apiEndpoint := os.Getenv("NEXMONYX_API_ENDPOINT")
        if apiEndpoint == "" </span><span class="cov0" title="0">{
                apiEndpoint = "https://api.nexmonyx.com"
        }</span>

        // Get region from environment (defaults to us-east-1)
        <span class="cov0" title="0">region := os.Getenv("NEXMONYX_REGION")
        if region == "" </span><span class="cov0" title="0">{
                region = "us-east-1"
        }</span>

        <span class="cov0" title="0">fmt.Printf("Starting monitoring agent for region: %s\n", region)

        // Create monitoring agent client
        client, err := nexmonyx.NewMonitoringAgentClient(&amp;nexmonyx.Config{
                BaseURL: apiEndpoint,
                Auth: nexmonyx.AuthConfig{
                        MonitoringKey: monitoringKey,
                },
                Debug: os.Getenv("DEBUG") == "true",
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create monitoring agent client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Test authentication with health check
        fmt.Println("Testing authentication...")
        if err := client.HealthCheck(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Authentication failed: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(" Authentication successful")

        // Get assigned probes for our region
        fmt.Printf("Fetching assigned probes for region: %s\n", region)
        probes, err := client.Monitoring.GetAssignedProbes(ctx, region)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to get assigned probes: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf(" Found %d assigned probes\n", len(probes))
        for i, probe := range probes </span><span class="cov0" title="0">{
                fmt.Printf("  %d. %s (%s) -&gt; %s (interval: %ds)\n", 
                        i+1, probe.Name, probe.Type, probe.Target, probe.Interval)
        }</span>

        // Create node info for heartbeat
        <span class="cov0" title="0">nodeInfo := nexmonyx.NodeInfo{
                AgentID:      "monitoring-agent-example",
                AgentVersion: "1.0.0",
                Region:       region,
                Hostname:     getHostname(),
                IPAddress:    getLocalIP(),
                Status:       "healthy",
                Uptime:       time.Hour * 2, // Example: agent has been running for 2 hours
                LastSeen:     time.Now(),
                ProbesAssigned: len(probes),
                SupportedTypes: []string{"http", "https", "tcp", "icmp"},
                MaxConcurrency: 10,
                Environment:    "production",
        }

        // Send heartbeat
        fmt.Println("Sending heartbeat...")
        if err := client.Monitoring.Heartbeat(ctx, nodeInfo); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to send heartbeat: %v", err)
        }</span>
        <span class="cov0" title="0">fmt.Println(" Heartbeat sent successfully")

        // Simulate executing probes and submitting results
        if len(probes) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Println("Simulating probe execution...")
                results := simulateProbeExecution(probes)
                
                if err := client.Monitoring.SubmitResults(ctx, results); err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to submit probe results: %v", err)
                }</span>
                
                <span class="cov0" title="0">fmt.Printf(" Submitted %d probe results\n", len(results))</span>
        }

        <span class="cov0" title="0">fmt.Println("Monitoring agent example completed successfully!")</span>
}

// simulateProbeExecution simulates executing probes and returns mock results
func simulateProbeExecution(probes []*nexmonyx.ProbeAssignment) []nexmonyx.ProbeExecutionResult <span class="cov0" title="0">{
        var results []nexmonyx.ProbeExecutionResult
        
        for _, probe := range probes </span><span class="cov0" title="0">{
                // Simulate successful probe execution
                result := nexmonyx.ProbeExecutionResult{
                        ProbeID:       probe.ProbeID,
                        ProbeUUID:     probe.ProbeUUID,
                        ExecutedAt:    time.Now(),
                        Region:        probe.Region,
                        Status:        "success",
                        ResponseTime:  150 + (len(probe.Target) % 100), // Mock response time
                        StatusCode:    200,
                        DNSTime:       10,
                        ConnectTime:   30,
                        TLSTime:       20,
                        FirstByteTime: 80,
                        TotalTime:     150,
                        ResponseSize:  1024,
                }
                
                // Occasionally simulate failures for demonstration
                if probe.ProbeID%7 == 0 </span><span class="cov0" title="0">{ // Every 7th probe "fails"
                        result.Status = "failed"
                        result.StatusCode = 500
                        result.Error = "Connection timeout"
                        result.ResponseTime = probe.Timeout * 1000 // Convert to milliseconds
                }</span>
                
                <span class="cov0" title="0">results = append(results, result)</span>
        }
        
        <span class="cov0" title="0">return results</span>
}

// getHostname returns the system hostname
func getHostname() string <span class="cov0" title="0">{
        hostname, err := os.Hostname()
        if err != nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">return hostname</span>
}

// getLocalIP returns a mock local IP address
func getLocalIP() string <span class="cov0" title="0">{
        // In a real implementation, you'd get the actual local IP
        return "10.0.1.100"
}</pre>
		
		<pre class="file" id="file22" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"

        "github.com/nexmonyx/go-sdk/v2"
)

func main() <span class="cov0" title="0">{
        // This example demonstrates how to manage monitoring agent keys
        // Both admin operations (for region enrollment) and customer operations (self-service)

        // For admin operations, use JWT token authentication
        adminConfig := &amp;nexmonyx.Config{
                BaseURL: "https://api-dev.nexmonyx.com", // Use dev environment
                Auth: nexmonyx.AuthConfig{
                        Token: os.Getenv("NEXMONYX_JWT_TOKEN"), // JWT token for admin access
                },
                Debug: true, // Enable debug logging
        }

        adminClient, err := nexmonyx.NewClient(adminConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create admin client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        fmt.Println("=== Admin Operations ===")

        // Admin: Create monitoring agent key for region enrollment
        adminKeyReq := &amp;nexmonyx.CreateMonitoringAgentKeyRequest{
                OrganizationID:     1, // Target organization ID
                RemoteClusterID:    nil, // No cluster restriction
                Description:        "Test region monitoring agent key",
                NamespaceName:      "test-region-agent",
                AgentType:          "public", // Public agent for Nexmonyx-managed regions
                RegionCode:         "NYC3",   // Required for public agents
                AllowedProbeScopes: []string{"public"},
                Capabilities:       `["probe:read","probe:write","node:register","node:heartbeat"]`,
        }

        fmt.Printf("Creating admin monitoring agent key...\n")
        agentKeyResp, err := adminClient.MonitoringAgentKeys.CreateAdmin(ctx, adminKeyReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create admin monitoring agent key: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf(" Created monitoring agent key: %s\n", agentKeyResp.FullToken)
                fmt.Printf("   Key ID: %s\n", agentKeyResp.KeyID)
                fmt.Printf("   Agent Type: %s\n", agentKeyResp.AgentType)
                fmt.Printf("   Allowed Scopes: %v\n", agentKeyResp.AllowedProbeScopes)
                fmt.Printf("   Description: %s\n", agentKeyResp.Key.Description)
        }</span>

        <span class="cov0" title="0">fmt.Println("\n=== Customer Operations ===")

        // For customer operations, use API key authentication or JWT token
        customerConfig := &amp;nexmonyx.Config{
                BaseURL: "https://api-dev.nexmonyx.com",
                Auth: nexmonyx.AuthConfig{
                        // You can use either JWT token or API key/secret
                        Token: os.Getenv("NEXMONYX_JWT_TOKEN"),
                        // Or: APIKey/APISecret for service authentication
                        // APIKey:    os.Getenv("NEXMONYX_API_KEY"),
                        // APISecret: os.Getenv("NEXMONYX_API_SECRET"),
                },
                Debug: true,
        }

        customerClient, err := nexmonyx.NewClient(customerConfig)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create customer client: %v", err)
        }</span>

        <span class="cov0" title="0">organizationID := "1" // Replace with actual organization UUID/ID

        // Customer: Create monitoring agent key for their own use
        fmt.Printf("Creating customer monitoring agent key...\n")
        privateKeyReq := nexmonyx.NewPrivateAgentKeyRequest(
                "Development environment monitoring",
                "dev-agent-1",
                "NYC3", // Optional region for private agents
        )
        customerKeyResp, err := customerClient.MonitoringAgentKeys.Create(ctx, 
                organizationID, 
                privateKeyReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create customer monitoring agent key: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf(" Created customer monitoring agent key: %s\n", customerKeyResp.FullToken)
                fmt.Printf("   Agent Type: %s\n", customerKeyResp.AgentType)
                fmt.Printf("   Allowed Scopes: %v\n", customerKeyResp.AllowedProbeScopes)
        }</span>

        // Customer: List monitoring agent keys
        <span class="cov0" title="0">fmt.Printf("\nListing monitoring agent keys...\n")
        keys, pagination, err := customerClient.MonitoringAgentKeys.List(ctx, organizationID, &amp;nexmonyx.ListMonitoringAgentKeysOptions{
                Page:  1,
                Limit: 10,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to list monitoring agent keys: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Found %d monitoring agent keys (page %d of %d):\n", 
                        len(keys), pagination.Page, pagination.TotalPages)
                for i, key := range keys </span><span class="cov0" title="0">{
                        fmt.Printf("  %d. %s - %s (%s) Type: %s, Region: %s\n", 
                                i+1, key.KeyID, key.Description, key.Status, key.AgentType, key.RegionCode)
                }</span>
        }

        // Example: Revoke a monitoring agent key (if needed)
        <span class="cov0" title="0">if len(keys) &gt; 0 &amp;&amp; keys[0].Status == "active" </span><span class="cov0" title="0">{
                fmt.Printf("\nRevoking monitoring agent key: %s...\n", keys[0].KeyID)
                err = customerClient.MonitoringAgentKeys.Revoke(ctx, organizationID, keys[0].KeyID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to revoke monitoring agent key: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf(" Successfully revoked monitoring agent key\n")
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("\n=== Usage Tips ===")
        fmt.Println("1. Admin operations require JWT token with admin privileges")
        fmt.Println("2. Customer operations work with JWT token or API key/secret")
        fmt.Println("3. The full token format is: mag_&lt;keyID&gt;.&lt;secretKey&gt;")
        fmt.Println("4. Use the full token in monitoring-agent configuration")
        fmt.Println("5. Keys can be filtered by namespace, cluster, or status")</span>
}</pre>
		
		<pre class="file" id="file23" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"

        "github.com/nexmonyx/go-sdk/v2"
)

func main() <span class="cov0" title="0">{
        // Create client with server authentication
        client, err := nexmonyx.NewClient(&amp;nexmonyx.Config{
                BaseURL: os.Getenv("NEXMONYX_API_URL"), // Default: https://api.nexmonyx.com
                Auth: nexmonyx.AuthConfig{
                        ServerUUID:   os.Getenv("SERVER_UUID"),
                        ServerSecret: os.Getenv("SERVER_SECRET"),
                },
                Debug: true, // Enable debug logging
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        // Example network interface data
        <span class="cov0" title="0">interfaces := []nexmonyx.NetworkHardwareInfo{
                {
                        InterfaceName:    "eth0",
                        InterfaceType:    "physical",
                        MacAddress:       "00:11:22:33:44:55",
                        DriverName:       "e1000e",
                        DriverVersion:    "3.2.6-k",
                        FirmwareVersion:  "1.2.3",
                        SpeedMbps:        1000,
                        Duplex:           "full",
                        MTU:              1500,
                        LinkDetected:     true,
                        OperationalState: "up",
                        IPAddresses:      []string{"192.168.1.100/24"},
                        IPv6Addresses:    []string{"fe80::211:22ff:fe33:4455/64"},
                        RxBytes:          1234567890,
                        TxBytes:          987654321,
                        RxPackets:        1000000,
                        TxPackets:        900000,
                },
                {
                        InterfaceName:    "bond0",
                        InterfaceType:    "bond",
                        MacAddress:       "00:11:22:33:44:66",
                        BondMode:         "802.3ad",
                        BondSlaves:       []string{"eth1", "eth2"},
                        BondActiveSlave:  "eth1",
                        LACPRate:         "slow",
                        SpeedMbps:        2000,
                        LinkDetected:     true,
                        OperationalState: "up",
                        MTU:              1500,
                },
                {
                        InterfaceName:      "br0",
                        InterfaceType:      "bridge",
                        MacAddress:         "00:11:22:33:44:77",
                        BridgePorts:        []string{"bond0.100"},
                        BridgeSTP:          true,
                        BridgeForwardDelay: 1500,
                        BridgeHelloTime:    200,
                        BridgeMaxAge:       2000,
                        LinkDetected:       true,
                        OperationalState:   "up",
                        IPAddresses:        []string{"10.0.0.1/24"},
                },
                {
                        InterfaceName:    "bond0.100",
                        InterfaceType:    "vlan",
                        VlanID:           100,
                        VlanParent:       "bond0",
                        MacAddress:       "00:11:22:33:44:66",
                        LinkDetected:     true,
                        OperationalState: "up",
                },
        }

        // Submit network hardware information
        ctx := context.Background()
        serverUUID := os.Getenv("SERVER_UUID")

        // Check for required environment variables
        if serverUUID == "" </span><span class="cov0" title="0">{
                log.Fatal("SERVER_UUID environment variable is required")
        }</span>

        <span class="cov0" title="0">serverSecret := os.Getenv("SERVER_SECRET")
        if serverSecret == "" </span><span class="cov0" title="0">{
                log.Fatal("SERVER_SECRET environment variable is required")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Starting network hardware submission for server: %s\n", serverUUID)
        fmt.Printf("Submitting %d network interfaces...\n", len(interfaces))

        resp, err := client.NetworkHardware.Submit(ctx, serverUUID, interfaces)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to submit network hardware: %v\n", err)
                fmt.Printf("Error type: %T\n", err)
                log.Fatalf("Submission failed")
        }</span>

        <span class="cov0" title="0">fmt.Printf("\n=== Network hardware submitted successfully ===\n")
        fmt.Printf("Status: %s\n", resp.Status)
        fmt.Printf("Message: %s\n", resp.Message)
        if resp.Data != nil </span><span class="cov0" title="0">{
                fmt.Printf("Data: %+v\n", resp.Data)
        }</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/nexmonyx/go-sdk/v2"
)

func main() <span class="cov0" title="0">{
        // Initialize the SDK client with server credentials
        client, err := nexmonyx.NewClient(&amp;nexmonyx.Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: nexmonyx.AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
                Debug: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Example 1: Submit service monitoring data as part of comprehensive metrics
        submitServiceMonitoringData(ctx, client)

        // Example 2: Monitor critical services
        monitorCriticalServices()

        // Example 3: Analyze service logs
        analyzeServiceLogs()

        // Example 4: Track service resource usage
        trackServiceResources()</span>
}

func submitServiceMonitoringData(ctx context.Context, client *nexmonyx.Client) <span class="cov0" title="0">{
        fmt.Println("=== Submitting Service Monitoring Data ===")

        // Create service info
        serviceInfo := nexmonyx.NewServiceInfo()

        // Add SSH service
        activeSince := time.Now().Add(-24 * time.Hour)
        serviceInfo.AddService(&amp;nexmonyx.ServiceMonitoringInfo{
                Name:          "ssh.service",
                State:         "active",
                SubState:      "running",
                LoadState:     "loaded",
                Description:   "OpenBSD Secure Shell server",
                MainPID:       163754,
                MemoryCurrent: 4308992,
                CPUUsageNSec:  890000000,
                TasksCurrent:  1,
                RestartCount:  0,
                ActiveSince:   &amp;activeSince,
        })

        // Add Nginx service (failed state)
        serviceInfo.AddService(&amp;nexmonyx.ServiceMonitoringInfo{
                Name:         "nginx.service",
                State:        "failed",
                SubState:     "failed",
                LoadState:    "loaded",
                Description:  "The nginx HTTP and reverse proxy server",
                MainPID:      0,
                RestartCount: 3,
        })

        // Add Cron service
        cronActiveSince := time.Now().Add(-48 * time.Hour)
        serviceInfo.AddService(&amp;nexmonyx.ServiceMonitoringInfo{
                Name:          "cron.service",
                State:         "active",
                SubState:      "running",
                LoadState:     "loaded",
                Description:   "Regular background program processing daemon",
                MainPID:       13969,
                MemoryCurrent: 679936,
                CPUUsageNSec:  1250000000,
                TasksCurrent:  1,
                ActiveSince:   &amp;cronActiveSince,
        })

        // Add service metrics
        serviceInfo.AddMetrics(nexmonyx.CreateServiceMetrics(
                "ssh.service",
                0.1,      // CPU percent
                4308992,  // Memory RSS
                1,        // Process count
                1,        // Thread count
        ))

        serviceInfo.AddMetrics(nexmonyx.CreateServiceMetrics(
                "cron.service",
                0.0,
                679936,
                1,
                1,
        ))

        // Add service logs
        serviceInfo.AddLogEntry("ssh.service", nexmonyx.ServiceLogEntry{
                Timestamp: time.Now().Add(-5 * time.Minute),
                Level:     "info",
                Message:   "Accepted publickey for user from 192.168.1.100 port 52847 ssh2",
                Fields: map[string]string{
                        "pid":  "163754",
                        "unit": "ssh.service",
                },
        })

        serviceInfo.AddLogEntry("nginx.service", nexmonyx.ServiceLogEntry{
                Timestamp: time.Now().Add(-1 * time.Hour),
                Level:     "error",
                Message:   "nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use)",
                Fields: map[string]string{
                        "unit": "nginx.service",
                },
        })

        // Display service summary
        fmt.Printf("Total services monitored: %d\n", len(serviceInfo.Services))
        stateCounts := serviceInfo.CountServicesByState()
        for state, count := range stateCounts </span><span class="cov0" title="0">{
                fmt.Printf("  %s: %d\n", state, count)
        }</span>

        <span class="cov0" title="0">failedServices := serviceInfo.GetFailedServices()
        if len(failedServices) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\nFailed services:\n")
                for _, service := range failedServices </span><span class="cov0" title="0">{
                        fmt.Printf("  - %s: %s\n", service.Name, service.Description)
                }</span>
        }

        // Submit as part of comprehensive metrics
        <span class="cov0" title="0">metricsRequest := &amp;nexmonyx.ComprehensiveMetricsRequest{
                ServerUUID:  "your-server-uuid",
                CollectedAt: time.Now().UTC().Format(time.RFC3339),
                Services:    serviceInfo,
                SystemInfo: &amp;nexmonyx.SystemInfo{
                        Hostname:      "server-01",
                        OS:            "Linux",
                        OSVersion:     "Ubuntu 22.04",
                        Architecture:  "x86_64",
                        Uptime:        172800, // 2 days
                        Processes:     150,
                },
        }

        err := client.Metrics.SubmitComprehensive(ctx, metricsRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to submit metrics: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Successfully submitted service monitoring data")
        }</span>
}

func monitorCriticalServices() <span class="cov0" title="0">{
        fmt.Println("\n=== Monitoring Critical Services ===")

        // Define critical services to monitor
        criticalServices := []string{
                "ssh.service",
                "systemd-resolved.service",
                "systemd-networkd.service",
                "cron.service",
        }

        // Create monitoring configuration
        config := nexmonyx.NewServiceMonitoringConfig()
        config.IncludeServices = criticalServices
        config.CollectMetrics = true
        config.CollectLogs = true

        // Simulate monitoring critical services
        serviceInfo := nexmonyx.NewServiceInfo()

        // Add some test services
        for _, serviceName := range criticalServices </span><span class="cov0" title="0">{
                if config.ShouldMonitorService(serviceName) </span><span class="cov0" title="0">{
                        fmt.Printf("Monitoring: %s\n", serviceName)
                        
                        // In a real implementation, you would query systemd for actual data
                        serviceInfo.AddService(&amp;nexmonyx.ServiceMonitoringInfo{
                                Name:      serviceName,
                                State:     "active",
                                SubState:  "running",
                                LoadState: "loaded",
                        })
                }</span>
        }

        // Check service health
        <span class="cov0" title="0">for _, service := range serviceInfo.Services </span><span class="cov0" title="0">{
                health := nexmonyx.GetServiceHealth(service)
                fmt.Printf("  %s health: %d%%\n", service.Name, health)
        }</span>
}

func analyzeServiceLogs() <span class="cov0" title="0">{
        fmt.Println("\n=== Analyzing Service Logs ===")

        serviceInfo := nexmonyx.NewServiceInfo()

        // Add sample logs
        serviceInfo.AddLogEntry("nginx.service", nexmonyx.CreateServiceLogEntry(
                "error",
                "upstream timed out (110: Connection timed out) while reading response header",
        ))

        serviceInfo.AddLogEntry("mysql.service", nexmonyx.CreateServiceLogEntry(
                "warning",
                "Aborted connection 12345 to db: 'app_db' user: 'app_user' host: 'localhost'",
        ))

        serviceInfo.AddLogEntry("ssh.service", nexmonyx.CreateServiceLogEntry(
                "info",
                "Server listening on 0.0.0.0 port 22",
        ))

        serviceInfo.AddLogEntry("nginx.service", nexmonyx.CreateServiceLogEntry(
                "error",
                "open() \"/var/cache/nginx/proxy_temp/1/02/0000000021\" failed (13: Permission denied)",
        ))

        // Get all error logs
        errorLogs := serviceInfo.GetErrorLogs()
        fmt.Printf("Found %d services with errors:\n", len(errorLogs))
        
        for serviceName, logs := range errorLogs </span><span class="cov0" title="0">{
                fmt.Printf("\n%s errors:\n", serviceName)
                for _, log := range logs </span><span class="cov0" title="0">{
                        fmt.Printf("  [%s] %s\n", log.Timestamp.Format("15:04:05"), log.Message)
                }</span>
        }
}

func trackServiceResources() <span class="cov0" title="0">{
        fmt.Println("\n=== Tracking Service Resource Usage ===")

        serviceInfo := nexmonyx.NewServiceInfo()

        // Add services with varying resource usage
        services := []struct {
                name   string
                memory uint64
                cpu    uint64
        }{
                {"mysql.service", 2147483648, 5000000000},      // 2GB memory, 5s CPU
                {"nginx.service", 134217728, 1000000000},       // 128MB memory, 1s CPU
                {"redis.service", 536870912, 2000000000},       // 512MB memory, 2s CPU
                {"elasticsearch.service", 4294967296, 10000000000}, // 4GB memory, 10s CPU
        }

        for _, svc := range services </span><span class="cov0" title="0">{
                activeSince := time.Now().Add(-72 * time.Hour)
                serviceInfo.AddService(&amp;nexmonyx.ServiceMonitoringInfo{
                        Name:          svc.name,
                        State:         "active",
                        SubState:      "running",
                        MemoryCurrent: svc.memory,
                        CPUUsageNSec:  svc.cpu,
                        ActiveSince:   &amp;activeSince,
                })
        }</span>

        // Calculate totals
        <span class="cov0" title="0">totalMemory := serviceInfo.CalculateTotalMemoryUsage()
        totalCPU := serviceInfo.CalculateTotalCPUTime()

        fmt.Printf("Total memory usage: %.2f GB\n", float64(totalMemory)/(1024*1024*1024))
        fmt.Printf("Total CPU time: %s\n", totalCPU)

        // Find high memory services (&gt; 1GB)
        highMemServices := serviceInfo.GetHighMemoryServices(1024 * 1024 * 1024)
        fmt.Printf("\nServices using &gt; 1GB memory:\n")
        for _, service := range highMemServices </span><span class="cov0" title="0">{
                fmt.Printf("  %s: %.2f GB (uptime: %s)\n", 
                        service.Name, 
                        float64(service.MemoryCurrent)/(1024*1024*1024),
                        nexmonyx.FormatServiceUptime(service.ActiveSince))
        }</span>

        // Add metrics for trend analysis
        <span class="cov0" title="0">for _, service := range serviceInfo.Services </span><span class="cov0" title="0">{
                cpuPercent := float64(service.CPUUsageNSec) / float64(time.Since(*service.ActiveSince).Nanoseconds()) * 100

                // Safe conversion: uint64  int with overflow check
                // Note: In production, validate that TasksCurrent fits in int range
                threadCount := int(service.TasksCurrent)
                if service.TasksCurrent &gt; uint64(^uint(0)&gt;&gt;1) </span><span class="cov0" title="0">{ // Check if exceeds max int
                        threadCount = int(^uint(0) &gt;&gt; 1) // Cap at max int value
                }</span>

                <span class="cov0" title="0">serviceInfo.AddMetrics(&amp;nexmonyx.ServiceMetrics{
                        ServiceName:  service.Name,
                        Timestamp:    time.Now(),
                        CPUPercent:   cpuPercent,
                        MemoryRSS:    service.MemoryCurrent,
                        ProcessCount: 1,
                        ThreadCount:  threadCount,
                })</span>
        }

        // Display latest metrics
        <span class="cov0" title="0">fmt.Printf("\nLatest metrics:\n")
        for _, service := range serviceInfo.Services </span><span class="cov0" title="0">{
                metrics := serviceInfo.GetServiceMetrics(service.Name)
                if metrics != nil </span><span class="cov0" title="0">{
                        fmt.Printf("  %s: CPU %.2f%%, Memory %.2f GB\n",
                                service.Name,
                                metrics.CPUPercent,
                                float64(metrics.MemoryRSS)/(1024*1024*1024))
                }</span>
        }
}</pre>
		
		<pre class="file" id="file25" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "time"

        "github.com/nexmonyx/go-sdk/v2"
)

func main() <span class="cov0" title="0">{
        // Initialize the SDK client with server credentials
        client, err := nexmonyx.NewClient(&amp;nexmonyx.Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: nexmonyx.AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
                Debug: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Example 1: Submit temperature and power metrics as part of comprehensive metrics
        submitTemperatureAndPowerMetrics(ctx, client)

        // Example 2: Update hardware inventory with temperature sensors
        updateHardwareInventoryWithSensors(ctx, client)

        // Example 3: Submit real-time temperature alerts
        monitorTemperatureThresholds(ctx, client)</span>
}

func submitTemperatureAndPowerMetrics(ctx context.Context, client *nexmonyx.Client) <span class="cov0" title="0">{
        fmt.Println("=== Submitting Temperature and Power Metrics ===")

        // Create temperature metrics
        tempMetrics := nexmonyx.NewTemperatureMetrics()

        // Add CPU temperature sensors
        for i := 0; i &lt; 4; i++ </span><span class="cov0" title="0">{
                temp := 45.0 + float64(i)*2.0 // Simulate varying temperatures
                sensor := nexmonyx.CreateCPUTemperatureSensor(i, temp)
                tempMetrics.AddTemperatureSensor(sensor)
        }</span>

        // Add system temperature sensors
        <span class="cov0" title="0">tempMetrics.AddTemperatureSensor(nexmonyx.TemperatureSensorData{
                SensorID:      "inlet_temp",
                SensorName:    "Inlet Temperature",
                Temperature:   26.0,
                Status:        "ok",
                Type:          "system",
                Location:      "chassis_front",
                UpperWarning:  35.0,
                UpperCritical: 40.0,
        })

        tempMetrics.AddTemperatureSensor(nexmonyx.TemperatureSensorData{
                SensorID:      "exhaust_temp",
                SensorName:    "Exhaust Temperature",
                Temperature:   46.0,
                Status:        "ok",
                Type:          "system",
                Location:      "chassis_rear",
                UpperWarning:  55.0,
                UpperCritical: 65.0,
        })

        // Add disk temperature sensors
        disks := []string{"/dev/sda", "/dev/sdb", "/dev/sdc"}
        for _, disk := range disks </span><span class="cov0" title="0">{
                temp := 30.0 + float64(len(disk))*1.5 // Simulate varying temperatures
                sensor := nexmonyx.CreateDiskTemperatureSensor(disk, temp)
                tempMetrics.AddTemperatureSensor(sensor)
        }</span>

        // Create power metrics
        <span class="cov0" title="0">powerMetrics := nexmonyx.NewPowerMetrics()

        // Add power supply metrics
        powerMetrics.AddPowerSupply(nexmonyx.PowerSupplyMetrics{
                ID:            "ps1",
                Name:          "Power Supply 1",
                Status:        "ok",
                PowerWatts:    196.0,
                MaxPowerWatts: 750.0,
                Voltage:       124.0,
                Current:       1.6,
                Efficiency:    94.5,
                Temperature:   38.0,
        })

        powerMetrics.AddPowerSupply(nexmonyx.PowerSupplyMetrics{
                ID:            "ps2",
                Name:          "Power Supply 2",
                Status:        "ok",
                PowerWatts:    196.0,
                MaxPowerWatts: 750.0,
                Voltage:       122.0,
                Current:       1.6,
                Efficiency:    94.2,
                Temperature:   39.0,
        })

        // Display summary
        maxTemp, maxSensor := tempMetrics.GetMaxTemperature()
        fmt.Printf("Max Temperature: %.1fC (Sensor: %s)\n", maxTemp, maxSensor)
        fmt.Printf("Total Power Draw: %.1fW\n", powerMetrics.TotalPowerW)
        fmt.Printf("Average PSU Efficiency: %.1f%%\n", powerMetrics.CalculateAverageEfficiency())

        // Create comprehensive metrics request
        metricsRequest := &amp;nexmonyx.ComprehensiveMetricsRequest{
                ServerUUID:  "your-server-uuid",
                CollectedAt: time.Now().UTC().Format(time.RFC3339),
                Temperature: tempMetrics,
                Power:       powerMetrics,
                // Include other metrics as needed
                SystemInfo: &amp;nexmonyx.SystemInfo{
                        Hostname:      "server-01",
                        OS:            "Linux",
                        OSVersion:     "Ubuntu 22.04",
                        Kernel:        "Linux",
                        KernelVersion: "5.15.0-88-generic",
                        Architecture:  "x86_64",
                        Uptime:        86400,
                        BootTime:      time.Now().Add(-24 * time.Hour).Unix(),
                        Processes:     150,
                },
        }

        // Submit the metrics
        err := client.Metrics.SubmitComprehensive(ctx, metricsRequest)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to submit metrics: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Successfully submitted temperature and power metrics")
        }</span>
}

func updateHardwareInventoryWithSensors(ctx context.Context, client *nexmonyx.Client) <span class="cov0" title="0">{
        fmt.Println("\n=== Updating Hardware Inventory with Temperature Sensors ===")

        // Create temperature sensor inventory
        tempSensors := []nexmonyx.TemperatureSensorInfo{
                {
                        SensorID:   "coretemp_package",
                        SensorName: "CPU Package Temperature",
                        Type:       "cpu",
                        Location:   "processor",
                        MaxTemp:    100.0,
                        MinTemp:    0.0,
                },
                {
                        SensorID:   "pch_temp",
                        SensorName: "PCH Temperature",
                        Type:       "chipset",
                        Location:   "motherboard",
                        MaxTemp:    90.0,
                        MinTemp:    0.0,
                },
                {
                        SensorID:   "dimm_a1_temp",
                        SensorName: "DIMM A1 Temperature",
                        Type:       "memory",
                        Location:   "memory_slot_a1",
                        MaxTemp:    85.0,
                        MinTemp:    0.0,
                },
                {
                        SensorID:   "nvme0_temp",
                        SensorName: "NVMe SSD 0 Temperature",
                        Type:       "storage",
                        Location:   "m2_slot_0",
                        MaxTemp:    70.0,
                        MinTemp:    0.0,
                },
        }

        // Create enhanced power supply info
        powerSupplies := []nexmonyx.PowerSupplyInfo{
                {
                        Model:             "Dell EPP-750AB A",
                        Manufacturer:      "Dell",
                        SerialNumber:      "CN-0VDTVR-17973-123-4567",
                        MaxPowerWatts:     750,
                        Type:              "AC",
                        Status:            "ok",
                        Efficiency:        "80 Plus Platinum",
                        CurrentPowerWatts: 196.0,
                        Voltage:           124.0,
                        Current:           1.6,
                        Temperature:       38.0,
                        FanSpeed:          2400,
                        InputVoltage:      120.0,
                        OutputVoltage:     12.0,
                },
                {
                        Model:             "Dell EPP-750AB A",
                        Manufacturer:      "Dell",
                        SerialNumber:      "CN-0VDTVR-17973-123-4568",
                        MaxPowerWatts:     750,
                        Type:              "AC",
                        Status:            "ok",
                        Efficiency:        "80 Plus Platinum",
                        CurrentPowerWatts: 196.0,
                        Voltage:           122.0,
                        Current:           1.6,
                        Temperature:       39.0,
                        FanSpeed:          2450,
                        InputVoltage:      120.0,
                        OutputVoltage:     12.0,
                },
        }

        // Create hardware inventory request
        // Note: In a real implementation, you would submit this to the appropriate endpoint
        inventoryRequest := &amp;nexmonyx.HardwareInventoryRequest{
                ServerUUID:  "your-server-uuid",
                CollectedAt: time.Now(),
                Hardware: nexmonyx.HardwareInventoryInfo{
                        TemperatureSensors: tempSensors,
                        PowerSupplies:     powerSupplies,
                        // Include other hardware components as needed
                        System: &amp;nexmonyx.SystemHardwareInfo{
                                Manufacturer: "Dell Inc.",
                                ProductName:  "PowerEdge R720xd",
                                Version:      "01",
                                SerialNumber: "ABC1234",
                        },
                },
                CollectionMethod: "agent",
        }

        // Note: You'll need to use the appropriate API endpoint for hardware inventory updates
        // This is a placeholder for the actual API call
        fmt.Printf("Hardware inventory prepared with %d temperature sensors and %d power supplies\n",
                len(inventoryRequest.Hardware.TemperatureSensors), 
                len(inventoryRequest.Hardware.PowerSupplies))
}</span>

func monitorTemperatureThresholds(ctx context.Context, client *nexmonyx.Client) <span class="cov0" title="0">{
        fmt.Println("\n=== Monitoring Temperature Thresholds ===")

        // Simulate temperature monitoring loop
        for i := 0; i &lt; 3; i++ </span><span class="cov0" title="0">{
                tempMetrics := nexmonyx.NewTemperatureMetrics()

                // Simulate a temperature spike
                cpuTemp := 45.0
                if i == 1 </span><span class="cov0" title="0">{
                        cpuTemp = 82.0 // Warning threshold
                }</span> else<span class="cov0" title="0"> if i == 2 </span><span class="cov0" title="0">{
                        cpuTemp = 92.0 // Critical threshold
                }</span>

                <span class="cov0" title="0">sensor := nexmonyx.CreateCPUTemperatureSensor(0, cpuTemp)
                tempMetrics.AddTemperatureSensor(sensor)

                // Check status
                fmt.Printf("Iteration %d: CPU Temperature: %.1fC - Status: %s\n",
                        i+1, cpuTemp, sensor.Status)

                // In a real implementation, you might send alerts or notifications
                // when temperature exceeds thresholds
                if sensor.Status == "warning" </span><span class="cov0" title="0">{
                        fmt.Println("    WARNING: CPU temperature is high!")
                }</span> else<span class="cov0" title="0"> if sensor.Status == "critical" </span><span class="cov0" title="0">{
                        fmt.Println("   CRITICAL: CPU temperature is critical!")
                }</span>

                <span class="cov0" title="0">time.Sleep(2 * time.Second)</span>
        }
}</pre>
		
		<pre class="file" id="file26" style="display: none">package main

import (
        "context"
        "flag"
        "fmt"
        "log"
        "os"
        "time"

        nexmonyx "github.com/nexmonyx/go-sdk/v2"
)

func main() <span class="cov0" title="0">{
        // Command line flags
        var (
                apiURL       = flag.String("api", "https://api.nexmonyx.com", "API endpoint URL")
                serverUUID   = flag.String("uuid", "", "Server UUID")
                serverSecret = flag.String("secret", "", "Server Secret")
                debug        = flag.Bool("debug", false, "Enable debug mode")
        )
        flag.Parse()

        // Check for environment variables if flags not provided
        if *serverUUID == "" </span><span class="cov0" title="0">{
                *serverUUID = os.Getenv("NEXMONYX_SERVER_UUID")
        }</span>
        <span class="cov0" title="0">if *serverSecret == "" </span><span class="cov0" title="0">{
                *serverSecret = os.Getenv("NEXMONYX_SERVER_SECRET")
        }</span>

        // Validate required parameters
        <span class="cov0" title="0">if *serverUUID == "" || *serverSecret == "" </span><span class="cov0" title="0">{
                fmt.Println("Usage: test_metrics -uuid &lt;SERVER_UUID&gt; -secret &lt;SERVER_SECRET&gt; [-api &lt;API_URL&gt;] [-debug]")
                fmt.Println("\nAlternatively, set environment variables:")
                fmt.Println("  NEXMONYX_SERVER_UUID")
                fmt.Println("  NEXMONYX_SERVER_SECRET")
                os.Exit(1)
        }</span>

        // Create client with server credentials
        <span class="cov0" title="0">client, err := nexmonyx.NewClient(&amp;nexmonyx.Config{
                BaseURL: *apiURL,
                Auth: nexmonyx.AuthConfig{
                        ServerUUID:   *serverUUID,
                        ServerSecret: *serverSecret,
                },
                Debug: *debug,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Test metrics submission
        fmt.Println("Testing metrics submission with fixed headers...")
        fmt.Printf("Server UUID: %s\n", *serverUUID)
        fmt.Printf("API URL: %s\n", *apiURL)
        fmt.Printf("SDK Version: %s\n", nexmonyx.Version)
        fmt.Println()

        metrics := &amp;nexmonyx.ComprehensiveMetricsRequest{
                ServerUUID:  *serverUUID,
                CollectedAt: time.Now().UTC().Format(time.RFC3339),
                CPU: &amp;nexmonyx.CPUMetrics{
                        UsagePercent: 45.5,
                },
                Memory: &amp;nexmonyx.MemoryMetrics{
                        TotalBytes:     8589934592, // 8GB
                        AvailableBytes: 4294967296, // 4GB
                        UsedBytes:      4294967296, // 4GB
                        FreeBytes:      4294967296, // 4GB
                },
        }

        err = client.Metrics.SubmitComprehensive(ctx, metrics)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf(" Metrics submission failed: %v\n", err)
                fmt.Println("\nThis indicates the authentication headers issue is NOT fixed.")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println(" Metrics submission successful!")
        fmt.Println("\nThe SDK is now correctly using 'Server-UUID' and 'Server-Secret' headers.")
        fmt.Println("Authentication is working correctly for the metrics endpoint.")</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package main

import (
        "context"
        "fmt"
        "log"
        "os"

        nexmonyx "github.com/nexmonyx/go-sdk/v2"
)

func main() <span class="cov0" title="0">{
        // Example of using the unified API key system

        // Create a client with admin authentication (using JWT token)
        adminClient, err := nexmonyx.NewClient(&amp;nexmonyx.Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: nexmonyx.AuthConfig{
                        Token: os.Getenv("NEXMONYX_ADMIN_TOKEN"),
                },
                Debug: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create admin client: %v", err)
        }</span>

        <span class="cov0" title="0">ctx := context.Background()

        // Example 1: Create a user API key
        fmt.Println("=== Creating User API Key ===")
        userKeyReq := nexmonyx.NewUserAPIKey(
                "My User API Key",
                "API key for user operations",
                []string{nexmonyx.CapabilityServersRead, nexmonyx.CapabilityMetricsRead},
        )

        userKeyResp, err := adminClient.APIKeys.CreateUnified(ctx, userKeyReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create user API key: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Created user API key: %s\n", userKeyResp.KeyID)
                fmt.Printf("Key value (save this): %s\n", userKeyResp.KeyValue)
                fmt.Printf("Secret (save this): %s\n", userKeyResp.Secret)
        }</span>

        // Example 2: Create a monitoring agent key
        <span class="cov0" title="0">fmt.Println("\n=== Creating Monitoring Agent Key ===")
        agentKeyReq := nexmonyx.NewMonitoringAgentKey(
                "Private Monitoring Agent",
                "Agent for internal monitoring",
                "production",
                "private",
                "us-east-1",
                []string{"public", "private"},
        )

        agentKeyResp, err := adminClient.APIKeys.CreateUnified(ctx, agentKeyReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create monitoring agent key: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Created monitoring agent key: %s\n", agentKeyResp.KeyID)
                fmt.Printf("Full token (save this): %s\n", agentKeyResp.FullToken)
        }</span>

        // Example 3: Create a registration key
        <span class="cov0" title="0">fmt.Println("\n=== Creating Registration Key ===")
        regKeyReq := nexmonyx.NewRegistrationKey(
                "Server Registration Key",
                "For registering new servers",
                1, // Organization ID
        )

        regKeyResp, err := adminClient.APIKeys.AdminCreateUnified(ctx, regKeyReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to create registration key: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Created registration key: %s\n", regKeyResp.KeyID)
                fmt.Printf("Registration token: %s\n", regKeyResp.FullToken)
        }</span>

        // Example 4: Using the unified API key for authentication
        <span class="cov0" title="0">if userKeyResp != nil </span><span class="cov0" title="0">{
                fmt.Println("\n=== Using User API Key ===")
                
                // Create a client with the user API key
                userClient := adminClient.WithUnifiedAPIKeyAndSecret(userKeyResp.KeyValue, userKeyResp.Secret)
                
                // List servers using the user key
                servers, meta, err := userClient.Servers.List(ctx, &amp;nexmonyx.ListOptions{
                        Page:  1,
                        Limit: 10,
                })
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to list servers with user key: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Listed %d servers (total %d)\n", len(servers), meta.TotalItems)
                }</span>
        }

        // Example 5: Using monitoring agent key
        <span class="cov0" title="0">if agentKeyResp != nil </span><span class="cov0" title="0">{
                fmt.Println("\n=== Using Monitoring Agent Key ===")
                
                // Create a client with the monitoring agent key (bearer token)
                agentClient := adminClient.WithUnifiedAPIKey(agentKeyResp.FullToken)
                
                // This would typically be used for probe execution or metrics submission
                fmt.Printf("Monitoring agent client created with key: %s\n", agentKeyResp.KeyID)
                
                // Example: Check if the agent client is working
                _ = agentClient // Use the variable to avoid unused error
        }</span>

        // Example 6: Using registration key for server registration
        <span class="cov0" title="0">if regKeyResp != nil </span><span class="cov0" title="0">{
                fmt.Println("\n=== Using Registration Key ===")
                
                // Create a client with the registration key
                regClient := adminClient.WithRegistrationKey(regKeyResp.FullToken)
                
                // Register a new server
                serverReq := &amp;nexmonyx.ServerCreateRequest{
                        Hostname:       "test-server-001",
                        MainIP:         "192.168.1.100",
                        OS:             "Linux",
                        OSVersion:      "Ubuntu 22.04",
                        OSArch:         "x86_64",
                        SerialNumber:   "TEST001",
                        MacAddress:     "aa:bb:cc:dd:ee:ff",
                        Environment:    "testing",
                        Location:       "Test Lab",
                        Classification: "test",
                }

                server, err := regClient.Servers.RegisterWithKey(ctx, regKeyResp.FullToken, serverReq)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to register server: %v", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Registered server: %s (UUID: %s)\n", server.Hostname, server.ServerUUID)
                }</span>
        }

        // Example 7: List and manage API keys
        <span class="cov0" title="0">fmt.Println("\n=== Managing API Keys ===")
        
        // List all API keys (admin only)
        keys, meta, err := adminClient.APIKeys.AdminListUnified(ctx, &amp;nexmonyx.ListUnifiedAPIKeysOptions{
                ListOptions: nexmonyx.ListOptions{Page: 1, Limit: 10},
                Status:      nexmonyx.APIKeyStatusActive,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to list API keys: %v", err)
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Found %d active API keys (total %d)\n", len(keys), meta.TotalItems)
                for _, key := range keys </span><span class="cov0" title="0">{
                        fmt.Printf("- %s (%s): %s\n", key.Name, key.Type, key.KeyID)
                }</span>
        }

        // Example 8: Key validation and capabilities
        <span class="cov0" title="0">if len(keys) &gt; 0 </span><span class="cov0" title="0">{
                key := keys[0]
                fmt.Printf("\n=== Key Information: %s ===\n", key.Name)
                fmt.Printf("Type: %s\n", key.Type)
                fmt.Printf("Status: %s\n", key.Status)
                fmt.Printf("Active: %t\n", key.IsActive())
                fmt.Printf("Can register servers: %t\n", key.CanRegisterServers())
                fmt.Printf("Is monitoring agent: %t\n", key.IsMonitoringAgent())
                fmt.Printf("Auth method: %s\n", key.GetAuthenticationMethod())
                fmt.Printf("Capabilities: %v\n", key.Capabilities)
                
                // Check specific capabilities
                if key.HasCapability(nexmonyx.CapabilityServersRead) </span><span class="cov0" title="0">{
                        fmt.Println(" Can read servers")
                }</span>
                <span class="cov0" title="0">if key.HasCapability(nexmonyx.CapabilityMetricsSubmit) </span><span class="cov0" title="0">{
                        fmt.Println(" Can submit metrics")
                }</span>
        }

        <span class="cov0" title="0">fmt.Println("\n=== Example completed ===")</span>
}</pre>
		
		<pre class="file" id="file28" style="display: none">package nexmonyx

import (
        "context"
        "time"

        "github.com/google/uuid"
)

// FilesystemService handles advanced filesystem metrics operations
type FilesystemService struct {
        client *Client
}

// FilesystemMetricsSubmission represents the payload for submitting filesystem metrics
type FilesystemMetricsSubmission struct {
        ServerUUID  uuid.UUID                     `json:"server_uuid"`
        Timestamp   time.Time                     `json:"timestamp"`
        Filesystems []FilesystemMetricsData       `json:"filesystems"`
}

// FilesystemMetricsData represents filesystem metrics for a single filesystem
type FilesystemMetricsData struct {
        FilesystemName string  `json:"filesystem_name"`
        FilesystemType string  `json:"filesystem_type"` // 'zfs', 'lvm', 'mdraid', 'btrfs', 'ext4', 'xfs', 'ntfs'
        MountPoint     *string `json:"mount_point,omitempty"`
        DevicePath     *string `json:"device_path,omitempty"`

        // Storage capacity metrics
        TotalBytes     *int64   `json:"total_bytes,omitempty"`
        UsedBytes      *int64   `json:"used_bytes,omitempty"`
        AvailableBytes *int64   `json:"available_bytes,omitempty"`
        ReservedBytes  *int64   `json:"reserved_bytes,omitempty"`
        UsagePercent   *float64 `json:"usage_percent,omitempty"`

        // ZFS-specific metrics
        ZFSPoolName             *string    `json:"zfs_pool_name,omitempty"`
        ZFSDatasetName          *string    `json:"zfs_dataset_name,omitempty"`
        ZFSPoolHealth           *string    `json:"zfs_pool_health,omitempty"` // 'ONLINE', 'DEGRADED', 'FAULTED', 'OFFLINE'
        ZFSPoolState            *string    `json:"zfs_pool_state,omitempty"`  // 'ACTIVE', 'EXPORTED', 'DESTROYED', 'SPARE'
        ZFSCompressionRatio     *float64   `json:"zfs_compression_ratio,omitempty"`
        ZFSDedupRatio           *float64   `json:"zfs_dedup_ratio,omitempty"`
        ZFSFragmentationPercent *float64   `json:"zfs_fragmentation_percent,omitempty"`
        ZFSAllocatedBytes       *int64     `json:"zfs_allocated_bytes,omitempty"`
        ZFSReferencedBytes      *int64     `json:"zfs_referenced_bytes,omitempty"`
        ZFSSnapshotsCount       *int       `json:"zfs_snapshots_count,omitempty"`
        ZFSSnapshotSizeBytes    *int64     `json:"zfs_snapshot_size_bytes,omitempty"`

        // ZFS pool operations
        ZFSScrubState                    *string    `json:"zfs_scrub_state,omitempty"`
        ZFSScrubPercentComplete          *float64   `json:"zfs_scrub_percent_complete,omitempty"`
        ZFSScrubLastRun                  *time.Time `json:"zfs_scrub_last_run,omitempty"`
        ZFSResilverState                 *string    `json:"zfs_resilver_state,omitempty"`
        ZFSResilverPercentComplete       *float64   `json:"zfs_resilver_percent_complete,omitempty"`
        ZFSResilverEstimatedCompletion   *time.Time `json:"zfs_resilver_estimated_completion,omitempty"`

        // ZFS error counters
        ZFSReadErrors     *int64 `json:"zfs_read_errors,omitempty"`
        ZFSWriteErrors    *int64 `json:"zfs_write_errors,omitempty"`
        ZFSChecksumErrors *int64 `json:"zfs_checksum_errors,omitempty"`

        // LVM-specific metrics
        LVMVGName      *string `json:"lvm_vg_name,omitempty"`
        LVMLVName      *string `json:"lvm_lv_name,omitempty"`
        LVMPVCount     *int    `json:"lvm_pv_count,omitempty"`
        LVMLVCount     *int    `json:"lvm_lv_count,omitempty"`
        LVMPESizeBytes *int64  `json:"lvm_pe_size_bytes,omitempty"`
        LVMTotalPE     *int    `json:"lvm_total_pe,omitempty"`
        LVMFreePE      *int    `json:"lvm_free_pe,omitempty"`
        LVMAllocatedPE *int    `json:"lvm_allocated_pe,omitempty"`
        LVMVGStatus    *string `json:"lvm_vg_status,omitempty"`
        LVMLVStatus    *string `json:"lvm_lv_status,omitempty"`
        LVMAttributes  *string `json:"lvm_attributes,omitempty"`

        // RAID-specific metrics
        RAIDLevel         *string  `json:"raid_level,omitempty"` // 'raid0', 'raid1', 'raid4', 'raid5', 'raid6', 'raid10'
        RAIDDeviceName    *string  `json:"raid_device_name,omitempty"`
        RAIDState         *string  `json:"raid_state,omitempty"` // 'active', 'inactive', 'clean', 'degraded'
        RAIDTotalDevices  *int     `json:"raid_total_devices,omitempty"`
        RAIDActiveDevices *int     `json:"raid_active_devices,omitempty"`
        RAIDSpareDevices  *int     `json:"raid_spare_devices,omitempty"`
        RAIDFailedDevices *int     `json:"raid_failed_devices,omitempty"`
        RAIDSyncPercent   *float64 `json:"raid_sync_percent,omitempty"`
        RAIDReshapePercent *float64 `json:"raid_reshape_percent,omitempty"`
        RAIDChunkSizeKB   *int     `json:"raid_chunk_size_kb,omitempty"`

        // BTRFS-specific metrics
        BTRFSFilesystemUUID  *string  `json:"btrfs_filesystem_uuid,omitempty"`
        BTRFSTotalDevices    *int     `json:"btrfs_total_devices,omitempty"`
        BTRFSRAIDType        *string  `json:"btrfs_raid_type,omitempty"`
        BTRFSAllocationRatio *float64 `json:"btrfs_allocation_ratio,omitempty"`
        BTRFSDataRatio       *float64 `json:"btrfs_data_ratio,omitempty"`
        BTRFSMetadataRatio   *float64 `json:"btrfs_metadata_ratio,omitempty"`

        // Performance metrics
        ReadOpsPerSec     *float64 `json:"read_ops_per_sec,omitempty"`
        WriteOpsPerSec    *float64 `json:"write_ops_per_sec,omitempty"`
        ReadBytesPerSec   *int64   `json:"read_bytes_per_sec,omitempty"`
        WriteBytesPerSec  *int64   `json:"write_bytes_per_sec,omitempty"`
        AvgReadLatencyMs  *float64 `json:"avg_read_latency_ms,omitempty"`
        AvgWriteLatencyMs *float64 `json:"avg_write_latency_ms,omitempty"`
        QueueDepth        *float64 `json:"queue_depth,omitempty"`

        // Health and status indicators
        OverallHealth string   `json:"overall_health"` // 'HEALTHY', 'WARNING', 'CRITICAL', 'UNKNOWN'
        HealthScore   *float64 `json:"health_score,omitempty"`
        WarningCount  int      `json:"warning_count"`
        ErrorCount    int      `json:"error_count"`

        // Alerts and warnings
        CriticalAlerts  []string `json:"critical_alerts,omitempty"`
        WarningMessages []string `json:"warning_messages,omitempty"`

        // Raw metrics for extensibility
        RawMetrics map[string]interface{} `json:"raw_metrics,omitempty"`
}

// Submit submits filesystem metrics to the API
func (s *FilesystemService) Submit(ctx context.Context, submission *FilesystemMetricsSubmission) error <span class="cov0" title="0">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v2/metrics/filesystem",
                Body:   submission,
                Result: &amp;resp,
        })
        return err
}</span>

// SubmitZFS is a convenience method for submitting ZFS-specific metrics
func (s *FilesystemService) SubmitZFS(ctx context.Context, serverUUID uuid.UUID, zfsMetrics []ZFSPoolMetrics) error <span class="cov0" title="0">{
        submission := &amp;FilesystemMetricsSubmission{
                ServerUUID:  serverUUID,
                Timestamp:   time.Now(),
                Filesystems: make([]FilesystemMetricsData, 0, len(zfsMetrics)),
        }

        for _, pool := range zfsMetrics </span><span class="cov0" title="0">{
                filesystemData := FilesystemMetricsData{
                        FilesystemName:          pool.PoolName,
                        FilesystemType:          "zfs",
                        MountPoint:              pool.MountPoint,
                        TotalBytes:              pool.TotalBytes,
                        UsedBytes:               pool.UsedBytes,
                        AvailableBytes:          pool.AvailableBytes,
                        UsagePercent:            pool.UsagePercent,
                        ZFSPoolName:             &amp;pool.PoolName,
                        ZFSPoolHealth:           pool.Health,
                        ZFSPoolState:            pool.State,
                        ZFSCompressionRatio:     pool.CompressionRatio,
                        ZFSDedupRatio:           pool.DedupRatio,
                        ZFSFragmentationPercent: pool.FragmentationPercent,
                        ZFSAllocatedBytes:       pool.AllocatedBytes,
                        ZFSReferencedBytes:      pool.ReferencedBytes,
                        ZFSSnapshotsCount:       pool.SnapshotsCount,
                        ZFSSnapshotSizeBytes:    pool.SnapshotSizeBytes,
                        ZFSScrubState:           pool.ScrubState,
                        ZFSScrubPercentComplete: pool.ScrubPercentComplete,
                        ZFSReadErrors:           pool.ReadErrors,
                        ZFSWriteErrors:          pool.WriteErrors,
                        ZFSChecksumErrors:       pool.ChecksumErrors,
                        OverallHealth:           pool.OverallHealth,
                        HealthScore:             pool.HealthScore,
                        WarningCount:            pool.WarningCount,
                        ErrorCount:              pool.ErrorCount,
                }
                submission.Filesystems = append(submission.Filesystems, filesystemData)
        }</span>

        <span class="cov0" title="0">return s.Submit(ctx, submission)</span>
}

// SubmitRAID is a convenience method for submitting RAID-specific metrics
func (s *FilesystemService) SubmitRAID(ctx context.Context, serverUUID uuid.UUID, raidMetrics []RAIDArrayMetrics) error <span class="cov0" title="0">{
        submission := &amp;FilesystemMetricsSubmission{
                ServerUUID:  serverUUID,
                Timestamp:   time.Now(),
                Filesystems: make([]FilesystemMetricsData, 0, len(raidMetrics)),
        }

        for _, raid := range raidMetrics </span><span class="cov0" title="0">{
                filesystemData := FilesystemMetricsData{
                        FilesystemName:    raid.DeviceName,
                        FilesystemType:    "mdraid",
                        MountPoint:        raid.MountPoint,
                        TotalBytes:        raid.TotalBytes,
                        UsedBytes:         raid.UsedBytes,
                        AvailableBytes:    raid.AvailableBytes,
                        UsagePercent:      raid.UsagePercent,
                        RAIDLevel:         raid.Level,
                        RAIDDeviceName:    &amp;raid.DeviceName,
                        RAIDState:         raid.State,
                        RAIDTotalDevices:  raid.TotalDevices,
                        RAIDActiveDevices: raid.ActiveDevices,
                        RAIDSpareDevices:  raid.SpareDevices,
                        RAIDFailedDevices: raid.FailedDevices,
                        RAIDSyncPercent:   raid.SyncPercent,
                        RAIDChunkSizeKB:   raid.ChunkSizeKB,
                        OverallHealth:     raid.OverallHealth,
                        HealthScore:       raid.HealthScore,
                        WarningCount:      raid.WarningCount,
                        ErrorCount:        raid.ErrorCount,
                }
                submission.Filesystems = append(submission.Filesystems, filesystemData)
        }</span>

        <span class="cov0" title="0">return s.Submit(ctx, submission)</span>
}

// SubmitLVM is a convenience method for submitting LVM-specific metrics
func (s *FilesystemService) SubmitLVM(ctx context.Context, serverUUID uuid.UUID, lvmMetrics []LVMVolumeMetrics) error <span class="cov0" title="0">{
        submission := &amp;FilesystemMetricsSubmission{
                ServerUUID:  serverUUID,
                Timestamp:   time.Now(),
                Filesystems: make([]FilesystemMetricsData, 0, len(lvmMetrics)),
        }

        for _, lvm := range lvmMetrics </span><span class="cov0" title="0">{
                filesystemData := FilesystemMetricsData{
                        FilesystemName: lvm.LogicalVolumeName,
                        FilesystemType: "lvm",
                        MountPoint:     lvm.MountPoint,
                        DevicePath:     lvm.DevicePath,
                        TotalBytes:     lvm.TotalBytes,
                        UsedBytes:      lvm.UsedBytes,
                        AvailableBytes: lvm.AvailableBytes,
                        UsagePercent:   lvm.UsagePercent,
                        LVMVGName:      &amp;lvm.VolumeGroupName,
                        LVMLVName:      &amp;lvm.LogicalVolumeName,
                        LVMPVCount:     lvm.PhysicalVolumeCount,
                        LVMLVCount:     lvm.LogicalVolumeCount,
                        LVMPESizeBytes: lvm.PhysicalExtentSize,
                        LVMTotalPE:     lvm.TotalPhysicalExtents,
                        LVMFreePE:      lvm.FreePhysicalExtents,
                        LVMAllocatedPE: lvm.AllocatedPhysicalExtents,
                        LVMVGStatus:    lvm.VolumeGroupStatus,
                        LVMLVStatus:    lvm.LogicalVolumeStatus,
                        LVMAttributes:  lvm.Attributes,
                        OverallHealth:  lvm.OverallHealth,
                        HealthScore:    lvm.HealthScore,
                        WarningCount:   lvm.WarningCount,
                        ErrorCount:     lvm.ErrorCount,
                }
                submission.Filesystems = append(submission.Filesystems, filesystemData)
        }</span>

        <span class="cov0" title="0">return s.Submit(ctx, submission)</span>
}

// Convenience types for specific storage technologies
type ZFSPoolMetrics struct {
        PoolName                string
        MountPoint              *string
        TotalBytes              *int64
        UsedBytes               *int64
        AvailableBytes          *int64
        UsagePercent            *float64
        Health                  *string
        State                   *string
        CompressionRatio        *float64
        DedupRatio              *float64
        FragmentationPercent    *float64
        AllocatedBytes          *int64
        ReferencedBytes         *int64
        SnapshotsCount          *int
        SnapshotSizeBytes       *int64
        ScrubState              *string
        ScrubPercentComplete    *float64
        ReadErrors              *int64
        WriteErrors             *int64
        ChecksumErrors          *int64
        OverallHealth           string
        HealthScore             *float64
        WarningCount            int
        ErrorCount              int
}

type RAIDArrayMetrics struct {
        DeviceName    string
        MountPoint    *string
        TotalBytes    *int64
        UsedBytes     *int64
        AvailableBytes *int64
        UsagePercent  *float64
        Level         *string
        State         *string
        TotalDevices  *int
        ActiveDevices *int
        SpareDevices  *int
        FailedDevices *int
        SyncPercent   *float64
        ChunkSizeKB   *int
        OverallHealth string
        HealthScore   *float64
        WarningCount  int
        ErrorCount    int
}

type LVMVolumeMetrics struct {
        LogicalVolumeName         string
        VolumeGroupName          string
        MountPoint               *string
        DevicePath               *string
        TotalBytes               *int64
        UsedBytes                *int64
        AvailableBytes           *int64
        UsagePercent             *float64
        PhysicalVolumeCount      *int
        LogicalVolumeCount       *int
        PhysicalExtentSize       *int64
        TotalPhysicalExtents     *int
        FreePhysicalExtents      *int
        AllocatedPhysicalExtents *int
        VolumeGroupStatus        *string
        LogicalVolumeStatus      *string
        Attributes               *string
        OverallHealth            string
        HealthScore              *float64
        WarningCount             int
        ErrorCount               int
}</pre>
		
		<pre class="file" id="file29" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// Submit submits hardware inventory for a server
func (s *HardwareInventoryService) Submit(ctx context.Context, inventory *HardwareInventoryRequest) (*HardwareInventorySubmitResponse, error) <span class="cov10" title="2">{
        var resp map[string]HardwareInventorySubmitResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v2/hardware/inventory",
                Body:   inventory,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if data, ok := resp["data"]; ok </span><span class="cov1" title="1">{
                return &amp;data, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response format")</span>
}

// GetInventory retrieves hardware inventory for a server
func (s *HardwareInventoryService) Get(ctx context.Context, serverUUID string) (*HardwareInventoryInfo, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;HardwareInventoryInfo{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/hardware-inventory/%s", serverUUID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if inventory, ok := resp.Data.(*HardwareInventoryInfo); ok </span><span class="cov1" title="1">{
                return inventory, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ListInventory retrieves hardware inventory for multiple servers
func (s *HardwareInventoryService) List(ctx context.Context, opts *ListOptions) ([]*HardwareInventoryInfo, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp PaginatedResponse
        var inventories []*HardwareInventoryInfo
        resp.Data = &amp;inventories

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/hardware-inventory",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return inventories, resp.Meta, nil</span>
}

// GetInventoryHistory retrieves historical hardware inventory data
func (s *HardwareInventoryService) GetHistory(ctx context.Context, serverUUID string, opts *ListOptions) ([]*HardwareInventoryInfo, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp PaginatedResponse
        var inventories []*HardwareInventoryInfo
        resp.Data = &amp;inventories

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/hardware-inventory/%s/history", serverUUID),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return inventories, resp.Meta, nil</span>
}

// GetInventoryChanges retrieves hardware changes for a server
func (s *HardwareInventoryService) GetChanges(ctx context.Context, serverUUID string, timeRange *QueryTimeRange) ([]HardwareChange, error) <span class="cov1" title="1">{
        var resp StandardResponse
        var changes []HardwareChange
        resp.Data = &amp;changes

        query := make(map[string]string)
        if timeRange != nil </span><span class="cov1" title="1">{
                start, end := timeRange.ToStrings()
                query["start"] = start
                query["end"] = end
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/hardware-inventory/%s/changes", serverUUID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return changes, nil</span>
}

// SearchInventory searches hardware inventory
func (s *HardwareInventoryService) Search(ctx context.Context, search *HardwareSearch) ([]*HardwareInventoryInfo, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp PaginatedResponse
        var inventories []*HardwareInventoryInfo
        resp.Data = &amp;inventories

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/hardware-inventory/search",
                Body:   search,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return inventories, resp.Meta, nil</span>
}

// ExportInventory exports hardware inventory data
func (s *HardwareInventoryService) Export(ctx context.Context, format string, serverUUIDs []string) ([]byte, error) <span class="cov1" title="1">{
        body := map[string]interface{}{
                "format":       format,
                "server_uuids": serverUUIDs,
        }

        resp, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/hardware-inventory/export",
                Body:   body,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Body, nil</span>
}

// GetHardwareInventory retrieves hardware inventory for a server within a time range
func (s *HardwareInventoryService) GetHardwareInventory(ctx context.Context, serverUUID string, timeRange *TimeRange) ([]*HardwareInventoryRecord, error) <span class="cov1" title="1">{
        var resp map[string][]*HardwareInventoryRecord

        query := make(map[string]string)
        if timeRange != nil </span><span class="cov1" title="1">{
                query["start"] = timeRange.Start
                query["end"] = timeRange.End
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v2/hardware/inventory/%s", serverUUID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if data, ok := resp["data"]; ok </span><span class="cov1" title="1">{
                return data, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response format")</span>
}

// GetLatestHardwareInventory retrieves the latest hardware inventory for a server
func (s *HardwareInventoryService) GetLatestHardwareInventory(ctx context.Context, serverUUID string) (*HardwareInventoryRecord, error) <span class="cov10" title="2">{
        var resp map[string]*HardwareInventoryRecord

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v2/hardware/inventory/%s/latest", serverUUID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if data, ok := resp["data"]; ok </span><span class="cov1" title="1">{
                return data, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response format")</span>
}

// HardwareChange represents a hardware change event
type HardwareChange struct {
        ID            uint        `json:"id"`
        ServerUUID    string      `json:"server_uuid"`
        ComponentType string      `json:"component_type"`
        ChangeType    string      `json:"change_type"` // added, removed, modified
        OldValue      interface{} `json:"old_value,omitempty"`
        NewValue      interface{} `json:"new_value,omitempty"`
        ChangedAt     *CustomTime `json:"changed_at"`
        Details       string      `json:"details,omitempty"`
}

// HardwareSearch represents hardware search parameters
type HardwareSearch struct {
        Manufacturer  string   `json:"manufacturer,omitempty"`
        Model         string   `json:"model,omitempty"`
        SerialNumber  string   `json:"serial_number,omitempty"`
        ComponentType string   `json:"component_type,omitempty"`
        ServerUUIDs   []string `json:"server_uuids,omitempty"`
        Tags          []string `json:"tags,omitempty"`
}

// ListHardwareHistory retrieves hardware inventory history for a server
func (s *HardwareInventoryService) ListHardwareHistory(ctx context.Context, serverUUID string, opts *HardwareInventoryListOptions) ([]*HardwareInventoryRecord, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp PaginatedResponse
        var records []*HardwareInventoryRecord
        resp.Data = &amp;records

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v2/hardware/inventory/%s/history", serverUUID),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return records, resp.Meta, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
        "time"
)

// GetHealth retrieves the health status of the API
func (s *HealthService) GetHealth(ctx context.Context) (*HealthStatus, error) <span class="cov10" title="12">{
        var resp StandardResponse
        resp.Data = &amp;HealthStatus{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/healthz",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov6" title="5">{
                return nil, err
        }</span>

        <span class="cov8" title="7">if health, ok := resp.Data.(*HealthStatus); ok </span><span class="cov8" title="7">{
                return health, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetHealthDetailed retrieves detailed health status
func (s *HealthService) GetHealthDetailed(ctx context.Context) (*DetailedHealthStatus, error) <span class="cov4" title="3">{
        var resp StandardResponse
        resp.Data = &amp;DetailedHealthStatus{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/health/detailed",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">if health, ok := resp.Data.(*DetailedHealthStatus); ok </span><span class="cov3" title="2">{
                return health, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// List retrieves all health checks
func (s *HealthService) List(ctx context.Context, opts *HealthCheckListOptions) ([]HealthCheck, *PaginationMeta, error) <span class="cov4" title="3">{
        var resp PaginatedResponse
        resp.Data = &amp;[]HealthCheck{}

        query := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.ServerID != nil </span><span class="cov1" title="1">{
                        query["server_id"] = fmt.Sprintf("%d", *opts.ServerID)
                }</span>
                <span class="cov1" title="1">if opts.CheckType != nil </span><span class="cov1" title="1">{
                        query["check_type"] = *opts.CheckType
                }</span>
                <span class="cov1" title="1">if opts.IsEnabled != nil </span><span class="cov1" title="1">{
                        if *opts.IsEnabled </span><span class="cov1" title="1">{
                                query["is_enabled"] = "true"
                        }</span> else<span class="cov0" title="0"> {
                                query["is_enabled"] = "false"
                        }</span>
                }
                <span class="cov1" title="1">if opts.ListOptions.Page &gt; 0 </span><span class="cov1" title="1">{
                        query["page"] = fmt.Sprintf("%d", opts.ListOptions.Page)
                }</span>
                <span class="cov1" title="1">if opts.ListOptions.Limit &gt; 0 </span><span class="cov1" title="1">{
                        query["limit"] = fmt.Sprintf("%d", opts.ListOptions.Limit)
                }</span>
                <span class="cov1" title="1">if opts.ListOptions.Sort != "" </span><span class="cov0" title="0">{
                        query["sort"] = opts.ListOptions.Sort
                }</span>
                <span class="cov1" title="1">if opts.ListOptions.Order != "" </span><span class="cov0" title="0">{
                        query["order"] = opts.ListOptions.Order
                }</span>
        }

        <span class="cov4" title="3">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/health/checks",
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov3" title="2">if checks, ok := resp.Data.(*[]HealthCheck); ok </span><span class="cov3" title="2">{
                return *checks, resp.Meta, nil
        }</span>
        <span class="cov0" title="0">return nil, nil, fmt.Errorf("unexpected response type")</span>
}

// Get retrieves a specific health check by ID
func (s *HealthService) Get(ctx context.Context, id uint) (*HealthCheck, error) <span class="cov4" title="3">{
        var resp StandardResponse
        resp.Data = &amp;HealthCheck{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/health/checks/%d", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if check, ok := resp.Data.(*HealthCheck); ok </span><span class="cov1" title="1">{
                return check, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// Create creates a new health check
func (s *HealthService) Create(ctx context.Context, req *CreateHealthCheckRequest) (*HealthCheck, error) <span class="cov4" title="3">{
        var resp StandardResponse
        resp.Data = &amp;HealthCheck{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/health/checks",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if check, ok := resp.Data.(*HealthCheck); ok </span><span class="cov1" title="1">{
                return check, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// Update updates an existing health check
func (s *HealthService) Update(ctx context.Context, id uint, req *UpdateHealthCheckRequest) (*HealthCheck, error) <span class="cov4" title="3">{
        var resp StandardResponse
        resp.Data = &amp;HealthCheck{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/health/checks/%d", id),
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if check, ok := resp.Data.(*HealthCheck); ok </span><span class="cov1" title="1">{
                return check, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// Delete removes a health check
func (s *HealthService) Delete(ctx context.Context, id uint) error <span class="cov6" title="4">{
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/health/checks/%d", id),
        })
        return err
}</span>

// GetHistory retrieves health check history
func (s *HealthService) GetHistory(ctx context.Context, opts *HealthCheckHistoryListOptions) ([]HealthCheckHistory, *PaginationMeta, error) <span class="cov6" title="4">{
        var resp PaginatedResponse
        resp.Data = &amp;[]HealthCheckHistory{}

        query := make(map[string]string)
        if opts != nil </span><span class="cov3" title="2">{
                if opts.HealthCheckID != nil </span><span class="cov3" title="2">{
                        query["health_check_id"] = fmt.Sprintf("%d", *opts.HealthCheckID)
                }</span>
                <span class="cov3" title="2">if opts.ServerID != nil </span><span class="cov1" title="1">{
                        query["server_id"] = fmt.Sprintf("%d", *opts.ServerID)
                }</span>
                <span class="cov3" title="2">if opts.Status != nil </span><span class="cov3" title="2">{
                        query["status"] = *opts.Status
                }</span>
                <span class="cov3" title="2">if opts.FromDate != nil </span><span class="cov1" title="1">{
                        query["from_date"] = opts.FromDate.Format(time.RFC3339)
                }</span>
                <span class="cov3" title="2">if opts.ToDate != nil </span><span class="cov1" title="1">{
                        query["to_date"] = opts.ToDate.Format(time.RFC3339)
                }</span>
                <span class="cov3" title="2">if opts.ListOptions.Page &gt; 0 </span><span class="cov1" title="1">{
                        query["page"] = fmt.Sprintf("%d", opts.ListOptions.Page)
                }</span>
                <span class="cov3" title="2">if opts.ListOptions.Limit &gt; 0 </span><span class="cov1" title="1">{
                        query["limit"] = fmt.Sprintf("%d", opts.ListOptions.Limit)
                }</span>
                <span class="cov3" title="2">if opts.ListOptions.Sort != "" </span><span class="cov0" title="0">{
                        query["sort"] = opts.ListOptions.Sort
                }</span>
                <span class="cov3" title="2">if opts.ListOptions.Order != "" </span><span class="cov0" title="0">{
                        query["order"] = opts.ListOptions.Order
                }</span>
        }

        <span class="cov6" title="4">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/health/history",
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov4" title="3">if history, ok := resp.Data.(*[]HealthCheckHistory); ok </span><span class="cov4" title="3">{
                return *history, resp.Meta, nil
        }</span>
        <span class="cov0" title="0">return nil, nil, fmt.Errorf("unexpected response type")</span>
}

// HealthStatus represents the basic health status
type HealthStatus struct {
        Status    string      `json:"status"`
        Healthy   bool        `json:"healthy"`
        Version   string      `json:"version"`
        Timestamp *CustomTime `json:"timestamp"`
}

// DetailedHealthStatus represents detailed health information
type DetailedHealthStatus struct {
        Status    string                   `json:"status"`
        Healthy   bool                     `json:"healthy"`
        Version   string                   `json:"version"`
        Timestamp *CustomTime              `json:"timestamp"`
        Uptime    int64                    `json:"uptime"`
        Services  map[string]ServiceHealth `json:"services"`
        Database  *DatabaseHealth          `json:"database"`
        Redis     *RedisHealth             `json:"redis"`
        Metrics   map[string]interface{}   `json:"metrics"`
}

// ServiceHealth represents the health of a service
type ServiceHealth struct {
        Healthy      bool   `json:"healthy"`
        Status       string `json:"status"`
        Message      string `json:"message,omitempty"`
        ResponseTime int    `json:"response_time,omitempty"` // milliseconds
}

// DatabaseHealth represents database health
type DatabaseHealth struct {
        Healthy         bool   `json:"healthy"`
        ConnectionCount int    `json:"connection_count"`
        MaxConnections  int    `json:"max_connections"`
        ResponseTime    int    `json:"response_time"` // milliseconds
        Version         string `json:"version"`
}

// RedisHealth represents Redis health
type RedisHealth struct {
        Healthy          bool   `json:"healthy"`
        Connected        bool   `json:"connected"`
        ResponseTime     int    `json:"response_time"` // milliseconds
        MemoryUsage      int64  `json:"memory_usage"`
        ConnectedClients int    `json:"connected_clients"`
        Version          string `json:"version"`
}

// HealthCheck represents a health check definition
type HealthCheck struct {
        ID                  uint                   `json:"id"`
        ServerID            uint                   `json:"server_id"`
        CheckName           string                 `json:"check_name"`
        CheckType           string                 `json:"check_type"`
        CheckDescription    string                 `json:"check_description,omitempty"`
        IsEnabled           bool                   `json:"is_enabled"`
        CheckInterval       int                    `json:"check_interval_minutes"` // minutes
        CheckTimeout        int                    `json:"check_timeout_seconds"`  // seconds
        MaxRetries          int                    `json:"max_retries"`
        RetryInterval       int                    `json:"retry_interval_seconds"` // seconds
        CheckData           map[string]interface{} `json:"check_data,omitempty"`
        Threshold           map[string]interface{} `json:"threshold,omitempty"`
        LastCheckAt         *CustomTime            `json:"last_check_at,omitempty"`
        NextCheckAt         time.Time              `json:"next_check_at"`
        LastStatus          string                 `json:"last_status,omitempty"`
        LastScore           int                    `json:"last_score,omitempty"`
        ConsecutiveFailures int                    `json:"consecutive_failures"`
        CreatedAt           *CustomTime            `json:"created_at"`
        UpdatedAt           *CustomTime            `json:"updated_at"`

        // Related data
        Server *Server `json:"server,omitempty"`
}

// HealthCheckHistory represents a health check result entry
type HealthCheckHistory struct {
        ID            uint                   `json:"id"`
        HealthCheckID uint                   `json:"health_check_id"`
        ServerID      uint                   `json:"server_id"`
        Status        string                 `json:"status"`           // healthy, warning, critical
        Score         int                    `json:"score"`            // 0-100
        ResponseTime  int64                  `json:"response_time_ms"` // milliseconds
        ErrorMessage  string                 `json:"error_message,omitempty"`
        CheckData     map[string]interface{} `json:"check_data,omitempty"`
        Attempt       int                    `json:"attempt"` // retry attempt number
        CreatedAt     *CustomTime            `json:"created_at"`

        // Related data
        HealthCheck *HealthCheck `json:"health_check,omitempty"`
        Server      *Server      `json:"server,omitempty"`
}

// HealthCheckListOptions represents options for listing health checks
type HealthCheckListOptions struct {
        ServerID    *uint   `json:"server_id,omitempty"`
        CheckType   *string `json:"check_type,omitempty"`
        IsEnabled   *bool   `json:"is_enabled,omitempty"`
        ListOptions ListOptions
}

// HealthCheckHistoryListOptions represents options for listing health check history
type HealthCheckHistoryListOptions struct {
        HealthCheckID *uint      `json:"health_check_id,omitempty"`
        ServerID      *uint      `json:"server_id,omitempty"`
        Status        *string    `json:"status,omitempty"`
        FromDate      *time.Time `json:"from_date,omitempty"`
        ToDate        *time.Time `json:"to_date,omitempty"`
        ListOptions   ListOptions
}

// CreateHealthCheckRequest represents a request to create a health check
type CreateHealthCheckRequest struct {
        ServerID         uint                   `json:"server_id" validate:"required"`
        CheckName        string                 `json:"check_name" validate:"required"`
        CheckType        string                 `json:"check_type" validate:"required"`
        CheckDescription string                 `json:"check_description,omitempty"`
        IsEnabled        bool                   `json:"is_enabled"`
        CheckInterval    int                    `json:"check_interval_minutes" validate:"min=1"`
        CheckTimeout     int                    `json:"check_timeout_seconds" validate:"min=1"`
        MaxRetries       int                    `json:"max_retries" validate:"min=0"`
        RetryInterval    int                    `json:"retry_interval_seconds" validate:"min=1"`
        CheckData        map[string]interface{} `json:"check_data,omitempty"`
        Threshold        map[string]interface{} `json:"threshold,omitempty"`
}

// UpdateHealthCheckRequest represents a request to update a health check
type UpdateHealthCheckRequest struct {
        CheckName        *string                `json:"check_name,omitempty"`
        CheckType        *string                `json:"check_type,omitempty"`
        CheckDescription *string                `json:"check_description,omitempty"`
        IsEnabled        *bool                  `json:"is_enabled,omitempty"`
        CheckInterval    *int                   `json:"check_interval_minutes,omitempty"`
        CheckTimeout     *int                   `json:"check_timeout_seconds,omitempty"`
        MaxRetries       *int                   `json:"max_retries,omitempty"`
        RetryInterval    *int                   `json:"retry_interval_seconds,omitempty"`
        CheckData        map[string]interface{} `json:"check_data,omitempty"`
        Threshold        map[string]interface{} `json:"threshold,omitempty"`
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// IncidentsService is defined in client.go

// CreateIncident creates a new incident
func (s *IncidentsService) CreateIncident(ctx context.Context, req CreateIncidentRequest) (*Incident, error) <span class="cov10" title="4">{
        var result struct {
                Status  string     `json:"status"`
                Message string     `json:"message"`
                Data    *Incident  `json:"data"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/incidents",
                Body:   req,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="3">return result.Data, nil</span>
}

// GetIncident retrieves a specific incident by ID
func (s *IncidentsService) GetIncident(ctx context.Context, id uint) (*Incident, error) <span class="cov5" title="2">{
        var result struct {
                Status  string     `json:"status"`
                Message string     `json:"message"`
                Data    *Incident  `json:"data"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/incidents/%d", id),
                Result: &amp;result,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return result.Data, nil</span>
}

// UpdateIncident updates an existing incident
func (s *IncidentsService) UpdateIncident(ctx context.Context, id uint, req UpdateIncidentRequest) (*Incident, error) <span class="cov8" title="3">{
        var result struct {
                Status  string     `json:"status"`
                Message string     `json:"message"`
                Data    *Incident  `json:"data"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/incidents/%d", id),
                Body:   req,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="3">return result.Data, nil</span>
}

// ListIncidents retrieves a paginated list of incidents
func (s *IncidentsService) ListIncidents(ctx context.Context, opts *IncidentListOptions) (*IncidentListResponse, error) <span class="cov10" title="4">{
        var result struct {
                Status  string                `json:"status"`
                Message string                `json:"message"`
                Data    *IncidentListResponse `json:"data"`
        }

        query := make(map[string]string)
        if opts != nil </span><span class="cov8" title="3">{
                if opts.Status != "" </span><span class="cov8" title="3">{
                        query["status"] = opts.Status
                }</span>
                <span class="cov8" title="3">if opts.Severity != "" </span><span class="cov1" title="1">{
                        query["severity"] = opts.Severity
                }</span>
                <span class="cov8" title="3">if opts.ServerID &gt; 0 </span><span class="cov0" title="0">{
                        query["server_id"] = fmt.Sprintf("%d", opts.ServerID)
                }</span>
                <span class="cov8" title="3">if opts.ProbeID &gt; 0 </span><span class="cov1" title="1">{
                        query["probe_id"] = fmt.Sprintf("%d", opts.ProbeID)
                }</span>
                <span class="cov8" title="3">if opts.Sort != "" </span><span class="cov0" title="0">{
                        query["sort"] = opts.Sort
                }</span>
                
                // Add pagination parameters from ListOptions
                <span class="cov8" title="3">if opts.Page &gt; 0 </span><span class="cov0" title="0">{
                        query["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov8" title="3">if opts.Limit &gt; 0 </span><span class="cov0" title="0">{
                        query["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }

        <span class="cov10" title="4">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/incidents",
                Query:  query,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="3">return result.Data, nil</span>
}

// GetRecentIncidents retrieves recent incidents
func (s *IncidentsService) GetRecentIncidents(ctx context.Context, limit int, severity string) ([]Incident, error) <span class="cov5" title="2">{
        var result struct {
                Status  string `json:"status"`
                Message string `json:"message"`
                Data    struct {
                        Incidents []Incident `json:"incidents"`
                        Total     int64      `json:"total"`
                        Limit     int        `json:"limit"`
                } `json:"data"`
        }

        query := make(map[string]string)
        if limit &gt; 0 </span><span class="cov1" title="1">{
                query["limit"] = fmt.Sprintf("%d", limit)
        }</span>
        <span class="cov5" title="2">if severity != "" </span><span class="cov1" title="1">{
                query["severity"] = severity
        }</span>

        <span class="cov5" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/incidents/recent",
                Query:  query,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return result.Data.Incidents, nil</span>
}

// GetIncidentStats retrieves incident statistics
func (s *IncidentsService) GetIncidentStats(ctx context.Context) (*IncidentStats, error) <span class="cov5" title="2">{
        var result struct {
                Status  string         `json:"status"`
                Message string         `json:"message"`
                Data    *IncidentStats `json:"data"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/incidents/stats",
                Result: &amp;result,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return result.Data, nil</span>
}

// ResolveIncident marks an incident as resolved
func (s *IncidentsService) ResolveIncident(ctx context.Context, id uint) (*Incident, error) <span class="cov1" title="1">{
        status := IncidentStatusResolved
        req := UpdateIncidentRequest{
                Status: status,
        }
        return s.UpdateIncident(ctx, id, req)
}</span>

// AcknowledgeIncident marks an incident as acknowledged
func (s *IncidentsService) AcknowledgeIncident(ctx context.Context, id uint) (*Incident, error) <span class="cov1" title="1">{
        status := IncidentStatusAcknowledged
        req := UpdateIncidentRequest{
                Status: status,
        }
        return s.UpdateIncident(ctx, id, req)
}</span>

// IncidentListResponse represents the response from listing incidents
type IncidentListResponse struct {
        Incidents []Incident `json:"incidents"`
        Total     int64      `json:"total"`
        Page      int        `json:"page"`
        Limit     int        `json:"limit"`
        Pages     int        `json:"pages"`
}

// CreateIncidentFromAlert creates an incident from an alert (for internal use by alerts-controller)
func (s *IncidentsService) CreateIncidentFromAlert(ctx context.Context, organizationID uint, alertID uint, alertName string, severity IncidentSeverity, serverID *uint, description string) (*Incident, error) <span class="cov1" title="1">{
        req := CreateIncidentRequest{
                Title:       fmt.Sprintf("Alert: %s", alertName),
                Description: description,
                Severity:    severity,
                ServerID:    serverID,
                Metadata: map[string]interface{}{
                        "source":    "alert",
                        "alert_id":  alertID,
                },
        }
        
        return s.CreateIncident(ctx, req)
}</span>

// CreateIncidentFromProbe creates an incident from a probe failure (for internal use by monitoring-controller)
func (s *IncidentsService) CreateIncidentFromProbe(ctx context.Context, organizationID uint, probeID uint, probeName string, description string) (*Incident, error) <span class="cov1" title="1">{
        req := CreateIncidentRequest{
                Title:       fmt.Sprintf("Probe Failure: %s", probeName),
                Description: description,
                Severity:    IncidentSeverityCritical, // Probe failures are typically critical
                ProbeID:     &amp;probeID,
                Metadata: map[string]interface{}{
                        "source":   "probe",
                        "probe_id": probeID,
                },
        }
        
        return s.CreateIncident(ctx, req)
}</span>

// ResolveIncidentFromAlert resolves an incident that was created from an alert
func (s *IncidentsService) ResolveIncidentFromAlert(ctx context.Context, alertID uint) error <span class="cov1" title="1">{
        // List incidents related to this alert
        opts := &amp;IncidentListOptions{
                Status: string(IncidentStatusActive),
        }
        
        incidents, err := s.ListIncidents(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Find and resolve incidents created by this alert
        <span class="cov1" title="1">for _, incident := range incidents.Incidents </span><span class="cov0" title="0">{
                if incident.Source == IncidentSourceAlert &amp;&amp; incident.SourceID != nil &amp;&amp; *incident.SourceID == alertID </span><span class="cov0" title="0">{
                        _, err := s.ResolveIncident(ctx, incident.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        
        <span class="cov1" title="1">return nil</span>
}

// ResolveIncidentFromProbe resolves an incident that was created from a probe failure
func (s *IncidentsService) ResolveIncidentFromProbe(ctx context.Context, probeID uint) error <span class="cov1" title="1">{
        // List incidents related to this probe
        opts := &amp;IncidentListOptions{
                Status:  string(IncidentStatusActive),
                ProbeID: probeID,
        }
        
        incidents, err := s.ListIncidents(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        // Resolve all active incidents for this probe
        <span class="cov1" title="1">for _, incident := range incidents.Incidents </span><span class="cov0" title="0">{
                if incident.Source == IncidentSourceProbe &amp;&amp; incident.SourceID != nil &amp;&amp; *incident.SourceID == probeID </span><span class="cov0" title="0">{
                        _, err := s.ResolveIncident(ctx, incident.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        
        <span class="cov1" title="1">return nil</span>
}</pre>
		
		<pre class="file" id="file32" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
        "time"
)

// Submit submits IPMI data for a server
func (s *IPMIService) Submit(ctx context.Context, request *IPMISubmitRequest) (*IPMISubmitResponse, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;IPMISubmitResponse{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v2/ipmi/data",
                Body:   request,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if data, ok := resp.Data.(*IPMISubmitResponse); ok </span><span class="cov1" title="1">{
                return data, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response format")</span>
}

// Get retrieves IPMI data for a server
func (s *IPMIService) Get(ctx context.Context, serverUUID string) (*IPMIData, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;IPMIData{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/ipmi/%s", serverUUID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if data, ok := resp.Data.(*IPMIData); ok </span><span class="cov1" title="1">{
                return data, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetSensorData retrieves IPMI sensor data for a server
func (s *IPMIService) GetSensorData(ctx context.Context, serverUUID string) ([]*IPMISensor, error) <span class="cov1" title="1">{
        var resp StandardResponse
        var sensors []*IPMISensor
        resp.Data = &amp;sensors

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/ipmi/%s/sensors", serverUUID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return sensors, nil</span>
}

// ExecuteCommand executes an IPMI command on a server
func (s *IPMIService) ExecuteCommand(ctx context.Context, serverUUID string, command string, args []string) (*IPMICommandResult, error) <span class="cov10" title="3">{
        var resp StandardResponse
        resp.Data = &amp;IPMICommandResult{}

        body := map[string]interface{}{
                "command": command,
                "args":    args,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/ipmi/%s/execute", serverUUID),
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov10" title="3">if result, ok := resp.Data.(*IPMICommandResult); ok </span><span class="cov10" title="3">{
                return result, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetIPMI retrieves IPMI data for a server within a time range
func (s *IPMIService) GetIPMI(ctx context.Context, serverUUID string, timeRange *TimeRange) (*IPMIInfo, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;IPMIInfo{}

        query := make(map[string]string)
        if timeRange != nil </span><span class="cov0" title="0">{
                query["start"] = timeRange.Start
                query["end"] = timeRange.End
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v2/ipmi/%s", serverUUID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if data, ok := resp.Data.(*IPMIInfo); ok </span><span class="cov1" title="1">{
                return data, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetLatestIPMI retrieves the latest IPMI data for a server
func (s *IPMIService) GetLatestIPMI(ctx context.Context, serverUUID string) (*IPMIInfo, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;IPMIInfo{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v2/ipmi/%s/latest", serverUUID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if data, ok := resp.Data.(*IPMIInfo); ok </span><span class="cov1" title="1">{
                return data, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ListIPMIHistory retrieves IPMI history for a server
func (s *IPMIService) ListIPMIHistory(ctx context.Context, serverUUID string, opts *IPMIListOptions) ([]*IPMIRecord, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp PaginatedResponse
        var records []*IPMIRecord
        resp.Data = &amp;records

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v2/ipmi/%s/history", serverUUID),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov0" title="0">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return records, resp.Meta, nil</span>
}

// IPMISubmitRequest represents a request to submit IPMI data
type IPMISubmitRequest struct {
        ServerUUID  string       `json:"server_uuid"`
        CollectedAt time.Time    `json:"collected_at"`
        IPMI        IPMIInfo     `json:"ipmi"`
        IPMIData    *IPMIData    `json:"ipmi_data,omitempty"`
        Sensors     []IPMISensor `json:"sensors,omitempty"`
        Events      []IPMIEvent  `json:"events,omitempty"`
}

// IPMISubmitResponse represents the response from submitting IPMI data
type IPMISubmitResponse struct {
        ServerUUID       string    `json:"server_uuid"`
        Timestamp        time.Time `json:"timestamp"`
        DataSaved        bool      `json:"data_saved"`
        SensorCount      int       `json:"sensor_count"`
        EventCount       int       `json:"event_count"`
        CollectionMethod string    `json:"collection_method,omitempty"`
        IPMIVersion      string    `json:"ipmi_version,omitempty"`
}

// IPMIData represents IPMI data for a server
type IPMIData struct {
        BMCInfo       *BMCInfo               `json:"bmc_info,omitempty"`
        ChassisStatus *ChassisStatus         `json:"chassis_status,omitempty"`
        PowerStatus   *PowerStatus           `json:"power_status,omitempty"`
        SystemHealth  string                 `json:"system_health"`
        FanStatus     []FanStatus            `json:"fan_status,omitempty"`
        Temperatures  []TemperatureSensor    `json:"temperatures,omitempty"`
        PowerSupplies []PowerSupplyStatus    `json:"power_supplies,omitempty"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`
}

// BMCInfo represents BMC (Baseboard Management Controller) information
type BMCInfo struct {
        Version          string `json:"version,omitempty"`
        Manufacturer     string `json:"manufacturer,omitempty"`
        Firmware         string `json:"firmware,omitempty"`
        IPAddress        string `json:"ip_address,omitempty"`
        MACAddress       string `json:"mac_address,omitempty"`
        DeviceID         string `json:"device_id,omitempty"`
        FirmwareRevision string `json:"firmware_revision,omitempty"`
        ManufacturerName string `json:"manufacturer_name,omitempty"`
        ProductName      string `json:"product_name,omitempty"`
}

// ChassisStatus represents chassis status
type ChassisStatus struct {
        PowerState        string `json:"power_state"`
        ChassisIntrusion  bool   `json:"chassis_intrusion"`
        FrontPanelLockout bool   `json:"front_panel_lockout"`
        DriveFault        bool   `json:"drive_fault"`
        CoolingFault      bool   `json:"cooling_fault"`
}

// PowerStatus represents power status
type PowerStatus struct {
        PowerOn          bool    `json:"power_on"`
        PowerConsumption float64 `json:"power_consumption"` // Watts
        PowerCapacity    float64 `json:"power_capacity"`    // Watts
}

// FanStatus represents fan status
type FanStatus struct {
        Name    string  `json:"name"`
        RPM     int     `json:"rpm"`
        Status  string  `json:"status"`
        Percent float64 `json:"percent"`
}

// TemperatureSensor represents a temperature sensor
type TemperatureSensor struct {
        Name      string  `json:"name"`
        Reading   float64 `json:"reading"` // Celsius
        Status    string  `json:"status"`
        Threshold float64 `json:"threshold"` // Celsius
        Critical  float64 `json:"critical"`  // Celsius
}

// PowerSupplyStatus represents power supply status
type PowerSupplyStatus struct {
        Name        string  `json:"name"`
        Status      string  `json:"status"`
        Present     bool    `json:"present"`
        PowerOutput float64 `json:"power_output"` // Watts
        Voltage     float64 `json:"voltage"`      // Volts
        Current     float64 `json:"current"`      // Amps
}

// IPMISensor represents an IPMI sensor
type IPMISensor struct {
        ID          string  `json:"id"`
        Name        string  `json:"name"`
        Type        string  `json:"type"`
        Reading     float64 `json:"reading"`
        Unit        string  `json:"unit"`
        Status      string  `json:"status"`
        LowerBound  float64 `json:"lower_bound,omitempty"`
        UpperBound  float64 `json:"upper_bound,omitempty"`
        Description string  `json:"description,omitempty"`
}

// IPMIEvent represents an IPMI event
type IPMIEvent struct {
        ID          string    `json:"id"`
        Timestamp   time.Time `json:"timestamp"`
        SensorName  string    `json:"sensor_name"`
        SensorType  string    `json:"sensor_type"`
        EventType   string    `json:"event_type"`
        Severity    string    `json:"severity"`
        Description string    `json:"description"`
        RawData     string    `json:"raw_data,omitempty"`
}

// IPMICommandResult represents the result of an IPMI command
type IPMICommandResult struct {
        Command    string    `json:"command"`
        Output     string    `json:"output"`
        Error      string    `json:"error,omitempty"`
        ExitCode   int       `json:"exit_code"`
        ExecutedAt time.Time `json:"executed_at"`
}

// IPMIInfo represents IPMI information
type IPMIInfo struct {
        CollectionMethod string                `json:"collection_method"`
        IPMIVersion      string                `json:"ipmi_version"`
        BMC              *BMCInfo              `json:"bmc,omitempty"`
        Sensors          []IPMISensorInfo      `json:"sensors,omitempty"`
        PowerInfo        *IPMIPowerInfo        `json:"power_info,omitempty"`
        Fans             []IPMIFanInfo         `json:"fans,omitempty"`
        Temperatures     []IPMITemperatureInfo `json:"temperatures,omitempty"`
        SystemHealth     *IPMISystemHealth     `json:"system_health,omitempty"`
}

// IPMISensorInfo represents IPMI sensor information
type IPMISensorInfo struct {
        SensorID   string  `json:"sensor_id"`
        SensorName string  `json:"sensor_name"`
        SensorType string  `json:"sensor_type"`
        Value      float64 `json:"value"`
        Unit       string  `json:"unit"`
        Status     string  `json:"status"`
}

// IPMIPowerInfo represents IPMI power information
type IPMIPowerInfo struct {
        PowerConsumption float64 `json:"power_consumption"`
        PowerCapacity    float64 `json:"power_capacity"`
        PowerState       string  `json:"power_state"`
}

// IPMIFanInfo represents IPMI fan information
type IPMIFanInfo struct {
        FanID        string  `json:"fan_id"`
        FanName      string  `json:"fan_name"`
        Speed        int     `json:"speed"`
        SpeedPercent float64 `json:"speed_percent"`
        Status       string  `json:"status"`
}

// IPMITemperatureInfo represents IPMI temperature information
type IPMITemperatureInfo struct {
        SensorID     string   `json:"sensor_id"`
        SensorName   string   `json:"sensor_name"`
        Temperature  float64  `json:"temperature"`
        Status       string   `json:"status"`
        UpperWarning *float64 `json:"upper_warning,omitempty"`
}

// IPMISystemHealth represents IPMI system health
type IPMISystemHealth struct {
        OverallStatus  string `json:"overall_status"`
        PowerStatus    string `json:"power_status"`
        ThermalStatus  string `json:"thermal_status"`
        FanStatus      string `json:"fan_status"`
        VoltageStatus  string `json:"voltage_status"`
        CriticalEvents int    `json:"critical_events"`
        WarningEvents  int    `json:"warning_events"`
        HealthScore    int    `json:"health_score"`
}

// IPMIRecord represents an IPMI record with metadata
type IPMIRecord struct {
        ID               uint      `json:"id"`
        ServerUUID       string    `json:"server_uuid"`
        OrganizationID   uint      `json:"organization_id"`
        CollectedAt      time.Time `json:"collected_at"`
        CollectionMethod string    `json:"collection_method,omitempty"`
        CreatedAt        time.Time `json:"created_at"`
        UpdatedAt        time.Time `json:"updated_at"`
        IPMI             IPMIInfo  `json:"ipmi"`
}

// IPMIListOptions represents options for listing IPMI data
type IPMIListOptions struct {
        ListOptions
        StartTime *time.Time `url:"start_time,omitempty"`
        EndTime   *time.Time `url:"end_time,omitempty"`
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package nexmonyx

import (
        "context"
        "encoding/json"
        "fmt"
        "time"
)

// SubmitMetrics submits metrics for a server
func (s *MetricsService) Submit(ctx context.Context, serverUUID string, metrics []*Metric) error <span class="cov10" title="11">{
        var resp StandardResponse

        body := map[string]interface{}{
                "server_uuid": serverUUID,
                "metrics":     metrics,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/metrics",
                Body:   body,
                Result: &amp;resp,
        })
        return err
}</span>

// SubmitComprehensiveMetrics submits comprehensive metrics for a server
func (s *MetricsService) SubmitComprehensive(ctx context.Context, metrics *ComprehensiveMetricsRequest) error <span class="cov6" title="4">{
        // If using server authentication and ServerUUID is not set in the request,
        // automatically populate it from the client configuration
        if s.client.config.Auth.ServerUUID != "" &amp;&amp; metrics.ServerUUID == "" </span><span class="cov3" title="2">{
                metrics.ServerUUID = s.client.config.Auth.ServerUUID
        }</span>

        <span class="cov6" title="4">var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v2/metrics/comprehensive",
                Body:   metrics,
                Result: &amp;resp,
        })
        return err</span>
}

// SubmitAggregatedMetrics submits aggregated metrics for a server
func (s *MetricsService) SubmitAggregatedMetrics(ctx context.Context, metrics *AggregatedMetricsRequest) error <span class="cov3" title="2">{
        // If using server authentication and ServerUUID is not set in the request,
        // automatically populate it from the client configuration
        if s.client.config.Auth.ServerUUID != "" &amp;&amp; metrics.ServerUUID == "" </span><span class="cov1" title="1">{
                metrics.ServerUUID = s.client.config.Auth.ServerUUID
        }</span>

        <span class="cov3" title="2">var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/metrics/aggregated",
                Body:   metrics,
                Result: &amp;resp,
        })
        return err</span>
}

// QueryMetrics queries metrics with filters
func (s *MetricsService) Query(ctx context.Context, query *MetricsQuery) ([]*Metric, error) <span class="cov6" title="4">{
        var resp StandardResponse
        var metrics []*Metric
        resp.Data = &amp;metrics

        req := &amp;Request{
                Method: "POST",
                Path:   "/v1/metrics/query",
                Body:   query,
                Result: &amp;resp,
        }

        _, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="3">return metrics, nil</span>
}

// GetMetrics retrieves metrics for a server
func (s *MetricsService) Get(ctx context.Context, serverUUID string, opts *ListOptions) ([]*Metric, *PaginationMeta, error) <span class="cov6" title="4">{
        var resp PaginatedResponse
        var metrics []*Metric
        resp.Data = &amp;metrics

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/metrics/server/%s", serverUUID),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov3" title="2">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov6" title="4">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov5" title="3">return metrics, resp.Meta, nil</span>
}

// GetMetricsSummary retrieves a summary of metrics for a server
func (s *MetricsService) GetSummary(ctx context.Context, serverUUID string, timeRange *QueryTimeRange) (map[string]interface{}, error) <span class="cov5" title="3">{
        var resp StandardResponse
        var summary map[string]interface{}
        resp.Data = &amp;summary

        query := make(map[string]string)
        if timeRange != nil </span><span class="cov1" title="1">{
                start, end := timeRange.ToStrings()
                query["start"] = start
                query["end"] = end
        }</span>

        <span class="cov5" title="3">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/metrics/server/%s/summary", serverUUID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">return summary, nil</span>
}

// GetAggregatedMetrics retrieves aggregated metrics
func (s *MetricsService) GetAggregated(ctx context.Context, aggregation *MetricsAggregation) (map[string]interface{}, error) <span class="cov5" title="3">{
        var resp StandardResponse
        var result map[string]interface{}
        resp.Data = &amp;result

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/metrics/aggregate",
                Body:   aggregation,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">return result, nil</span>
}

// ExportMetrics exports metrics in various formats
func (s *MetricsService) Export(ctx context.Context, export *MetricsExport) ([]byte, error) <span class="cov6" title="4">{
        resp, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/metrics/export",
                Body:   export,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="3">return resp.Body, nil</span>
}

// MetricsQuery represents a metrics query
type MetricsQuery struct {
        ServerUUIDs []string               `json:"server_uuids,omitempty"`
        MetricNames []string               `json:"metric_names,omitempty"`
        StartTime   string                 `json:"start_time"`
        EndTime     string                 `json:"end_time"`
        GroupBy     string                 `json:"group_by,omitempty"`
        Aggregation string                 `json:"aggregation,omitempty"`
        Filters     map[string]interface{} `json:"filters,omitempty"`
        Limit       int                    `json:"limit,omitempty"`
}

// MetricsAggregation represents metrics aggregation parameters
type MetricsAggregation struct {
        ServerUUIDs []string `json:"server_uuids,omitempty"`
        MetricNames []string `json:"metric_names"`
        StartTime   string   `json:"start_time"`
        EndTime     string   `json:"end_time"`
        GroupBy     []string `json:"group_by"`
        Function    string   `json:"function"`           // avg, sum, min, max, count
        Interval    string   `json:"interval,omitempty"` // 1m, 5m, 1h, 1d
}

// MetricsExport represents metrics export parameters
type MetricsExport struct {
        ServerUUIDs []string `json:"server_uuids,omitempty"`
        MetricNames []string `json:"metric_names,omitempty"`
        StartTime   string   `json:"start_time"`
        EndTime     string   `json:"end_time"`
        Format      string   `json:"format"` // csv, json, prometheus
}

// GetStatus retrieves metrics status for a server
func (s *MetricsService) GetStatus(ctx context.Context, serverUUID string) (*MetricsStatus, error) <span class="cov5" title="3">{
        var resp StandardResponse
        resp.Data = &amp;MetricsStatus{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/metrics/%s/status", serverUUID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">if status, ok := resp.Data.(*MetricsStatus); ok </span><span class="cov3" title="2">{
                return status, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// MetricsStatus represents the status of metrics collection
type MetricsStatus struct {
        ServerUUID         string      `json:"server_uuid"`
        CollectionEnabled  bool        `json:"collection_enabled"`
        LastCollection     *CustomTime `json:"last_collection,omitempty"`
        NextCollection     *CustomTime `json:"next_collection,omitempty"`
        CollectionInterval int         `json:"collection_interval"`
        ErrorCount         int         `json:"error_count"`
        LastError          string      `json:"last_error,omitempty"`
}

// MetricsBuilder provides a fluent interface for building metrics
type MetricsBuilder struct {
        metrics *TimescaleMetrics
}

// NewMetricsBuilder creates a new metrics builder
func NewMetricsBuilder(hostname string) *MetricsBuilder <span class="cov1" title="1">{
        return &amp;MetricsBuilder{
                metrics: &amp;TimescaleMetrics{
                        Hostname:    hostname,
                        CollectedAt: time.Now(),
                        Metrics:     &amp;MetricsData{},
                },
        }
}</span>

// WithAgentVersion sets the agent version
func (b *MetricsBuilder) WithAgentVersion(version string) *MetricsBuilder <span class="cov1" title="1">{
        b.metrics.AgentVersion = version
        return b
}</span>

// WithCollectionDuration sets the collection duration
func (b *MetricsBuilder) WithCollectionDuration(duration float64) *MetricsBuilder <span class="cov1" title="1">{
        b.metrics.CollectionDuration = duration
        return b
}</span>

// WithErrorCount sets the error count
func (b *MetricsBuilder) WithErrorCount(count int) *MetricsBuilder <span class="cov1" title="1">{
        b.metrics.ErrorCount = count
        return b
}</span>

// WithCPUMetrics sets the CPU metrics
func (b *MetricsBuilder) WithCPUMetrics(cpu *TimescaleCPUMetrics) *MetricsBuilder <span class="cov1" title="1">{
        b.metrics.Metrics.CPU = cpu
        return b
}</span>

// WithMemoryMetrics sets the memory metrics
func (b *MetricsBuilder) WithMemoryMetrics(memory *TimescaleMemoryMetrics) *MetricsBuilder <span class="cov1" title="1">{
        b.metrics.Metrics.Memory = memory
        return b
}</span>

// Build returns the constructed metrics
func (b *MetricsBuilder) Build() *TimescaleMetrics <span class="cov1" title="1">{
        return b.metrics
}</span>

// TimescaleMetrics represents metrics in TimescaleDB format
type TimescaleMetrics struct {
        Hostname           string       `json:"hostname"`
        CollectedAt        time.Time    `json:"collected_at"`
        AgentVersion       string       `json:"agent_version"`
        CollectionDuration float64      `json:"collection_duration"`
        ErrorCount         int          `json:"error_count"`
        Metrics            *MetricsData `json:"metrics"`
}

// MetricsData contains the actual metrics
type MetricsData struct {
        CPU    *TimescaleCPUMetrics    `json:"cpu,omitempty"`
        Memory *TimescaleMemoryMetrics `json:"memory,omitempty"`
        System *TimescaleSystemMetrics `json:"system,omitempty"`
}

// TimescaleSystemMetrics represents system metrics in TimescaleDB format
type TimescaleSystemMetrics struct {
        Host *HostInfo `json:"host,omitempty"`
}

// HostInfo represents host information
type HostInfo struct {
        Hostname       string `json:"hostname"`
        OS             string `json:"os"`
        Uptime         int64  `json:"uptime"`
        BootTime       int64  `json:"boot_time"`
        Procs          int    `json:"procs"`
        Platform       string `json:"platform"`
        PlatformFamily string `json:"platform_family"`
}

// TimescaleCPUMetrics represents CPU metrics in TimescaleDB format
type TimescaleCPUMetrics struct {
        UsagePercent   float64            `json:"usage_percent"`
        UserPercent    float64            `json:"user_percent"`
        SystemPercent  float64            `json:"system_percent"`
        IdlePercent    float64            `json:"idle_percent"`
        IowaitPercent  float64            `json:"iowait_percent"`
        IRQPercent     float64            `json:"irq_percent"`
        SoftIRQPercent float64            `json:"soft_irq_percent"`
        StealPercent   float64            `json:"steal_percent"`
        LoadAverage    *LoadAverage       `json:"load_average,omitempty"`
        PerCPU         []TimescaleCPUCore `json:"per_cpu,omitempty"`
}

// TimescaleCPUCore represents per-CPU metrics
type TimescaleCPUCore struct {
        Core         string  `json:"core"`
        UsagePercent float64 `json:"usage_percent"`
}

// LoadAverage represents system load averages
type LoadAverage struct {
        Load1  float64 `json:"load_1"`
        Load5  float64 `json:"load_5"`
        Load15 float64 `json:"load_15"`
}

// TimescaleMemoryMetrics represents memory metrics in TimescaleDB format
type TimescaleMemoryMetrics struct {
        Total           uint64  `json:"total"`
        Available       uint64  `json:"available"`
        Used            uint64  `json:"used"`
        UsedPercent     float64 `json:"used_percent"`
        Free            uint64  `json:"free"`
        Active          uint64  `json:"active"`
        Inactive        uint64  `json:"inactive"`
        Buffers         uint64  `json:"buffers"`
        Cached          uint64  `json:"cached"`
        SwapTotal       uint64  `json:"swap_total"`
        SwapUsed        uint64  `json:"swap_used"`
        SwapFree        uint64  `json:"swap_free"`
        SwapUsedPercent float64 `json:"swap_used_percent"`
        Slab            uint64  `json:"slab"`
        SReclaimable    uint64  `json:"s_reclaimable"`
        SUnreclaim      uint64  `json:"s_unreclaim"`
        PageTables      uint64  `json:"page_tables"`
        SwapCached      uint64  `json:"swap_cached"`
}

// ConvertLegacyToTimescaleMetrics converts legacy metrics format to TimescaleDB format
func ConvertLegacyToTimescaleMetrics(legacy *ComprehensiveMetricsRequest) *TimescaleMetrics <span class="cov1" title="1">{
        metrics := &amp;TimescaleMetrics{
                Hostname:    legacy.SystemInfo.Hostname,
                CollectedAt: time.Now(),
                Metrics:     &amp;MetricsData{},
        }

        // Parse collected at time
        if t, err := time.Parse(time.RFC3339, legacy.CollectedAt); err == nil </span><span class="cov1" title="1">{
                metrics.CollectedAt = t
        }</span>

        // Convert CPU metrics
        <span class="cov1" title="1">if legacy.CPU != nil </span><span class="cov1" title="1">{
                cpu := &amp;TimescaleCPUMetrics{
                        UsagePercent: legacy.CPU.UsagePercent,
                        LoadAverage: &amp;LoadAverage{
                                Load1:  legacy.CPU.LoadAverage1,
                                Load5:  legacy.CPU.LoadAverage5,
                                Load15: legacy.CPU.LoadAverage15,
                        },
                }

                // Convert per-core usage
                if legacy.CPU.PerCoreUsage != nil </span><span class="cov1" title="1">{
                        cpu.PerCPU = make([]TimescaleCPUCore, len(legacy.CPU.PerCoreUsage))
                        for i, usage := range legacy.CPU.PerCoreUsage </span><span class="cov6" title="4">{
                                cpu.PerCPU[i] = TimescaleCPUCore{
                                        Core:         fmt.Sprintf("%d", i),
                                        UsagePercent: usage,
                                }
                        }</span>
                }

                <span class="cov1" title="1">metrics.Metrics.CPU = cpu</span>
        }

        // Convert memory metrics
        <span class="cov1" title="1">if legacy.Memory != nil </span><span class="cov1" title="1">{
                // Safely convert int64 to uint64 for memory metrics
                // Negative values are treated as zero (invalid data)
                metrics.Metrics.Memory = &amp;TimescaleMemoryMetrics{
                        Total:       SafeInt64ToUint64OrZero(legacy.Memory.TotalBytes),
                        Used:        SafeInt64ToUint64OrZero(legacy.Memory.UsedBytes),
                        UsedPercent: legacy.Memory.UsagePercent,
                }
        }</span>

        // Convert system info
        <span class="cov1" title="1">if legacy.SystemInfo != nil </span><span class="cov1" title="1">{
                metrics.Metrics.System = &amp;TimescaleSystemMetrics{
                        Host: &amp;HostInfo{
                                Hostname:       legacy.SystemInfo.Hostname,
                                OS:             legacy.SystemInfo.OS,
                                Uptime:         legacy.SystemInfo.Uptime,
                                BootTime:       legacy.SystemInfo.BootTime,
                                Procs:          legacy.SystemInfo.Processes,
                                Platform:       legacy.SystemInfo.Platform,
                                PlatformFamily: legacy.SystemInfo.PlatformFamily,
                        },
                }
        }</span>

        <span class="cov1" title="1">return metrics</span>
}

// ComprehensiveMetricsSubmission represents a comprehensive metrics submission
type ComprehensiveMetricsSubmission struct {
        Timestamp int64                        `json:"timestamp"`
        Hostname  string                       `json:"hostname"`
        Metrics   *ComprehensiveMetricsPayload `json:"metrics"`
}

// ComprehensiveMetricsPayload represents the payload for comprehensive metrics
type ComprehensiveMetricsPayload struct {
        ServerUUID    string                      `json:"server_uuid"`
        CollectedAt   string                      `json:"collected_at"`
        SystemInfo    *SystemInfo                 `json:"system_info,omitempty"`
        CPU           *TimescaleCPUMetrics        `json:"cpu,omitempty"`
        Memory        *TimescaleMemoryMetrics     `json:"memory,omitempty"`
        Disk          *TimescaleDiskMetrics       `json:"disk,omitempty"`
        Network       *TimescaleNetworkMetrics    `json:"network,omitempty"`
        Filesystem    *TimescaleFilesystemMetrics `json:"filesystem,omitempty"`
        Processes     []ProcessMetrics            `json:"processes,omitempty"`
        ZFS           json.RawMessage             `json:"zfs,omitempty"`
        RAID          json.RawMessage             `json:"raid,omitempty"`
        System        *TimescaleSystemMetrics     `json:"system,omitempty"`
        CustomMetrics map[string]interface{}      `json:"custom_metrics,omitempty"`
}

// SubmitComprehensiveToTimescale submits comprehensive metrics to TimescaleDB
func (s *MetricsService) SubmitComprehensiveToTimescale(ctx context.Context, metrics *ComprehensiveMetricsSubmission) error <span class="cov7" title="5">{
        // If using server authentication and ServerUUID is not set in the payload,
        // automatically populate it from the client configuration
        if s.client.config.Auth.ServerUUID != "" &amp;&amp; metrics.Metrics != nil &amp;&amp; metrics.Metrics.ServerUUID == "" </span><span class="cov3" title="2">{
                metrics.Metrics.ServerUUID = s.client.config.Auth.ServerUUID
        }</span>

        <span class="cov7" title="5">var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v2/metrics/comprehensive",
                Body:   metrics,
                Result: &amp;resp,
        })
        return err</span>
}

// GetLatestMetrics retrieves the latest metrics for a server
func (s *MetricsService) GetLatestMetrics(ctx context.Context, serverUUID string) (*TimescaleMetricsResponse, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;TimescaleMetricsResponse{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v2/servers/%s/metrics/latest", serverUUID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if data, ok := resp.Data.(*TimescaleMetricsResponse); ok </span><span class="cov1" title="1">{
                return data, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// TimescaleMetricsResponse represents a response containing TimescaleDB metrics
type TimescaleMetricsResponse struct {
        ServerUUID string                         `json:"server_uuid"`
        Timestamp  string                         `json:"timestamp"`
        Metrics    *ComprehensiveMetricsTimescale `json:"metrics"`
        Source     string                         `json:"source,omitempty"`
}

// ComprehensiveMetricsTimescale represents comprehensive metrics in TimescaleDB format
type ComprehensiveMetricsTimescale struct {
        ServerUUID         string                  `json:"server_uuid"`
        CollectedAt        time.Time               `json:"collected_at"`
        Timestamp          time.Time               `json:"timestamp,omitempty"`
        AgentVersion       string                  `json:"agent_version"`
        CollectionDuration float64                 `json:"collection_duration"`
        CPUUsagePercent    *float64                `json:"cpu_usage_percent,omitempty"`
        MemoryUsagePercent *float64                `json:"memory_usage_percent,omitempty"`
        CPU                *TimescaleCPUMetrics    `json:"cpu,omitempty"`
        Memory             *TimescaleMemoryMetrics `json:"memory,omitempty"`
        System             *TimescaleSystemMetrics `json:"system,omitempty"`
}

// TimescaleMetricsRangeResponse represents a response containing multiple TimescaleDB metrics
type TimescaleMetricsRangeResponse struct {
        ServerUUID string                           `json:"server_uuid"`
        StartTime  string                           `json:"start_time,omitempty"`
        EndTime    string                           `json:"end_time,omitempty"`
        Metrics    []*ComprehensiveMetricsTimescale `json:"metrics"`
        Count      int                              `json:"count"`
        Source     string                           `json:"source,omitempty"`
}

// GetMetricsRange retrieves metrics for a server within a time range
func (s *MetricsService) GetMetricsRange(ctx context.Context, serverUUID string, startTime, endTime string, limit int) (*TimescaleMetricsRangeResponse, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;TimescaleMetricsRangeResponse{}

        query := map[string]string{
                "start_time": startTime,
                "end_time":   endTime,
        }

        if limit &gt; 0 </span><span class="cov1" title="1">{
                query["limit"] = fmt.Sprintf("%d", limit)
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v2/servers/%s/metrics/range", serverUUID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if data, ok := resp.Data.(*TimescaleMetricsRangeResponse); ok </span><span class="cov1" title="1">{
                return data, nil
        }</span>

        // If type assertion failed, try to handle map[string]interface{} case
        <span class="cov0" title="0">if dataMap, ok := resp.Data.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                // Convert map to JSON and unmarshal into our type
                jsonBytes, err := json.Marshal(dataMap)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to marshal data map: %w", err)
                }</span>

                <span class="cov0" title="0">var result TimescaleMetricsRangeResponse
                if err := json.Unmarshal(jsonBytes, &amp;result); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal into TimescaleMetricsRangeResponse: %w", err)
                }</span>

                <span class="cov0" title="0">return &amp;result, nil</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// MetricsAggregator handles aggregation of metrics data
type MetricsAggregator struct {
        metrics  []*ComprehensiveMetricsTimescale
        groupBy  string
        function string
}

// NewMetricsAggregator creates a new metrics aggregator
func NewMetricsAggregator(initialMetrics ...interface{}) *MetricsAggregator <span class="cov8" title="8">{
        aggregator := &amp;MetricsAggregator{
                metrics: make([]*ComprehensiveMetricsTimescale, 0),
        }

        // Handle different input types
        for _, m := range initialMetrics </span><span class="cov7" title="6">{
                switch v := m.(type) </span>{
                case []*ComprehensiveMetricsTimescale:<span class="cov1" title="1">
                        aggregator.metrics = append(aggregator.metrics, v...)</span>
                case []ComprehensiveMetricsTimescale:<span class="cov3" title="2">
                        for i := range v </span><span class="cov6" title="4">{
                                aggregator.metrics = append(aggregator.metrics, &amp;v[i])
                        }</span>
                case *ComprehensiveMetricsTimescale:<span class="cov3" title="2">
                        aggregator.metrics = append(aggregator.metrics, v)</span>
                case ComprehensiveMetricsTimescale:<span class="cov1" title="1">
                        aggregator.metrics = append(aggregator.metrics, &amp;v)</span>
                }
        }

        <span class="cov8" title="8">return aggregator</span>
}

// AddMetrics adds metrics to the aggregator
func (a *MetricsAggregator) AddMetrics(metrics ...*ComprehensiveMetricsTimescale) <span class="cov1" title="1">{
        a.metrics = append(a.metrics, metrics...)
}</span>

// WithGroupBy sets the grouping field
func (a *MetricsAggregator) WithGroupBy(field string) *MetricsAggregator <span class="cov1" title="1">{
        a.groupBy = field
        return a
}</span>

// WithFunction sets the aggregation function
func (a *MetricsAggregator) WithFunction(fn string) *MetricsAggregator <span class="cov1" title="1">{
        a.function = fn
        return a
}</span>

// Aggregate performs the aggregation
func (a *MetricsAggregator) Aggregate() map[string]interface{} <span class="cov1" title="1">{
        // Simple implementation for tests
        return map[string]interface{}{
                "count":    len(a.metrics),
                "groupBy":  a.groupBy,
                "function": a.function,
        }
}</span>

// AverageCPUUsage calculates the average CPU usage
func (a *MetricsAggregator) AverageCPUUsage() float64 <span class="cov1" title="1">{
        if len(a.metrics) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov1" title="1">var total float64
        var count int
        for _, m := range a.metrics </span><span class="cov5" title="3">{
                if m.CPUUsagePercent != nil </span><span class="cov5" title="3">{
                        total += *m.CPUUsagePercent
                        count++
                }</span>
        }

        <span class="cov1" title="1">if count == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov1" title="1">return total / float64(count)</span>
}

// AverageMemoryUsage calculates the average memory usage
func (a *MetricsAggregator) AverageMemoryUsage() float64 <span class="cov1" title="1">{
        if len(a.metrics) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov1" title="1">var total float64
        var count int
        for _, m := range a.metrics </span><span class="cov5" title="3">{
                if m.MemoryUsagePercent != nil </span><span class="cov5" title="3">{
                        total += *m.MemoryUsagePercent
                        count++
                }</span>
        }

        <span class="cov1" title="1">if count == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov1" title="1">return total / float64(count)</span>
}

// MaxCPUUsage returns the maximum CPU usage
func (a *MetricsAggregator) MaxCPUUsage() float64 <span class="cov1" title="1">{
        var max float64
        for _, m := range a.metrics </span><span class="cov5" title="3">{
                if m.CPUUsagePercent != nil &amp;&amp; *m.CPUUsagePercent &gt; max </span><span class="cov5" title="3">{
                        max = *m.CPUUsagePercent
                }</span>
        }
        <span class="cov1" title="1">return max</span>
}

// MaxMemoryUsage returns the maximum memory usage
func (a *MetricsAggregator) MaxMemoryUsage() float64 <span class="cov1" title="1">{
        var max float64
        for _, m := range a.metrics </span><span class="cov5" title="3">{
                if m.MemoryUsagePercent != nil &amp;&amp; *m.MemoryUsagePercent &gt; max </span><span class="cov5" title="3">{
                        max = *m.MemoryUsagePercent
                }</span>
        }
        <span class="cov1" title="1">return max</span>
}

// TimeRange returns the time range of the metrics
func (a *MetricsAggregator) TimeRange() (start, end time.Time) <span class="cov1" title="1">{
        if len(a.metrics) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov1" title="1">start = a.metrics[0].Timestamp
        end = a.metrics[0].Timestamp

        for _, m := range a.metrics </span><span class="cov5" title="3">{
                if m.Timestamp.Before(start) </span><span class="cov0" title="0">{
                        start = m.Timestamp
                }</span>
                <span class="cov5" title="3">if m.Timestamp.After(end) </span><span class="cov3" title="2">{
                        end = m.Timestamp
                }</span>
        }

        <span class="cov1" title="1">return start, end</span>
}

// GetServerMetrics retrieves specific metrics for a server within a time range
func (s *MetricsService) GetServerMetrics(ctx context.Context, serverUUID string, metricName string, timeRange *TimeRange) ([]interface{}, error) <span class="cov5" title="3">{
        var resp StandardResponse
        var metrics []interface{}
        resp.Data = &amp;metrics

        query := map[string]string{
                "metric": metricName,
        }

        if timeRange != nil </span><span class="cov1" title="1">{
                query["start"] = timeRange.Start
                query["end"] = timeRange.End
        }</span>

        <span class="cov5" title="3">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/metrics/server/%s", serverUUID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov3" title="2">return metrics, nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// MLService handles machine learning operations
// Provides tag suggestions, group suggestions, model management, and training jobs
type MLService struct {
        client *Client
}

// Tag Suggestion Methods

// GetTagSuggestions retrieves ML-generated tag suggestions for a server
// Authentication: JWT Token required
// Endpoint: GET /v1/servers/{serverID}/tag-suggestions
// Parameters:
//   - serverID: Server ID or UUID
// Returns: Array of tag predictions with confidence scores
func (s *MLService) GetTagSuggestions(ctx context.Context, serverID string) ([]TagSuggestion, error) <span class="cov10" title="5">{
        var resp struct {
                Data    []TagSuggestion `json:"data"`
                Status  string          `json:"status"`
                Message string          `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/servers/%s/tag-suggestions", serverID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov8" title="4">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// ApplyTagSuggestion applies ML-suggested tags to a server
// Authentication: JWT Token required
// Endpoint: POST /v1/servers/{serverID}/tag-suggestions/apply
// Parameters:
//   - serverID: Server ID or UUID
//   - predictionID: Prediction ID to apply (optional, applies all if empty)
// Returns: Number of tags applied
func (s *MLService) ApplyTagSuggestion(ctx context.Context, serverID string, predictionID string) (int, error) <span class="cov1" title="1">{
        var resp struct {
                Data struct {
                        TagsApplied int `json:"tags_applied"`
                } `json:"data"`
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        body := map[string]interface{}{}
        if predictionID != "" </span><span class="cov1" title="1">{
                body["prediction_id"] = predictionID
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/servers/%s/tag-suggestions/apply", serverID),
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="1">return resp.Data.TagsApplied, nil</span>
}

// RejectTagSuggestion rejects an ML tag suggestion with optional feedback
// Authentication: JWT Token required
// Endpoint: POST /v1/servers/{serverID}/tag-suggestions/{predictionID}/reject
// Parameters:
//   - serverID: Server ID or UUID
//   - predictionID: Prediction ID to reject
//   - feedback: Optional feedback for model improvement
// Returns: Success confirmation
func (s *MLService) RejectTagSuggestion(ctx context.Context, serverID string, predictionID string, feedback string) error <span class="cov1" title="1">{
        body := map[string]interface{}{}
        if feedback != "" </span><span class="cov1" title="1">{
                body["feedback"] = feedback
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/servers/%s/tag-suggestions/%s/reject", serverID, predictionID),
                Body:   body,
        })
        return err</span>
}

// Group Suggestion Methods

// GetGroupSuggestions retrieves ML-generated server grouping suggestions
// Authentication: JWT Token required
// Endpoint: GET /v1/groups/suggestions
// Parameters:
//   - opts: Optional pagination and filtering options
// Returns: Array of group suggestions with confidence scores
func (s *MLService) GetGroupSuggestions(ctx context.Context, opts *PaginationOptions) ([]GroupSuggestion, *ResponseMeta, error) <span class="cov1" title="1">{
        var resp struct {
                Data    []GroupSuggestion `json:"data"`
                Status  string            `json:"status"`
                Message string            `json:"message"`
                Meta    *ResponseMeta     `json:"meta,omitempty"`
        }

        query := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        query["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        query["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }

        <span class="cov1" title="1">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/groups/suggestions",
                Result: &amp;resp,
        }
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                req.Query = query
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, resp.Meta, nil</span>
}

// AcceptGroupSuggestion creates a server group from an ML suggestion
// Authentication: JWT Token required
// Endpoint: POST /v1/groups/suggestions/{id}/accept
// Parameters:
//   - suggestionID: Suggestion ID to accept
// Returns: Created group information
func (s *MLService) AcceptGroupSuggestion(ctx context.Context, suggestionID uint) (*GroupSuggestion, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *GroupSuggestion `json:"data"`
                Status  string           `json:"status"`
                Message string           `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/groups/suggestions/%d/accept", suggestionID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Data, nil</span>
}

// RejectGroupSuggestion rejects an ML grouping suggestion
// Authentication: JWT Token required
// Endpoint: POST /v1/groups/suggestions/{id}/reject
// Parameters:
//   - suggestionID: Suggestion ID to reject
// Returns: Success confirmation
func (s *MLService) RejectGroupSuggestion(ctx context.Context, suggestionID uint) error <span class="cov1" title="1">{
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/groups/suggestions/%d/reject", suggestionID),
        })
        return err
}</span>

// Model Management Methods

// ListModels retrieves available ML models with pagination
// Authentication: JWT Token required
// Endpoint: GET /v1/ml/models
// Parameters:
//   - opts: Optional pagination options
// Returns: Array of ML models with status and performance metrics
func (s *MLService) ListModels(ctx context.Context, opts *PaginationOptions) ([]MLModel, *ResponseMeta, error) <span class="cov1" title="1">{
        var resp struct {
                Data    []MLModel     `json:"data"`
                Status  string        `json:"status"`
                Message string        `json:"message"`
                Meta    *ResponseMeta `json:"meta,omitempty"`
        }

        query := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        query["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        query["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }

        <span class="cov1" title="1">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/ml/models",
                Result: &amp;resp,
        }
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                req.Query = query
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, resp.Meta, nil</span>
}

// TrainModel triggers training for a specific ML model
// Authentication: JWT Token required
// Endpoint: POST /v1/ml/models/train
// Parameters:
//   - modelType: Type of model to train (e.g., "tag_prediction", "group_suggestion")
//   - parameters: Optional training parameters
// Returns: Training job information
func (s *MLService) TrainModel(ctx context.Context, modelType string, parameters map[string]interface{}) (*TrainingJob, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *TrainingJob `json:"data"`
                Status  string       `json:"status"`
                Message string       `json:"message"`
        }

        body := map[string]interface{}{
                "model_type": modelType,
        }
        if parameters != nil </span><span class="cov0" title="0">{
                body["parameters"] = parameters
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/ml/models/train",
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// ToggleModel enables or disables a specific ML model
// Authentication: JWT Token required
// Endpoint: PUT /v1/ml/models/{model_id}/toggle
// Parameters:
//   - modelID: Model ID to toggle
// Returns: Updated model information
func (s *MLService) ToggleModel(ctx context.Context, modelID uint) (*MLModel, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *MLModel `json:"data"`
                Status  string   `json:"status"`
                Message string   `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/ml/models/%d/toggle", modelID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Data, nil</span>
}

// GetModelPerformance retrieves performance metrics for a specific model
// Authentication: JWT Token required
// Endpoint: GET /v1/ml/models/{model_id}/performance
// Parameters:
//   - modelID: Model ID
// Returns: Model performance metrics including accuracy, precision, recall
func (s *MLService) GetModelPerformance(ctx context.Context, modelID uint) (*ModelPerformance, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *ModelPerformance `json:"data"`
                Status  string            `json:"status"`
                Message string            `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/ml/models/%d/performance", modelID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// Training Job Methods

// TriggerModelTraining triggers batch model training for all models
// Authentication: JWT Token required
// Endpoint: POST /v1/ml/train-models
// Returns: Array of initiated training jobs
func (s *MLService) TriggerModelTraining(ctx context.Context) ([]TrainingJob, error) <span class="cov1" title="1">{
        var resp struct {
                Data    []TrainingJob `json:"data"`
                Status  string        `json:"status"`
                Message string        `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/ml/train-models",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// GetTrainingJobs retrieves training job history with filtering
// Authentication: JWT Token required
// Endpoint: GET /v1/ml/training-jobs
// Parameters:
//   - opts: Optional pagination and filtering options
//   - status: Optional status filter ("pending", "running", "completed", "failed")
// Returns: Array of training jobs with pagination metadata
func (s *MLService) GetTrainingJobs(ctx context.Context, opts *PaginationOptions, status string) ([]TrainingJob, *ResponseMeta, error) <span class="cov1" title="1">{
        var resp struct {
                Data    []TrainingJob `json:"data"`
                Status  string        `json:"status"`
                Message string        `json:"message"`
                Meta    *ResponseMeta `json:"meta,omitempty"`
        }

        query := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        query["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        query["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }
        <span class="cov1" title="1">if status != "" </span><span class="cov1" title="1">{
                query["status"] = status
        }</span>

        <span class="cov1" title="1">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/ml/training-jobs",
                Result: &amp;resp,
        }
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                req.Query = query
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, resp.Meta, nil</span>
}

// GetAggregatedModelPerformance retrieves aggregated performance metrics across all models
// Authentication: JWT Token required
// Endpoint: GET /v1/ml/model-performance
// Returns: Aggregated performance metrics
func (s *MLService) GetAggregatedModelPerformance(ctx context.Context) (*ModelPerformance, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *ModelPerformance `json:"data"`
                Status  string            `json:"status"`
                Message string            `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/ml/model-performance",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package nexmonyx

import (
        "encoding/json"
        "fmt"
        "time"
)

// CustomTime handles custom time parsing for API responses
type CustomTime struct {
        time.Time
}

// UnmarshalJSON implements json.Unmarshaler
func (ct *CustomTime) UnmarshalJSON(b []byte) error <span class="cov9" title="227">{
        s := string(b)
        s = s[1 : len(s)-1] // Remove quotes

        if s == "null" || s == "" </span><span class="cov2" title="2">{
                return nil
        }</span>

        // Try multiple formats
        <span class="cov9" title="225">formats := []string{
                time.RFC3339,
                "2006-01-02T15:04:05.000Z",
                "2006-01-02T15:04:05Z",
                "2006-01-02 15:04:05",
        }

        var err error
        for _, format := range formats </span><span class="cov10" title="336">{
                ct.Time, err = time.Parse(format, s)
                if err == nil </span><span class="cov9" title="188">{
                        return nil
                }</span>
        }

        <span class="cov6" title="37">return err</span>
}

// MarshalJSON implements json.Marshaler
func (ct CustomTime) MarshalJSON() ([]byte, error) <span class="cov9" title="268">{
        if ct.IsZero() </span><span class="cov8" title="95">{
                return []byte("null"), nil
        }</span>
        <span class="cov8" title="173">return json.Marshal(ct.Time.Format(time.RFC3339))</span>
}

// GormModel is the base model for all entities
type GormModel struct {
        ID        uint        `json:"id"`
        CreatedAt *CustomTime `json:"created_at,omitempty"`
        UpdatedAt *CustomTime `json:"updated_at,omitempty"`
        DeletedAt *CustomTime `json:"deleted_at,omitempty"`
}

// BaseModel is the base model for entities with UUID
type BaseModel struct {
        UUID      string      `json:"uuid"`
        CreatedAt *CustomTime `json:"created_at,omitempty"`
        UpdatedAt *CustomTime `json:"updated_at,omitempty"`
}

// ResponseMeta represents metadata in API responses (alias for PaginationMeta)
type ResponseMeta = PaginationMeta

// PaginationOptions represents common pagination parameters
type PaginationOptions struct {
        Page  int `json:"page,omitempty"`
        Limit int `json:"limit,omitempty"`
}

// Organization represents an organization
type Organization struct {
        GormModel
        UUID        string `json:"uuid"`
        Name        string `json:"name"`
        Description string `json:"description,omitempty"`
        Industry    string `json:"industry,omitempty"`
        Website     string `json:"website,omitempty"`
        Size        string `json:"size,omitempty"`
        Country     string `json:"country,omitempty"`
        TimeZone    string `json:"timezone,omitempty"`

        // Billing and subscription
        StripeCustomerID   string      `json:"stripe_customer_id,omitempty"`
        SubscriptionID     string      `json:"subscription_id,omitempty"`
        SubscriptionStatus string      `json:"subscription_status,omitempty"`
        SubscriptionPlan   string      `json:"subscription_plan,omitempty"`
        TrialEndsAt        *CustomTime `json:"trial_ends_at,omitempty"`

        // Features and limits
        MaxServers        int  `json:"max_servers"`
        MaxUsers          int  `json:"max_users"`
        MaxProbes         int  `json:"max_probes"`
        DataRetentionDays int  `json:"data_retention_days"`
        AlertsEnabled     bool `json:"alerts_enabled"`
        MonitoringEnabled bool `json:"monitoring_enabled"`

        // Relationships
        Users            []User   `json:"users,omitempty"`
        Servers          []Server `json:"servers,omitempty"`
        BillingContact   *User    `json:"billing_contact,omitempty"`
        TechnicalContact *User    `json:"technical_contact,omitempty"`

        // Settings and preferences
        Settings map[string]interface{} `json:"settings,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
        Tags     []string               `json:"tags,omitempty"`
}

// User represents a user
type User struct {
        GormModel
        Email          string `json:"email"`
        FirstName      string `json:"first_name,omitempty"`
        LastName       string `json:"last_name,omitempty"`
        DisplayName    string `json:"display_name,omitempty"`
        ProfilePicture string `json:"profile_picture,omitempty"`
        PhoneNumber    string `json:"phone_number,omitempty"`

        // Authentication
        Auth0ID          string      `json:"auth0_id,omitempty"`
        LastLogin        *CustomTime `json:"last_login,omitempty"`
        EmailVerified    bool        `json:"email_verified"`
        TwoFactorEnabled bool        `json:"two_factor_enabled"`

        // Organization and permissions
        OrganizationID uint          `json:"organization_id,omitempty"`
        Organization   *Organization `json:"organization,omitempty"`
        Role           string        `json:"role,omitempty"`
        Permissions    []string      `json:"permissions,omitempty"`
        IsActive       bool          `json:"is_active"`
        IsAdmin        bool          `json:"is_admin"`

        // Preferences
        Timezone          string                 `json:"timezone,omitempty"`
        Language          string                 `json:"language,omitempty"`
        NotificationPrefs map[string]bool        `json:"notification_prefs,omitempty"`
        UIPreferences     map[string]interface{} `json:"ui_preferences,omitempty"`
}

// Server represents a monitored server
type Server struct {
        GormModel
        ServerUUID     string        `json:"server_uuid"`
        ServerSecret   string        `json:"server_secret,omitempty"`
        Hostname       string        `json:"hostname"`
        FQDN           string        `json:"fqdn,omitempty"`
        OrganizationID uint          `json:"organization_id"`
        Organization   *Organization `json:"organization,omitempty"`

        // System information
        OS              string  `json:"os,omitempty"`
        OSVersion       string  `json:"os_version,omitempty"`
        OSArch          string  `json:"os_arch,omitempty"`
        KernelVersion   string  `json:"kernel_version,omitempty"`
        CPUArchitecture string  `json:"cpu_architecture,omitempty"`
        CPUModel        string  `json:"cpu_model,omitempty"`
        CPUCores        int     `json:"cpu_cores"`
        TotalMemoryGB   float64 `json:"total_memory_gb"`
        TotalDiskGB     float64 `json:"total_disk_gb"`

        // Network information
        MainIP            string   `json:"main_ip,omitempty"`
        IPv6Address       string   `json:"ipv6_address,omitempty"`
        NetworkInterfaces []string `json:"network_interfaces,omitempty"`

        // Location and classification
        Environment    string `json:"environment,omitempty"`
        Location       string `json:"location,omitempty"`
        DataCenter     string `json:"data_center,omitempty"`
        Rack           string `json:"rack,omitempty"`
        Classification string `json:"classification,omitempty"`

        // Monitoring and status
        LastHeartbeat     *CustomTime `json:"last_heartbeat,omitempty"`
        Status            string      `json:"status,omitempty"`
        AgentVersion      string      `json:"agent_version,omitempty"`
        MonitoringEnabled bool        `json:"monitoring_enabled"`
        AlertsEnabled     bool        `json:"alerts_enabled"`

        // Cloud/provider information
        Provider         string                 `json:"provider,omitempty"`
        ProviderID       string                 `json:"provider_id,omitempty"`
        InstanceType     string                 `json:"instance_type,omitempty"`
        Region           string                 `json:"region,omitempty"`
        AvailabilityZone string                 `json:"availability_zone,omitempty"`
        ProviderMetadata map[string]interface{} `json:"provider_metadata,omitempty"`

        // Tags and metadata
        Tags         []string               `json:"tags,omitempty"`
        Labels       map[string]string      `json:"labels,omitempty"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
        CustomFields map[string]interface{} `json:"custom_fields,omitempty"`
}

// ServerCreateRequest represents a request to create/register a new server
type ServerCreateRequest struct {
        Hostname       string `json:"hostname"`
        MainIP         string `json:"main_ip"`
        OS             string `json:"os"`
        OSVersion      string `json:"os_version"`
        OSArch         string `json:"os_arch"`
        SerialNumber   string `json:"serial_number"`
        MacAddress     string `json:"mac_address"`
        Environment    string `json:"environment,omitempty"`
        Location       string `json:"location,omitempty"`
        Classification string `json:"classification,omitempty"`
        HardwareIP     string `json:"hardware_ip,omitempty"`
        HardwareType   string `json:"hardware_type,omitempty"`
}

// ServerRegistrationResponse represents the response from server registration
type ServerRegistrationResponse struct {
        Server       *Server `json:"server"`
        ServerUUID   string  `json:"server_uuid"`
        ServerSecret string  `json:"server_secret"`
}

// ServerUpdateRequest represents a request to update server information
type ServerUpdateRequest struct {
        Hostname       string `json:"hostname,omitempty"`
        MainIP         string `json:"main_ip,omitempty"`
        Environment    string `json:"environment,omitempty"`
        Location       string `json:"location,omitempty"`
        Classification string `json:"classification,omitempty"`
}

// HardwareDetails represents detailed hardware information for server updates
type HardwareDetails struct {
        CPU     []ServerCPUInfo              `json:"cpu,omitempty"`
        Memory  *ServerMemoryInfo            `json:"memory,omitempty"`
        Network []ServerNetworkInterfaceInfo `json:"network,omitempty"`
        Disks   []ServerDiskInfo             `json:"disks,omitempty"`
}

// ServerCPUInfo represents CPU hardware information for server update requests
type ServerCPUInfo struct {
        PhysicalID       string  `json:"physical_id,omitempty"`
        Manufacturer     string  `json:"manufacturer,omitempty"`
        ModelName        string  `json:"model_name,omitempty"`
        Family           string  `json:"family,omitempty"`
        Model            string  `json:"model,omitempty"`
        Stepping         string  `json:"stepping,omitempty"`
        Microcode        string  `json:"microcode,omitempty"`
        Architecture     string  `json:"architecture,omitempty"`
        SocketType       string  `json:"socket_type,omitempty"`
        BaseSpeed        float64 `json:"base_speed,omitempty"`
        MaxSpeed         float64 `json:"max_speed,omitempty"`
        CurrentSpeed     float64 `json:"current_speed,omitempty"`
        BusSpeed         float64 `json:"bus_speed,omitempty"`
        SocketCount      int     `json:"socket_count,omitempty"`
        PhysicalCores    int     `json:"physical_cores,omitempty"`
        LogicalCores     int     `json:"logical_cores,omitempty"`
        L1Cache          int     `json:"l1_cache,omitempty"`
        L2Cache          int     `json:"l2_cache,omitempty"`
        L3Cache          int     `json:"l3_cache,omitempty"`
        Flags            string  `json:"flags,omitempty"`
        Virtualization   string  `json:"virtualization,omitempty"`
        PowerFeatures    string  `json:"power_features,omitempty"`
        Usage            float64 `json:"usage,omitempty"`
        Temperature      float64 `json:"temperature,omitempty"`
        PowerConsumption float64 `json:"power_consumption,omitempty"`
}

// ServerMemoryInfo represents memory hardware information for server update requests
type ServerMemoryInfo struct {
        TotalSize     uint64 `json:"total_size,omitempty"`
        AvailableSize uint64 `json:"available_size,omitempty"`
        UsedSize      uint64 `json:"used_size,omitempty"`
        MemoryType    string `json:"memory_type,omitempty"`
        Speed         int    `json:"speed,omitempty"`
        ModuleCount   int    `json:"module_count,omitempty"`
        ECCSupported  bool   `json:"ecc_supported,omitempty"`
}

// ServerNetworkInterfaceInfo represents network interface hardware information for server update requests
type ServerNetworkInterfaceInfo struct {
        Name          string `json:"name,omitempty"`
        HardwareAddr  string `json:"hardware_addr,omitempty"`
        MTU           int    `json:"mtu,omitempty"`
        Flags         string `json:"flags,omitempty"`
        Addrs         string `json:"addrs,omitempty"`
        BytesReceived uint64 `json:"bytes_received,omitempty"`
        BytesSent     uint64 `json:"bytes_sent,omitempty"`
        SpeedMbps     int    `json:"speed_mbps,omitempty"`
        IsUp          bool   `json:"is_up,omitempty"`
        IsWireless    bool   `json:"is_wireless,omitempty"`
}

// ServerDiskInfo represents disk hardware information for server update requests
type ServerDiskInfo struct {
        Device       string `json:"device,omitempty"`
        DiskModel    string `json:"disk_model,omitempty"`
        SerialNumber string `json:"serial_number,omitempty"`
        Size         int64  `json:"size,omitempty"`
        Type         string `json:"type,omitempty"`
        Vendor       string `json:"vendor,omitempty"`
}

// ServerDetailsUpdateRequest represents a request to update detailed server information
type ServerDetailsUpdateRequest struct {
        // Basic server information
        Hostname       string `json:"hostname,omitempty"`
        MainIP         string `json:"main_ip,omitempty"`
        Environment    string `json:"environment,omitempty"`
        Location       string `json:"location,omitempty"`
        Classification string `json:"classification,omitempty"`
        // System information
        OS           string `json:"os,omitempty"`
        OSVersion    string `json:"os_version,omitempty"`
        OSArch       string `json:"os_arch,omitempty"`
        SerialNumber string `json:"serial_number,omitempty"`
        MacAddress   string `json:"mac_address,omitempty"`
        // Hardware details (legacy fields for backward compatibility)
        CPUModel     string `json:"cpu_model,omitempty"`
        CPUCount     int    `json:"cpu_count,omitempty"`
        CPUCores     int    `json:"cpu_cores,omitempty"`
        MemoryTotal  uint64 `json:"memory_total,omitempty"`
        StorageTotal uint64 `json:"storage_total,omitempty"`
        // Enhanced hardware details (optional)
        Hardware *HardwareDetails `json:"hardware,omitempty"`
}

// Alert represents an alert
type Alert struct {
        GormModel
        Name           string  `json:"name"`
        Description    string  `json:"description,omitempty"`
        OrganizationID uint    `json:"organization_id"`
        ServerID       *uint   `json:"server_id,omitempty"`
        Server         *Server `json:"server,omitempty"`

        // Alert configuration
        Type       string  `json:"type"`
        MetricName string  `json:"metric_name"`
        Condition  string  `json:"condition"`
        Threshold  float64 `json:"threshold"`
        Duration   int     `json:"duration"`
        Frequency  int     `json:"frequency"`

        // Alert state
        Enabled       bool        `json:"enabled"`
        Status        string      `json:"status"`
        LastTriggered *CustomTime `json:"last_triggered,omitempty"`
        LastResolved  *CustomTime `json:"last_resolved,omitempty"`
        TriggerCount  int         `json:"trigger_count"`

        // Notification settings
        Severity        string   `json:"severity"`
        Channels        []string `json:"channels"`
        Recipients      []string `json:"recipients"`
        NotifyOnResolve bool     `json:"notify_on_resolve"`

        // Actions and metadata
        Actions  []AlertAction          `json:"actions,omitempty"`
        Tags     []string               `json:"tags,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// AlertAction represents an action to take when an alert triggers
type AlertAction struct {
        Type      string                 `json:"type"`
        Config    map[string]interface{} `json:"config"`
        OnTrigger bool                   `json:"on_trigger"`
        OnResolve bool                   `json:"on_resolve"`
}

// AlertChannel represents a notification channel configuration
type AlertChannel struct {
        ID             uint                   `json:"id"`
        Name           string                 `json:"name"`
        Type           string                 `json:"type"` // email, slack, pagerduty, webhook
        Configuration  map[string]interface{} `json:"configuration"`
        Enabled        bool                   `json:"enabled"`
        OrganizationID uint                   `json:"organization_id"`
        CreatedAt      time.Time              `json:"created_at"`
        UpdatedAt      time.Time              `json:"updated_at"`
}

// AlertRule represents a more detailed alert rule configuration
type AlertRule struct {
        ID             uint   `json:"id"`
        Name           string `json:"name"`
        Description    string `json:"description"`
        OrganizationID uint   `json:"organization_id"`

        // Scope configuration
        ScopeType  string `json:"scope_type"` // organization, server, tag, group
        ScopeID    *uint  `json:"scope_id,omitempty"`
        ScopeValue string `json:"scope_value,omitempty"`

        // Metric configuration
        MetricName  string `json:"metric_name"`
        Aggregation string `json:"aggregation"` // avg, sum, min, max, count

        // Conditions
        Conditions AlertConditions `json:"conditions"`

        // Notification settings
        ChannelIDs []uint `json:"channel_ids"`

        // State
        Enabled       bool       `json:"enabled"`
        LastEvaluated *time.Time `json:"last_evaluated,omitempty"`

        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// AlertConditions represents the conditions for triggering an alert
type AlertConditions struct {
        TimeWindow int              `json:"time_window"` // in minutes
        Thresholds []AlertThreshold `json:"thresholds"`
}

// AlertThreshold represents a threshold configuration
type AlertThreshold struct {
        Value    float64 `json:"value"`
        Operator string  `json:"operator"` // &gt;, &gt;=, &lt;, &lt;=, ==, !=
        Duration int     `json:"duration"` // in minutes (how long condition must be true)
        Severity string  `json:"severity"` // critical, warning, info
}

// Metric represents a metric data point
type Metric struct {
        ServerID   uint                   `json:"server_id"`
        ServerUUID string                 `json:"server_uuid"`
        Timestamp  time.Time              `json:"timestamp"`
        Name       string                 `json:"name"`
        Value      float64                `json:"value"`
        Unit       string                 `json:"unit,omitempty"`
        Tags       map[string]string      `json:"tags,omitempty"`
        Metadata   map[string]interface{} `json:"metadata,omitempty"`
}

// MonitoringAgent represents a monitoring agent
type MonitoringAgent struct {
        GormModel
        UUID           string                 `json:"uuid"`
        Name           string                 `json:"name"`
        Status         string                 `json:"status"`
        Version        string                 `json:"version"`
        OrganizationID uint                   `json:"organization_id"`
        ServerUUID     string                 `json:"server_uuid,omitempty"`
        Configuration  map[string]interface{} `json:"configuration,omitempty"`
        LastHeartbeat  *CustomTime            `json:"last_heartbeat,omitempty"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// ProbeTestResult represents the result of a probe test
type ProbeTestResult struct {
        GormModel
        ProbeID    uint        `json:"probe_id"`
        ProbeUUID  string      `json:"probe_uuid,omitempty"`
        AgentID    uint        `json:"agent_id,omitempty"`
        ExecutedAt *CustomTime `json:"executed_at"`
        Target     string      `json:"target,omitempty"`
        Type       string      `json:"type,omitempty"`

        // Result data
        Status       string `json:"status"`
        ResponseTime int    `json:"response_time"`
        StatusCode   int    `json:"status_code,omitempty"`
        ResponseBody string `json:"response_body,omitempty"`
        Error        string `json:"error,omitempty"`

        // Additional metrics
        DNSTime       int `json:"dns_time,omitempty"`
        ConnectTime   int `json:"connect_time,omitempty"`
        TLSTime       int `json:"tls_time,omitempty"`
        FirstByteTime int `json:"first_byte_time,omitempty"`
        TotalTime     int `json:"total_time,omitempty"`

        // Metadata
        Region   string                 `json:"region,omitempty"`
        Location string                 `json:"location,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// HardwareInventoryRequest represents a request to submit hardware inventory
type HardwareInventoryRequest struct {
        ServerUUID       string                `json:"server_uuid"`
        CollectedAt      time.Time             `json:"collected_at"`
        CollectionMethod string                `json:"collection_method,omitempty"`
        Hardware         HardwareInventoryInfo `json:"hardware"`
}

// HardwareInventoryInfo contains detailed hardware information
type HardwareInventoryInfo struct {
        // Legacy flat fields for backward compatibility
        Manufacturer     string                 `json:"manufacturer,omitempty"`
        Model            string                 `json:"model,omitempty"`
        SerialNumber     string                 `json:"serial_number,omitempty"`
        CollectionMethod string                 `json:"collection_method,omitempty"`
        DetectionTool    string                 `json:"detection_tool,omitempty"`
        AdditionalInfo   map[string]interface{} `json:"additional_info,omitempty"`

        // Structured hardware components
        System              *SystemHardwareInfo    `json:"system,omitempty"`
        Motherboard         *MotherboardInfo       `json:"motherboard,omitempty"`
        CPUs                []CPUInfo              `json:"cpus,omitempty"`
        Memory              *MemoryInfo            `json:"memory,omitempty"`
        MemoryModules       []MemoryModuleInfo     `json:"memory_modules,omitempty"`
        Storage             []StorageDeviceInfo    `json:"storage,omitempty"`
        StorageDevices      []StorageDeviceInfo    `json:"storage_devices,omitempty"` // Alias for Storage
        Network             []NetworkCardInfo      `json:"network,omitempty"`
        NetworkCards        []NetworkCardInfo      `json:"network_cards,omitempty"` // Alias for Network
        GPUs                []GPUInfo              `json:"gpus,omitempty"`
        PowerSupplies       []PowerSupplyInfo      `json:"power_supplies,omitempty"`
        RAIDControllers     []RAIDControllerInfo   `json:"raid_controllers,omitempty"`
        TemperatureSensors  []TemperatureSensorInfo `json:"temperature_sensors,omitempty"`
        Services            *ServiceInfo           `json:"services,omitempty"`
}

// SystemHardwareInfo represents system-level hardware information
type SystemHardwareInfo struct {
        Manufacturer string `json:"manufacturer,omitempty"`
        ProductName  string `json:"product_name,omitempty"`
        Version      string `json:"version,omitempty"`
        SerialNumber string `json:"serial_number,omitempty"`
        UUID         string `json:"uuid,omitempty"`
        SKU          string `json:"sku,omitempty"`
}

// MotherboardInfo represents motherboard information
type MotherboardInfo struct {
        Manufacturer string    `json:"manufacturer,omitempty"`
        ProductName  string    `json:"product_name,omitempty"`
        Version      string    `json:"version,omitempty"`
        SerialNumber string    `json:"serial_number,omitempty"`
        AssetTag     string    `json:"asset_tag,omitempty"`
        BIOS         *BIOSInfo `json:"bios,omitempty"`
}

// BIOSInfo represents BIOS information
type BIOSInfo struct {
        Vendor      string `json:"vendor,omitempty"`
        Version     string `json:"version,omitempty"`
        ReleaseDate string `json:"release_date,omitempty"`
        Revision    string `json:"revision,omitempty"`
}

// CPUInfo represents CPU information
type CPUInfo struct {
        Manufacturer string  `json:"manufacturer,omitempty"`
        Model        string  `json:"model,omitempty"`
        Architecture string  `json:"architecture,omitempty"`
        Cores        int     `json:"cores,omitempty"`
        Threads      int     `json:"threads,omitempty"`
        BaseSpeedMHz float64 `json:"base_speed_mhz,omitempty"`
        MaxSpeedMHz  float64 `json:"max_speed_mhz,omitempty"`
        CacheSizeKB  int     `json:"cache_size_kb,omitempty"`
        Socket       string  `json:"socket,omitempty"`
}

// MemoryInfo represents memory information
type MemoryInfo struct {
        TotalCapacity      int64              `json:"total_capacity,omitempty"` // bytes
        TotalSizeGB        float64            `json:"total_size_gb,omitempty"`
        TotalSlots         int                `json:"total_slots,omitempty"`
        AvailableSlots     int                `json:"available_slots,omitempty"`
        UsedSlots          int                `json:"used_slots,omitempty"`
        MaxCapacityGB      float64            `json:"max_capacity_gb,omitempty"`
        MaxCapacityPerSlot int64              `json:"max_capacity_per_slot,omitempty"`
        SupportedTypes     []string           `json:"supported_types,omitempty"`
        SupportedSpeeds    []int              `json:"supported_speeds,omitempty"`
        ECCSupported       bool               `json:"ecc_supported,omitempty"`
        Modules            []MemoryModuleInfo `json:"modules,omitempty"`
}

// MemoryModuleInfo represents individual memory module information
type MemoryModuleInfo struct {
        Size         int64   `json:"size,omitempty"` // bytes
        SizeGB       float64 `json:"size_gb,omitempty"`
        Type         string  `json:"type,omitempty"`
        Speed        int     `json:"speed,omitempty"` // MHz
        SpeedMHz     int     `json:"speed_mhz,omitempty"`
        Manufacturer string  `json:"manufacturer,omitempty"`
        SerialNumber string  `json:"serial_number,omitempty"`
        PartNumber   string  `json:"part_number,omitempty"`
        Slot         string  `json:"slot,omitempty"`
        FormFactor   string  `json:"form_factor,omitempty"`
        ECC          bool    `json:"ecc,omitempty"`
        Registered   bool    `json:"registered,omitempty"`
}

// StorageDeviceInfo represents storage device information
type StorageDeviceInfo struct {
        DeviceName      string  `json:"device_name,omitempty"`
        Model           string  `json:"model,omitempty"`
        Vendor          string  `json:"vendor,omitempty"`
        Manufacturer    string  `json:"manufacturer,omitempty"`
        SerialNumber    string  `json:"serial_number,omitempty"`
        Capacity        int64   `json:"capacity,omitempty"` // bytes
        SizeGB          float64 `json:"size_gb,omitempty"`
        Type            string  `json:"type,omitempty"`
        Interface       string  `json:"interface,omitempty"`
        FirmwareVersion string  `json:"firmware_version,omitempty"`
        SmartStatus     string  `json:"smart_status,omitempty"`
        Health          string  `json:"health,omitempty"`
        Temperature     int     `json:"temperature,omitempty"`
        PowerOnHours    int64   `json:"power_on_hours,omitempty"`
        WriteEndurance  float64 `json:"write_endurance,omitempty"`
        FormFactor      string  `json:"form_factor,omitempty"`
}

// NetworkCardInfo represents network card information
type NetworkCardInfo struct {
        Model         string   `json:"model,omitempty"`
        Vendor        string   `json:"vendor,omitempty"`
        MACAddress    string   `json:"mac_address,omitempty"`
        SpeedMbps     int      `json:"speed_mbps,omitempty"`
        PortCount     int      `json:"port_count,omitempty"`
        Capabilities  []string `json:"capabilities,omitempty"`
        Driver        string   `json:"driver,omitempty"`
        DriverVersion string   `json:"driver_version,omitempty"`
}

// GPUInfo represents GPU information
type GPUInfo struct {
        Model         string  `json:"model,omitempty"`
        Vendor        string  `json:"vendor,omitempty"`
        Manufacturer  string  `json:"manufacturer,omitempty"`
        MemoryGB      float64 `json:"memory_gb,omitempty"`
        MemorySize    int64   `json:"memory_size,omitempty"`
        Driver        string  `json:"driver,omitempty"`
        DriverVersion string  `json:"driver_version,omitempty"`
        BusID         string  `json:"bus_id,omitempty"`
        Temperature   int     `json:"temperature,omitempty"`
}

// PowerSupplyInfo represents power supply information
type PowerSupplyInfo struct {
        Model             string  `json:"model,omitempty"`
        Manufacturer      string  `json:"manufacturer,omitempty"`
        SerialNumber      string  `json:"serial_number,omitempty"`
        MaxPowerWatts     int     `json:"max_power_watts,omitempty"`
        Type              string  `json:"type,omitempty"`
        Status            string  `json:"status,omitempty"`
        Efficiency        string  `json:"efficiency,omitempty"`
        CurrentPowerWatts float64 `json:"current_power_watts,omitempty"`
        Voltage           float64 `json:"voltage,omitempty"`
        Current           float64 `json:"current,omitempty"`
        Temperature       float64 `json:"temperature,omitempty"`
        FanSpeed          int     `json:"fan_speed,omitempty"`
        InputVoltage      float64 `json:"input_voltage,omitempty"`
        OutputVoltage     float64 `json:"output_voltage,omitempty"`
}

// SystemInfo represents system information for metrics
type SystemInfo struct {
        Hostname        string `json:"hostname"`
        OS              string `json:"os"`
        OSVersion       string `json:"os_version"`
        Kernel          string `json:"kernel"`
        KernelVersion   string `json:"kernel_version,omitempty"`
        Architecture    string `json:"architecture"`
        CPUArchitecture string `json:"cpu_architecture,omitempty"`
        Uptime          int64  `json:"uptime"`
        BootTime        int64  `json:"boot_time"`
        Processes       int    `json:"processes"`
        UsersLoggedIn   int    `json:"users_logged_in"`
        Platform        string `json:"platform,omitempty"`
        PlatformFamily  string `json:"platform_family,omitempty"`
}

// CPUMetrics represents CPU metrics
type CPUMetrics struct {
        UsagePercent  float64   `json:"usage_percent"`
        LoadAverage1  float64   `json:"load_average_1"`
        LoadAverage5  float64   `json:"load_average_5"`
        LoadAverage15 float64   `json:"load_average_15"`
        UserPercent   float64   `json:"user_percent"`
        SystemPercent float64   `json:"system_percent"`
        IdlePercent   float64   `json:"idle_percent"`
        IOWaitPercent float64   `json:"iowait_percent"`
        StealPercent  float64   `json:"steal_percent"`
        CoreCount     int       `json:"core_count"`
        ThreadCount   int       `json:"thread_count"`
        PerCoreUsage  []float64 `json:"per_core_usage,omitempty"`
}

// MemoryMetrics represents memory metrics
type MemoryMetrics struct {
        TotalBytes       int64   `json:"total_bytes"`
        UsedBytes        int64   `json:"used_bytes"`
        FreeBytes        int64   `json:"free_bytes"`
        AvailableBytes   int64   `json:"available_bytes"`
        UsagePercent     float64 `json:"usage_percent"`
        BuffersBytes     int64   `json:"buffers_bytes"`
        CachedBytes      int64   `json:"cached_bytes"`
        SwapTotalBytes   int64   `json:"swap_total_bytes"`
        SwapUsedBytes    int64   `json:"swap_used_bytes"`
        SwapFreeBytes    int64   `json:"swap_free_bytes"`
        SwapUsagePercent float64 `json:"swap_usage_percent"`
}

// DiskMetrics represents disk metrics
type DiskMetrics struct {
        Device             string  `json:"device"`
        Mountpoint         string  `json:"mountpoint"`
        Filesystem         string  `json:"filesystem"`
        TotalBytes         int64   `json:"total_bytes"`
        UsedBytes          int64   `json:"used_bytes"`
        FreeBytes          int64   `json:"free_bytes"`
        UsagePercent       float64 `json:"usage_percent"`
        InodesTotal        int64   `json:"inodes_total"`
        InodesUsed         int64   `json:"inodes_used"`
        InodesFree         int64   `json:"inodes_free"`
        InodesUsagePercent float64 `json:"inodes_usage_percent"`
}

// DiskUsageAggregate represents aggregated disk usage summary across all filesystems
type DiskUsageAggregate struct {
        TotalBytes      uint64   `json:"total_bytes"`      // Total bytes across all filesystems
        UsedBytes       uint64   `json:"used_bytes"`       // Used bytes across all filesystems
        FreeBytes       uint64   `json:"free_bytes"`       // Free bytes across all filesystems
        UsedPercent     float64  `json:"used_percent"`     // Overall usage percentage
        FilesystemCount int      `json:"filesystem_count"` // Number of filesystems included in aggregation
        LargestMount    string   `json:"largest_mount"`    // Mount point with largest capacity
        CriticalMounts  []string `json:"critical_mounts"`  // Mount points &gt;90% full
        CalculatedAt    string   `json:"calculated_at"`    // ISO 8601 timestamp when aggregation was calculated
}

// NetworkMetrics represents network metrics
type NetworkMetrics struct {
        Interface   string `json:"interface"`
        BytesRecv   int64  `json:"bytes_recv"`
        BytesSent   int64  `json:"bytes_sent"`
        PacketsRecv int64  `json:"packets_recv"`
        PacketsSent int64  `json:"packets_sent"`
        ErrorsIn    int64  `json:"errors_in"`
        ErrorsOut   int64  `json:"errors_out"`
        DropsIn     int64  `json:"drops_in"`
        DropsOut    int64  `json:"drops_out"`
}

// ProcessMetrics represents process metrics
type ProcessMetrics struct {
        PID           int     `json:"pid"`
        Name          string  `json:"name"`
        Username      string  `json:"username"`
        State         string  `json:"state"`
        CPUPercent    float64 `json:"cpu_percent"`
        MemoryPercent float64 `json:"memory_percent"`
        MemoryRSS     int64   `json:"memory_rss"`
        MemoryVMS     int64   `json:"memory_vms"`
        CreateTime    int64   `json:"create_time"`
        OpenFiles     int     `json:"open_files"`
        NumThreads    int     `json:"num_threads"`
}

// ComprehensiveMetricsRequest represents a comprehensive metrics submission
type ComprehensiveMetricsRequest struct {
        ServerUUID         string                 `json:"server_uuid"`
        CollectedAt        string                 `json:"collected_at"`
        SystemInfo         *SystemInfo            `json:"system_info,omitempty"`
        CPU                *CPUMetrics            `json:"cpu,omitempty"`
        Memory             *MemoryMetrics         `json:"memory,omitempty"`
        Disks              []DiskMetrics          `json:"disks,omitempty"`
        DiskUsageAggregate *DiskUsageAggregate    `json:"disk_usage_aggregate,omitempty"`
        Network            []NetworkMetrics       `json:"network,omitempty"`
        Processes          []ProcessMetrics       `json:"processes,omitempty"`
        Temperature        *TemperatureMetrics    `json:"temperature,omitempty"`
        Power              *PowerMetrics          `json:"power,omitempty"`
        Services           *ServiceInfo           `json:"services,omitempty"`
        CustomMetrics      map[string]interface{} `json:"custom_metrics,omitempty"`
}

// TimescaleDiskMetrics represents disk metrics for Timescale
type TimescaleDiskMetrics struct {
        Devices []TimescaleDiskDevice `json:"devices"`
}

// TimescaleDiskDevice represents individual disk device metrics
type TimescaleDiskDevice struct {
        Name                  string  `json:"name"`
        ReadCount             uint64  `json:"read_count"`
        WriteCount            uint64  `json:"write_count"`
        ReadBytes             uint64  `json:"read_bytes"`
        WriteBytes            uint64  `json:"write_bytes"`
        ReadTime              uint64  `json:"read_time"`
        WriteTime             uint64  `json:"write_time"`
        IoTime                uint64  `json:"io_time"`
        Size                  uint64  `json:"size"`
        ReadsPerSec           float64 `json:"reads_per_sec"`
        WritesPerSec          float64 `json:"writes_per_sec"`
        DiscardsPerSec        float64 `json:"discards_per_sec"`
        FlushesPerSec         float64 `json:"flushes_per_sec"`
        ReadKBPerSec          float64 `json:"read_kb_per_sec"`
        WriteKBPerSec         float64 `json:"write_kb_per_sec"`
        DiscardKBPerSec       float64 `json:"discard_kb_per_sec"`
        ReadMergePercent      float64 `json:"read_merge_percent"`
        WriteMergePercent     float64 `json:"write_merge_percent"`
        DiscardMergePercent   float64 `json:"discard_merge_percent"`
        AvgReadRequestSize    float64 `json:"avg_read_request_size"`
        AvgWriteRequestSize   float64 `json:"avg_write_request_size"`
        AvgDiscardRequestSize float64 `json:"avg_discard_request_size"`
        AvgReadWait           float64 `json:"avg_read_wait"`
        AvgWriteWait          float64 `json:"avg_write_wait"`
        AvgDiscardWait        float64 `json:"avg_discard_wait"`
        AvgFlushWait          float64 `json:"avg_flush_wait"`
        AvgQueueSize          float64 `json:"avg_queue_size"`
        Utilization           float64 `json:"utilization"`
        QueueDepth            uint64  `json:"queue_depth"`
}

// TimescaleNetworkMetrics represents network metrics for Timescale
type TimescaleNetworkMetrics struct {
        Interfaces []TimescaleNetworkInterface `json:"interfaces"`
}

// TimescaleNetworkInterface represents individual network interface metrics
type TimescaleNetworkInterface struct {
        Name        string  `json:"name"`
        BytesSent   uint64  `json:"bytes_sent"`
        BytesRecv   uint64  `json:"bytes_recv"`
        PacketsSent uint64  `json:"packets_sent"`
        PacketsRecv uint64  `json:"packets_recv"`
        Errin       uint64  `json:"errin"`
        Errout      uint64  `json:"errout"`
        Dropin      uint64  `json:"dropin"`
        Dropout     uint64  `json:"dropout"`
        Speed       uint64  `json:"speed"`
        Mtu         uint64  `json:"mtu"`
        State       string  `json:"state"`
        RxRateKbps  float64 `json:"rx_rate_kbps"`
        TxRateKbps  float64 `json:"tx_rate_kbps"`
}

// TimescaleFilesystemMetrics represents filesystem metrics for Timescale
type TimescaleFilesystemMetrics struct {
        Filesystems []TimescaleFilesystem `json:"filesystems"`
}

// TimescaleFilesystem represents individual filesystem metrics
type TimescaleFilesystem struct {
        Device      string  `json:"device"`
        Mountpoint  string  `json:"mountpoint"`
        Fstype      string  `json:"fstype"`
        Total       uint64  `json:"total"`
        Used        uint64  `json:"used"`
        Free        uint64  `json:"free"`
        UsedPercent float64 `json:"used_percent"`
        InodesTotal uint64  `json:"inodes_total"`
        InodesUsed  uint64  `json:"inodes_used"`
        InodesFree  uint64  `json:"inodes_free"`
}

// TimescaleHostInfo represents host system information
type TimescaleHostInfo struct {
        Hostname       string `json:"hostname"`
        Uptime         uint64 `json:"uptime"`
        BootTime       uint64 `json:"boot_time"`
        Procs          uint32 `json:"procs"`
        OS             string `json:"os"`
        Platform       string `json:"platform"`
        PlatformFamily string `json:"platform_family"`
}

// RAIDControllerInfo represents RAID controller information
type RAIDControllerInfo struct {
        Manufacturer    string             `json:"manufacturer,omitempty"`
        Model           string             `json:"model,omitempty"`
        FirmwareVersion string             `json:"firmware_version,omitempty"`
        CacheSize       int64              `json:"cache_size,omitempty"`
        BatteryBackup   bool               `json:"battery_backup,omitempty"`
        BatteryStatus   string             `json:"battery_status,omitempty"`
        RAIDLevels      []string           `json:"raid_levels,omitempty"`
        LogicalDrives   []RAIDLogicalDrive `json:"logical_drives,omitempty"`
}

// RAIDLogicalDrive represents a logical drive on a RAID controller
type RAIDLogicalDrive struct {
        ID        string `json:"id,omitempty"`
        Name      string `json:"name,omitempty"`
        RAIDLevel string `json:"raid_level,omitempty"`
        Size      int64  `json:"size,omitempty"`
        Status    string `json:"status,omitempty"`
        DiskCount int    `json:"disk_count,omitempty"`
}

// HardwareInventorySubmitResponse represents the response from submitting hardware inventory
type HardwareInventorySubmitResponse struct {
        ServerUUID       string         `json:"server_uuid"`
        Timestamp        time.Time      `json:"timestamp"`
        CollectionMethod string         `json:"collection_method,omitempty"`
        DetectionTool    string         `json:"detection_tool,omitempty"`
        ComponentCounts  map[string]int `json:"component_counts,omitempty"`
}

// HardwareInventoryRecord represents a hardware inventory record with metadata
type HardwareInventoryRecord struct {
        ID               uint                  `json:"id"`
        ServerUUID       string                `json:"server_uuid"`
        OrganizationID   uint                  `json:"organization_id"`
        CollectedAt      time.Time             `json:"collected_at"`
        CollectionMethod string                `json:"collection_method,omitempty"`
        DetectionTool    string                `json:"detection_tool,omitempty"`
        CreatedAt        time.Time             `json:"created_at"`
        UpdatedAt        time.Time             `json:"updated_at"`
        Hardware         HardwareInventoryInfo `json:"hardware"`
        Timestamp        time.Time             `json:"timestamp"`
}

// HardwareInventoryListOptions represents options for listing hardware inventory
type HardwareInventoryListOptions struct {
        ListOptions
        StartTime *time.Time `url:"start_time,omitempty"`
        EndTime   *time.Time `url:"end_time,omitempty"`
}

// ToQuery converts HardwareInventoryListOptions to query parameters
func (o *HardwareInventoryListOptions) ToQuery() map[string]string <span class="cov2" title="3">{
        params := o.ListOptions.ToQuery()
        if o.StartTime != nil </span><span class="cov2" title="2">{
                params["start_time"] = o.StartTime.Format(time.RFC3339)
        }</span>
        <span class="cov2" title="3">if o.EndTime != nil </span><span class="cov2" title="2">{
                params["end_time"] = o.EndTime.Format(time.RFC3339)
        }</span>
        <span class="cov2" title="3">return params</span>
}

// Controller health and heartbeat types
type ControllerHealthInfo struct {
        Status        string                 `json:"status"`
        Version       string                 `json:"version"`
        Uptime        time.Duration          `json:"uptime"`
        LastHeartbeat *CustomTime            `json:"last_heartbeat,omitempty"`
        ResourceUsage *ResourceUsageInfo     `json:"resource_usage,omitempty"`
        Metadata      map[string]interface{} `json:"metadata,omitempty"`

        // Additional fields needed by monitoring-controller:
        ServiceComponents map[string]string `json:"service_components,omitempty"`
        RegionHealth      map[string]string `json:"region_health,omitempty"`
        LastErrors        []string          `json:"last_errors,omitempty"`
}

type ControllerHeartbeatRequest struct {
        ControllerID  string                `json:"controller_id"`
        Status        string                `json:"status"`
        Version       string                `json:"version"`
        Health        *ControllerHealthInfo `json:"health"`
        ResourceUsage *ResourceUsageInfo    `json:"resource_usage,omitempty"`
        Timestamp     time.Time             `json:"timestamp"`

        // Additional fields needed by monitoring-controller:
        ControllerName    string                 `json:"controller_name"`
        ControllerType    string                 `json:"controller_type"`
        HeartbeatInterval int                    `json:"heartbeat_interval"`
        IsLeader          bool                   `json:"is_leader"`
        Metadata          map[string]interface{} `json:"metadata,omitempty"`
        HealthDetails     *ControllerHealthInfo  `json:"health_details,omitempty"`
}

type ResourceUsageInfo struct {
        CPUUsage       float64 `json:"cpu_usage"`
        MemoryUsage    int64   `json:"memory_usage"`
        MemoryLimit    int64   `json:"memory_limit,omitempty"`
        DiskUsage      int64   `json:"disk_usage,omitempty"`
        NetworkRxBytes int64   `json:"network_rx_bytes,omitempty"`
        NetworkTxBytes int64   `json:"network_tx_bytes,omitempty"`
}

// Regional monitoring types
type MonitoringRegion struct {
        GormModel
        Code        string                 `json:"code"`
        Name        string                 `json:"name"`
        Status      RegionStatus           `json:"status"`
        Location    string                 `json:"location,omitempty"`
        Description string                 `json:"description,omitempty"`
        Enabled     bool                   `json:"enabled"`
        Priority    int                    `json:"priority"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

type RegionStatus string

const (
        RegionStatusActive      RegionStatus = "active"
        RegionStatusInactive    RegionStatus = "inactive"
        RegionStatusMaintenance RegionStatus = "maintenance"
)

// Remote cluster types
type RemoteCluster struct {
        GormModel
        Name         string                 `json:"name"`
        Endpoint     string                 `json:"endpoint"`
        Region       string                 `json:"region"`
        Status       string                 `json:"status"`
        Version      string                 `json:"version,omitempty"`
        Capabilities []string               `json:"capabilities,omitempty"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"`
        LastSeen     *CustomTime            `json:"last_seen,omitempty"`
}

// ControllerHeartbeat represents a controller heartbeat record
type ControllerHeartbeat struct {
        GormModel
        ControllerID  string                `json:"controller_id"`
        Status        string                `json:"status"`
        Version       string                `json:"version"`
        Health        *ControllerHealthInfo `json:"health"`
        ResourceUsage *ResourceUsageInfo    `json:"resource_usage,omitempty"`
        Timestamp     time.Time             `json:"timestamp"`
}

// NamespaceDeployment represents a deployment within a namespace
type NamespaceDeployment struct {
        GormModel
        Name           string                 `json:"name"`
        Namespace      string                 `json:"namespace"`
        OrganizationID uint                   `json:"organization_id"`
        Status         string                 `json:"status"`
        AgentVersion   string                 `json:"agent_version"`
        Configuration  map[string]interface{} `json:"configuration,omitempty"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
        LastUpdated    *CustomTime            `json:"last_updated,omitempty"`
}

// ProbeCreateRequest represents a request to create a probe
type ProbeCreateRequest struct {
        Name           string                 `json:"name"`
        Type           string                 `json:"type"`
        Target         string                 `json:"target"`
        Configuration  map[string]interface{} `json:"configuration,omitempty"`
        Interval       int                    `json:"interval"`
        Timeout        int                    `json:"timeout"`
        OrganizationID uint                   `json:"organization_id"`
        RegionCode     string                 `json:"region_code,omitempty"`
        Enabled        bool                   `json:"enabled"`
}

// ProbeUpdateRequest represents a request to update a probe
type ProbeUpdateRequest struct {
        Name          *string                `json:"name,omitempty"`
        Type          *string                `json:"type,omitempty"`
        Target        *string                `json:"target,omitempty"`
        Configuration map[string]interface{} `json:"configuration,omitempty"`
        Interval      *int                   `json:"interval,omitempty"`
        Timeout       *int                   `json:"timeout,omitempty"`
        RegionCode    *string                `json:"region_code,omitempty"`
        Enabled       *bool                  `json:"enabled,omitempty"`
}

// ProbeMetricsOptions represents options for retrieving probe metrics
type ProbeMetricsOptions struct {
        ProbeUUID   string     `json:"probe_uuid"`
        StartTime   *time.Time `json:"start_time,omitempty"`
        EndTime     *time.Time `json:"end_time,omitempty"`
        Granularity string     `json:"granularity,omitempty"` // minute, hour, day
        Aggregation string     `json:"aggregation,omitempty"` // avg, min, max, sum
}

// AggregatedMetricsRequest represents a request to submit aggregated metrics
type AggregatedMetricsRequest struct {
        ServerUUID  string               `json:"server_uuid"`
        CollectedAt string               `json:"collected_at"`
        Disk        *DiskAggregation     `json:"disk,omitempty"`
        CPU         *CPUAggregation      `json:"cpu,omitempty"`
        Memory      *MemoryAggregation   `json:"memory,omitempty"`
        Network     *NetworkAggregation  `json:"network,omitempty"`
        GPU         *GPUAggregation      `json:"gpu,omitempty"`
}

// DiskAggregation represents aggregated disk metrics
type DiskAggregation struct {
        TotalBytes      uint64   `json:"total_bytes"`
        UsedBytes       uint64   `json:"used_bytes"`
        FreeBytes       uint64   `json:"free_bytes"`
        UsedPercent     float64  `json:"used_percent"`
        FilesystemCount int      `json:"filesystem_count"`
        LargestMount    string   `json:"largest_mount"`
        CriticalMounts  []string `json:"critical_mounts"`
        CalculatedAt    string   `json:"calculated_at"`
}

// CPUAggregation represents aggregated CPU metrics
type CPUAggregation struct {
        UsagePercent   float64 `json:"usage_percent"`
        LoadAverage1   float64 `json:"load_average_1"`
        LoadAverage5   float64 `json:"load_average_5"`
        LoadAverage15  float64 `json:"load_average_15"`
        CoreCount      int     `json:"core_count"`
        MaxCorePercent float64 `json:"max_core_percent"`
        MinCorePercent float64 `json:"min_core_percent"`
        StealPercent   float64 `json:"steal_percent"`
        IOWaitPercent  float64 `json:"iowait_percent"`
        CalculatedAt   string  `json:"calculated_at"`
}

// MemoryAggregation represents aggregated memory metrics
type MemoryAggregation struct {
        TotalBytes      uint64  `json:"total_bytes"`
        UsedBytes       uint64  `json:"used_bytes"`
        FreeBytes       uint64  `json:"free_bytes"`
        AvailableBytes  uint64  `json:"available_bytes"`
        UsedPercent     float64 `json:"used_percent"`
        SwapTotalBytes  uint64  `json:"swap_total_bytes"`
        SwapUsedBytes   uint64  `json:"swap_used_bytes"`
        SwapUsedPercent float64 `json:"swap_used_percent"`
        CacheBytes      uint64  `json:"cache_bytes"`
        BufferBytes     uint64  `json:"buffer_bytes"`
        CalculatedAt    string  `json:"calculated_at"`
}

// NetworkAggregation represents aggregated network metrics
type NetworkAggregation struct {
        TotalBandwidthBPS uint64  `json:"total_bandwidth_bps"`
        IngressBPS        uint64  `json:"ingress_bps"`
        EgressBPS         uint64  `json:"egress_bps"`
        TotalInterfaces   int     `json:"total_interfaces"`
        ActiveInterfaces  int     `json:"active_interfaces"`
        ErrorRate         float64 `json:"error_rate"`
        DropRate          float64 `json:"drop_rate"`
        PrimaryInterface  string  `json:"primary_interface"`
        CalculatedAt      string  `json:"calculated_at"`
}

// GPUAggregation represents aggregated GPU metrics
type GPUAggregation struct {
        TotalGPUs         int     `json:"total_gpus"`
        AvgUsagePercent   float64 `json:"avg_usage_percent"`
        MaxUsagePercent   float64 `json:"max_usage_percent"`
        TotalMemoryBytes  uint64  `json:"total_memory_bytes"`
        UsedMemoryBytes   uint64  `json:"used_memory_bytes"`
        MemoryUsedPercent float64 `json:"memory_used_percent"`
        AvgTemperature    float64 `json:"avg_temperature"`
        MaxTemperature    float64 `json:"max_temperature"`
        PowerUsageWatts   float64 `json:"power_usage_watts"`
        CalculatedAt      string  `json:"calculated_at"`
}

// TemperatureMetrics represents temperature sensor data
type TemperatureMetrics struct {
        Sensors []TemperatureSensorData `json:"sensors,omitempty"`
}

// TemperatureSensorData represents individual temperature sensor data
type TemperatureSensorData struct {
        SensorID      string  `json:"sensor_id"`
        SensorName    string  `json:"sensor_name"`
        Temperature   float64 `json:"temperature"`      // in Celsius
        Status        string  `json:"status"`           // ok, warning, critical
        Type          string  `json:"type,omitempty"`   // cpu, system, disk, gpu, etc.
        Location      string  `json:"location,omitempty"`
        UpperWarning  float64 `json:"upper_warning,omitempty"`
        UpperCritical float64 `json:"upper_critical,omitempty"`
}

// PowerMetrics represents power supply data
type PowerMetrics struct {
        PowerSupplies []PowerSupplyMetrics `json:"power_supplies,omitempty"`
        TotalPowerW   float64             `json:"total_power_watts,omitempty"`
}

// PowerSupplyMetrics represents individual power supply metrics
type PowerSupplyMetrics struct {
        ID            string  `json:"id"`
        Name          string  `json:"name"`
        Status        string  `json:"status"`        // ok, warning, critical, failed
        PowerWatts    float64 `json:"power_watts"`   // current power draw
        MaxPowerWatts float64 `json:"max_power_watts"`
        Voltage       float64 `json:"voltage,omitempty"`
        Current       float64 `json:"current,omitempty"`
        Efficiency    float64 `json:"efficiency,omitempty"` // percentage
        Temperature   float64 `json:"temperature,omitempty"`
}

// TemperatureSensorInfo represents temperature sensor information for hardware inventory
type TemperatureSensorInfo struct {
        SensorID      string  `json:"sensor_id"`
        SensorName    string  `json:"sensor_name"`
        Type          string  `json:"type"`
        Location      string  `json:"location,omitempty"`
        MaxTemp       float64 `json:"max_temp,omitempty"`
        MinTemp       float64 `json:"min_temp,omitempty"`
}

// ServiceInfo contains service monitoring data
type ServiceInfo struct {
        Services []*ServiceMonitoringInfo      `json:"services,omitempty"`
        Metrics  []*ServiceMetrics             `json:"metrics,omitempty"`
        Logs     map[string][]ServiceLogEntry  `json:"logs,omitempty"`
}

// ServiceMonitoringInfo represents service monitoring data
type ServiceMonitoringInfo struct {
        Name          string     `json:"name"`
        State         string     `json:"state"`         // active, inactive, failed
        SubState      string     `json:"sub_state"`     // running, dead, exited, etc.
        LoadState     string     `json:"load_state"`    // loaded, not-found, masked
        Description   string     `json:"description"`
        MainPID       int        `json:"main_pid"`
        MemoryCurrent uint64     `json:"memory_current"`
        CPUUsageNSec  uint64     `json:"cpu_usage_nsec"`
        TasksCurrent  uint64     `json:"tasks_current"`
        RestartCount  int        `json:"restart_count"`
        ActiveSince   *time.Time `json:"active_since,omitempty"`
}

// ServiceMetrics represents service resource metrics
type ServiceMetrics struct {
        ServiceName  string    `json:"service_name"`
        Timestamp    time.Time `json:"timestamp"`
        CPUPercent   float64   `json:"cpu_percent"`
        MemoryRSS    uint64    `json:"memory_rss"`
        ProcessCount int       `json:"process_count"`
        ThreadCount  int       `json:"thread_count"`
}

// ServiceLogEntry represents a service log entry
type ServiceLogEntry struct {
        Timestamp time.Time         `json:"timestamp"`
        Level     string            `json:"level"`
        Message   string            `json:"message"`
        Fields    map[string]string `json:"fields,omitempty"`
}

// ServiceMonitoringConfig represents configuration for service monitoring
type ServiceMonitoringConfig struct {
        Enabled         bool     `json:"enabled"`          // Enable service monitoring
        IncludeServices []string `json:"include_services"` // Specific services to monitor
        ExcludeServices []string `json:"exclude_services"` // Services to exclude
        IncludePatterns []string `json:"include_patterns"` // Patterns like "nginx*", "apache*"
        ExcludePatterns []string `json:"exclude_patterns"` // Patterns like "*.scope", "*.slice"
        CollectMetrics  bool     `json:"collect_metrics"`  // Collect resource metrics
        CollectLogs     bool     `json:"collect_logs"`     // Collect recent logs
        LogLines        int      `json:"log_lines"`        // Number of recent log lines
        MetricsInterval string   `json:"metrics_interval"` // How often to collect metrics
        LogStateFile    string   `json:"log_state_file"`   // Path to log state file
}

// Type alias for backward compatibility
type Probe = MonitoringProbe

// IncidentSeverity represents the severity level of an incident
type IncidentSeverity string

const (
        // IncidentSeverityCritical indicates a critical incident requiring immediate attention
        IncidentSeverityCritical IncidentSeverity = "critical"
        // IncidentSeverityWarning indicates a warning-level incident
        IncidentSeverityWarning IncidentSeverity = "warning"
        // IncidentSeverityInfo indicates an informational incident
        IncidentSeverityInfo IncidentSeverity = "info"
)

// IncidentStatus represents the current status of an incident
type IncidentStatus string

const (
        // IncidentStatusActive indicates the incident is active and needs attention
        IncidentStatusActive IncidentStatus = "active"
        // IncidentStatusResolved indicates the incident has been resolved
        IncidentStatusResolved IncidentStatus = "resolved"
        // IncidentStatusAcknowledged indicates the incident has been acknowledged
        IncidentStatusAcknowledged IncidentStatus = "acknowledged"
)

// IncidentSource represents the source that created the incident
type IncidentSource string

const (
        // IncidentSourceProbe indicates the incident was created from a probe failure
        IncidentSourceProbe IncidentSource = "probe"
        // IncidentSourceAlert indicates the incident was created from an alert
        IncidentSourceAlert IncidentSource = "alert"
        // IncidentSourceManual indicates the incident was created manually
        IncidentSourceManual IncidentSource = "manual"
)

// IncidentEventType represents the type of event in an incident timeline
type IncidentEventType string

const (
        // IncidentEventTypeCreated indicates the incident was created
        IncidentEventTypeCreated IncidentEventType = "created"
        // IncidentEventTypeUpdated indicates the incident was updated
        IncidentEventTypeUpdated IncidentEventType = "updated"
        // IncidentEventTypeResolved indicates the incident was resolved
        IncidentEventTypeResolved IncidentEventType = "resolved"
        // IncidentEventTypeAcknowledged indicates the incident was acknowledged
        IncidentEventTypeAcknowledged IncidentEventType = "acknowledged"
        // IncidentEventTypeEscalated indicates the incident was escalated
        IncidentEventTypeEscalated IncidentEventType = "escalated"
        // IncidentEventTypeAssigned indicates the incident was assigned to someone
        IncidentEventTypeAssigned IncidentEventType = "assigned"
        // IncidentEventTypeComment indicates a comment was added to the incident
        IncidentEventTypeComment IncidentEventType = "comment"
)

// AffectedResource represents a resource affected by an incident
type AffectedResource struct {
        Type string `json:"type"` // "server", "probe", "service"
        ID   uint   `json:"id"`
        Name string `json:"name"`
}

// Incident represents an incident in the system
type Incident struct {
        GormModel
        OrganizationID    uint                  `json:"organization_id"`
        Organization      *Organization         `json:"organization,omitempty"`
        Title             string                `json:"title"`
        Description       string                `json:"description"`
        Severity          IncidentSeverity      `json:"severity"`
        Status            IncidentStatus        `json:"status"`
        Source            IncidentSource        `json:"source"`
        SourceID          *uint                 `json:"source_id,omitempty"`
        AffectedResources []AffectedResource    `json:"affected_resources"`
        StartedAt         *CustomTime           `json:"started_at"`
        ResolvedAt        *CustomTime           `json:"resolved_at,omitempty"`
        Events            []IncidentEvent       `json:"events,omitempty"`
}

// IncidentEvent represents an event in an incident timeline
type IncidentEvent struct {
        GormModel
        IncidentID uint              `json:"incident_id"`
        Incident   *Incident         `json:"incident,omitempty"`
        EventType  IncidentEventType `json:"event_type"`
        Message    string            `json:"message"`
        CreatedBy  *uint             `json:"created_by,omitempty"`
        User       *User             `json:"user,omitempty"`
        Metadata   map[string]interface{} `json:"metadata"`
}

// CreateIncidentRequest represents a request to create an incident
type CreateIncidentRequest struct {
        Title             string             `json:"title"`
        Description       string             `json:"description"`
        Severity          IncidentSeverity   `json:"severity"`
        ServerID          *uint              `json:"server_id,omitempty"`
        ProbeID           *uint              `json:"probe_id,omitempty"`
        Tags              []string           `json:"tags,omitempty"`
        Metadata          map[string]interface{} `json:"metadata,omitempty"`
}

// UpdateIncidentRequest represents a request to update an incident
type UpdateIncidentRequest struct {
        Title       string                 `json:"title,omitempty"`
        Description string                 `json:"description,omitempty"`
        Severity    IncidentSeverity       `json:"severity,omitempty"`
        Status      IncidentStatus         `json:"status,omitempty"`
        Tags        []string               `json:"tags,omitempty"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// IncidentListOptions represents options for listing incidents
type IncidentListOptions struct {
        ListOptions
        Status   string `url:"status,omitempty"`
        Severity string `url:"severity,omitempty"`
        ServerID uint   `url:"server_id,omitempty"`
        ProbeID  uint   `url:"probe_id,omitempty"`
        Sort     string `url:"sort,omitempty"`
}

// IncidentStats represents incident statistics
type IncidentStats struct {
        TotalCount     int            `json:"total_count"`
        ActiveCount    int            `json:"active_count"`
        BySeverity     map[string]int `json:"by_severity"`
        MTTRMinutes    float64        `json:"mttr_minutes"`
        RecentCount    int64          `json:"recent_count"`
        RecentResolved int64          `json:"recent_resolved"`
        RecentMTTR     float64        `json:"recent_mttr"`
}

// =============================================================================
// Unified API Key System
// =============================================================================

// APIKeyType represents the type of API key
type APIKeyType string

const (
        // APIKeyTypeUser represents user-created keys for personal access
        APIKeyTypeUser APIKeyType = "user"
        // APIKeyTypeAdmin represents admin keys with elevated permissions
        APIKeyTypeAdmin APIKeyType = "admin"
        // APIKeyTypeMonitoringAgent represents keys for monitoring agents
        APIKeyTypeMonitoringAgent APIKeyType = "monitoring_agent"
        // APIKeyTypeSystem represents keys for system-to-system communication
        APIKeyTypeSystem APIKeyType = "system"
        // APIKeyTypePublicAgent represents keys for public monitoring agents
        APIKeyTypePublicAgent APIKeyType = "public_agent"
        // APIKeyTypeRegistration represents keys for server registration
        APIKeyTypeRegistration APIKeyType = "registration"
        // APIKeyTypeOrgMonitoring represents organization-level monitoring keys
        APIKeyTypeOrgMonitoring APIKeyType = "org_monitoring"
)

// APIKeyStatus represents the status of an API key
type APIKeyStatus string

const (
        // APIKeyStatusActive indicates the key is active and can be used
        APIKeyStatusActive APIKeyStatus = "active"
        // APIKeyStatusRevoked indicates the key has been revoked
        APIKeyStatusRevoked APIKeyStatus = "revoked"
        // APIKeyStatusExpired indicates the key has expired
        APIKeyStatusExpired APIKeyStatus = "expired"
        // APIKeyStatusPending indicates the key is pending activation
        APIKeyStatusPending APIKeyStatus = "pending"
)

// UnifiedAPIKey represents a unified API key that supports all key types and capabilities
type UnifiedAPIKey struct {
        GormModel

        // Basic identification
        KeyID       string `json:"key_id"`                // Unique identifier for the key
        Name        string `json:"name"`                  // Human-readable name
        Description string `json:"description,omitempty"` // Optional description
        KeyPrefix   string `json:"key_prefix"`            // First few characters for display

        // Key data (only returned on creation for security)
        Key       string `json:"key,omitempty"`        // The actual key (only on creation)
        Secret    string `json:"secret,omitempty"`     // The secret part (only on creation)
        FullToken string `json:"full_token,omitempty"` // Complete token (only on creation)

        // Type and permissions
        Type         APIKeyType `json:"type"`              // Type of API key
        Capabilities []string   `json:"capabilities"`      // Fine-grained permissions
        Scopes       []string   `json:"scopes,omitempty"`  // Legacy scopes for backward compatibility

        // Ownership and organization
        OrganizationID uint          `json:"organization_id"`
        Organization   *Organization `json:"organization,omitempty"`
        UserID         *uint         `json:"user_id,omitempty"`
        User           *User         `json:"user,omitempty"`

        // Monitoring-specific fields (for monitoring agent keys)
        RemoteClusterID    *uint          `json:"remote_cluster_id,omitempty"`
        RemoteCluster      *RemoteCluster `json:"remote_cluster,omitempty"`
        NamespaceName      string         `json:"namespace_name,omitempty"`
        AgentType          string         `json:"agent_type,omitempty"`          // public, private
        RegionCode         string         `json:"region_code,omitempty"`
        AllowedProbeScopes []string       `json:"allowed_probe_scopes,omitempty"`

        // Status and usage tracking
        Status     APIKeyStatus `json:"status"`                  // Current status
        ExpiresAt  *CustomTime  `json:"expires_at,omitempty"`    // Optional expiration
        LastUsedAt *CustomTime  `json:"last_used_at,omitempty"`  // Last usage timestamp
        LastUsedIP string       `json:"last_used_ip,omitempty"`  // Last used IP address
        UsageCount int          `json:"usage_count"`             // Number of times used

        // Security and rate limiting
        RateLimitPerHour int      `json:"rate_limit_per_hour,omitempty"` // Requests per hour limit
        AllowedIPs       []string `json:"allowed_ips,omitempty"`          // IP whitelist

        // Metadata and tagging
        Tags     []string               `json:"tags,omitempty"`     // Tags for organization
        Metadata map[string]interface{} `json:"metadata,omitempty"` // Custom metadata
}

// IsActive returns true if the API key is active and not expired
func (k *UnifiedAPIKey) IsActive() bool <span class="cov4" title="12">{
        if k.Status != APIKeyStatusActive </span><span class="cov2" title="3">{
                return false
        }</span>
        <span class="cov4" title="9">if k.ExpiresAt != nil &amp;&amp; k.ExpiresAt.Before(time.Now()) </span><span class="cov2" title="2">{
                return false
        }</span>
        <span class="cov4" title="7">return true</span>
}

// IsExpired returns true if the API key has expired
func (k *UnifiedAPIKey) IsExpired() bool <span class="cov2" title="3">{
        return k.ExpiresAt != nil &amp;&amp; k.ExpiresAt.Before(time.Now())
}</span>

// IsRevoked returns true if the API key has been revoked
func (k *UnifiedAPIKey) IsRevoked() bool <span class="cov3" title="4">{
        return k.Status == APIKeyStatusRevoked
}</span>

// HasCapability checks if the API key has the specified capability
func (k *UnifiedAPIKey) HasCapability(capability string) bool <span class="cov5" title="24">{
        for _, cap := range k.Capabilities </span><span class="cov5" title="24">{
                if cap == capability || cap == "*" </span><span class="cov4" title="10">{
                        return true
                }</span>
        }
        <span class="cov5" title="14">return false</span>
}

// HasScope checks if the API key has the specified scope (for backward compatibility)
func (k *UnifiedAPIKey) HasScope(scope string) bool <span class="cov3" title="4">{
        for _, s := range k.Scopes </span><span class="cov2" title="3">{
                if s == scope || s == "*" </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}

// IsMonitoringAgent returns true if this is a monitoring agent key
func (k *UnifiedAPIKey) IsMonitoringAgent() bool <span class="cov4" title="7">{
        return k.Type == APIKeyTypeMonitoringAgent || k.Type == APIKeyTypePublicAgent
}</span>

// IsRegistrationKey returns true if this is a registration key
func (k *UnifiedAPIKey) IsRegistrationKey() bool <span class="cov5" title="19">{
        return k.Type == APIKeyTypeRegistration
}</span>

// CanRegisterServers returns true if this key can register servers
func (k *UnifiedAPIKey) CanRegisterServers() bool <span class="cov5" title="16">{
        return k.IsRegistrationKey() || k.HasCapability("servers:register") || k.HasCapability("servers:*") || k.HasCapability("*")
}</span>

// CanAccessOrganization returns true if this key can access the specified organization
func (k *UnifiedAPIKey) CanAccessOrganization(orgID uint) bool <span class="cov3" title="4">{
        return k.OrganizationID == orgID || k.Type == APIKeyTypeSystem || k.Type == APIKeyTypeAdmin
}</span>

// IsPublicAgent returns true if this is a public monitoring agent key
func (k *UnifiedAPIKey) IsPublicAgent() bool <span class="cov3" title="4">{
        return k.Type == APIKeyTypePublicAgent || (k.Type == APIKeyTypeMonitoringAgent &amp;&amp; k.AgentType == "public")
}</span>

// IsPrivateAgent returns true if this is a private monitoring agent key
func (k *UnifiedAPIKey) IsPrivateAgent() bool <span class="cov3" title="4">{
        return k.Type == APIKeyTypeMonitoringAgent &amp;&amp; k.AgentType == "private"
}</span>

// GetAuthenticationMethod returns the preferred authentication method for this key type
func (k *UnifiedAPIKey) GetAuthenticationMethod() string <span class="cov4" title="12">{
        switch k.Type </span>{
        case APIKeyTypeMonitoringAgent, APIKeyTypePublicAgent:<span class="cov2" title="3">
                return "bearer"</span> // Use Bearer token
        case APIKeyTypeRegistration:<span class="cov3" title="5">
                return "headers"</span> // Use X-Registration-Key header
        default:<span class="cov3" title="4">
                return "headers"</span> // Use Access-Key/Access-Secret headers
        }
}

// CreateUnifiedAPIKeyRequest represents a request to create a unified API key
type CreateUnifiedAPIKeyRequest struct {
        Name               string            `json:"name"`
        Description        string            `json:"description,omitempty"`
        Type               APIKeyType        `json:"type"`
        Capabilities       []string          `json:"capabilities,omitempty"`
        OrganizationID     uint              `json:"organization_id,omitempty"`     // Only for admin creation
        ExpiresAt          *CustomTime       `json:"expires_at,omitempty"`
        RateLimitPerHour   int               `json:"rate_limit_per_hour,omitempty"`
        AllowedIPs         []string          `json:"allowed_ips,omitempty"`
        Tags               []string          `json:"tags,omitempty"`
        Metadata           map[string]interface{} `json:"metadata,omitempty"`

        // Monitoring-specific fields
        RemoteClusterID    *uint    `json:"remote_cluster_id,omitempty"`
        NamespaceName      string   `json:"namespace_name,omitempty"`
        AgentType          string   `json:"agent_type,omitempty"`          // public, private
        RegionCode         string   `json:"region_code,omitempty"`
        AllowedProbeScopes []string `json:"allowed_probe_scopes,omitempty"`
}

// CreateUnifiedAPIKeyResponse represents the response when creating a unified API key
type CreateUnifiedAPIKeyResponse struct {
        Key       *UnifiedAPIKey `json:"key"`
        KeyID     string         `json:"key_id"`
        KeyValue  string         `json:"key_value"`         // The actual key
        Secret    string         `json:"secret,omitempty"`  // Secret if using key/secret auth
        FullToken string         `json:"full_token"`        // Complete token for bearer auth
}

// UpdateUnifiedAPIKeyRequest represents a request to update a unified API key
type UpdateUnifiedAPIKeyRequest struct {
        Name             *string           `json:"name,omitempty"`
        Description      *string           `json:"description,omitempty"`
        Capabilities     []string          `json:"capabilities,omitempty"`
        Status           APIKeyStatus      `json:"status,omitempty"`
        ExpiresAt        *CustomTime       `json:"expires_at,omitempty"`
        RateLimitPerHour *int              `json:"rate_limit_per_hour,omitempty"`
        AllowedIPs       []string          `json:"allowed_ips,omitempty"`
        Tags             []string          `json:"tags,omitempty"`
        Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// ListUnifiedAPIKeysOptions represents options for listing unified API keys
type ListUnifiedAPIKeysOptions struct {
        ListOptions
        Type         APIKeyType   `url:"type,omitempty"`
        Status       APIKeyStatus `url:"status,omitempty"`
        UserID       uint         `url:"user_id,omitempty"`
        AgentType    string       `url:"agent_type,omitempty"`
        RegionCode   string       `url:"region_code,omitempty"`
        Namespace    string       `url:"namespace,omitempty"`
        Capability   string       `url:"capability,omitempty"`
        Tag          string       `url:"tag,omitempty"`
}

// Backward compatibility type alias
// This allows existing code to continue working while gradually migrating to UnifiedAPIKey
type APIKey = UnifiedAPIKey

// Legacy constructor functions for backward compatibility
// These create UnifiedAPIKey instances with appropriate types

// NewUserAPIKey creates a new user API key request
func NewUserAPIKey(name, description string, capabilities []string) *CreateUnifiedAPIKeyRequest <span class="cov2" title="2">{
        return &amp;CreateUnifiedAPIKeyRequest{
                Name:         name,
                Description:  description,
                Type:         APIKeyTypeUser,
                Capabilities: capabilities,
        }
}</span>

// NewAdminAPIKey creates a new admin API key request
func NewAdminAPIKey(name, description string, capabilities []string, orgID uint) *CreateUnifiedAPIKeyRequest <span class="cov1" title="1">{
        return &amp;CreateUnifiedAPIKeyRequest{
                Name:           name,
                Description:    description,
                Type:           APIKeyTypeAdmin,
                Capabilities:   capabilities,
                OrganizationID: orgID,
        }
}</span>

// NewMonitoringAgentKey creates a new monitoring agent key request
func NewMonitoringAgentKey(name, description, namespace, agentType, regionCode string, allowedScopes []string) *CreateUnifiedAPIKeyRequest <span class="cov2" title="2">{
        return &amp;CreateUnifiedAPIKeyRequest{
                Name:               name,
                Description:        description,
                Type:               APIKeyTypeMonitoringAgent,
                NamespaceName:      namespace,
                AgentType:          agentType,
                RegionCode:         regionCode,
                AllowedProbeScopes: allowedScopes,
                Capabilities:       []string{"monitoring:execute", "probes:execute"},
        }
}</span>

// NewRegistrationKey creates a new registration key request
func NewRegistrationKey(name, description string, orgID uint) *CreateUnifiedAPIKeyRequest <span class="cov2" title="2">{
        return &amp;CreateUnifiedAPIKeyRequest{
                Name:           name,
                Description:    description,
                Type:           APIKeyTypeRegistration,
                OrganizationID: orgID,
                Capabilities:   []string{"servers:register", "servers:update"},
        }
}</span>

// NewServerDetailsUpdateRequest creates a new server details update request with hardware information
func NewServerDetailsUpdateRequest() *ServerDetailsUpdateRequest <span class="cov3" title="4">{
        return &amp;ServerDetailsUpdateRequest{}
}</span>

// WithBasicInfo sets basic server information
func (r *ServerDetailsUpdateRequest) WithBasicInfo(hostname, mainIP, environment, location, classification string) *ServerDetailsUpdateRequest <span class="cov3" title="4">{
        r.Hostname = hostname
        r.MainIP = mainIP
        r.Environment = environment
        r.Location = location
        r.Classification = classification
        return r
}</span>

// WithSystemInfo sets system information
func (r *ServerDetailsUpdateRequest) WithSystemInfo(os, osVersion, osArch, serialNumber, macAddress string) *ServerDetailsUpdateRequest <span class="cov3" title="4">{
        r.OS = os
        r.OSVersion = osVersion
        r.OSArch = osArch
        r.SerialNumber = serialNumber
        r.MacAddress = macAddress
        return r
}</span>

// WithLegacyHardware sets legacy hardware fields for backward compatibility
func (r *ServerDetailsUpdateRequest) WithLegacyHardware(cpuModel string, cpuCount, cpuCores int, memoryTotal, storageTotal uint64) *ServerDetailsUpdateRequest <span class="cov2" title="3">{
        r.CPUModel = cpuModel
        r.CPUCount = cpuCount
        r.CPUCores = cpuCores
        r.MemoryTotal = memoryTotal
        r.StorageTotal = storageTotal
        return r
}</span>

// WithHardwareDetails sets detailed hardware information
func (r *ServerDetailsUpdateRequest) WithHardwareDetails(hardware *HardwareDetails) *ServerDetailsUpdateRequest <span class="cov2" title="2">{
        r.Hardware = hardware
        return r
}</span>

// WithCPUs adds CPU information to hardware details
func (r *ServerDetailsUpdateRequest) WithCPUs(cpus []ServerCPUInfo) *ServerDetailsUpdateRequest <span class="cov3" title="4">{
        if r.Hardware == nil </span><span class="cov3" title="4">{
                r.Hardware = &amp;HardwareDetails{}
        }</span>
        <span class="cov3" title="4">r.Hardware.CPU = cpus
        return r</span>
}

// WithMemory adds memory information to hardware details
func (r *ServerDetailsUpdateRequest) WithMemory(memory *ServerMemoryInfo) *ServerDetailsUpdateRequest <span class="cov2" title="3">{
        if r.Hardware == nil </span><span class="cov1" title="1">{
                r.Hardware = &amp;HardwareDetails{}
        }</span>
        <span class="cov2" title="3">r.Hardware.Memory = memory
        return r</span>
}

// WithNetworkInterfaces adds network interface information to hardware details
func (r *ServerDetailsUpdateRequest) WithNetworkInterfaces(interfaces []ServerNetworkInterfaceInfo) *ServerDetailsUpdateRequest <span class="cov2" title="2">{
        if r.Hardware == nil </span><span class="cov1" title="1">{
                r.Hardware = &amp;HardwareDetails{}
        }</span>
        <span class="cov2" title="2">r.Hardware.Network = interfaces
        return r</span>
}

// WithDisks adds disk information to hardware details
func (r *ServerDetailsUpdateRequest) WithDisks(disks []ServerDiskInfo) *ServerDetailsUpdateRequest <span class="cov3" title="5">{
        if r.Hardware == nil </span><span class="cov2" title="2">{
                r.Hardware = &amp;HardwareDetails{}
        }</span>
        <span class="cov3" title="5">r.Hardware.Disks = disks
        return r</span>
}

// HasHardwareDetails returns true if the request contains enhanced hardware details
func (r *ServerDetailsUpdateRequest) HasHardwareDetails() bool <span class="cov4" title="7">{
        return r.Hardware != nil
}</span>

// HasDisks returns true if the request contains disk information
func (r *ServerDetailsUpdateRequest) HasDisks() bool <span class="cov4" title="8">{
        return r.Hardware != nil &amp;&amp; len(r.Hardware.Disks) &gt; 0
}</span>

// Standard capability constants
const (
        // Server capabilities
        CapabilityServersRead     = "servers:read"
        CapabilityServersWrite    = "servers:write"
        CapabilityServersRegister = "servers:register"
        CapabilityServersDelete   = "servers:delete"
        CapabilityServersAll      = "servers:*"

        // Monitoring capabilities
        CapabilityMonitoringRead    = "monitoring:read"
        CapabilityMonitoringWrite   = "monitoring:write"
        CapabilityMonitoringExecute = "monitoring:execute"
        CapabilityMonitoringAll     = "monitoring:*"

        // Probe capabilities
        CapabilityProbesRead    = "probes:read"
        CapabilityProbesWrite   = "probes:write"
        CapabilityProbesExecute = "probes:execute"
        CapabilityProbesAll     = "probes:*"

        // Metrics capabilities
        CapabilityMetricsRead   = "metrics:read"
        CapabilityMetricsWrite  = "metrics:write"
        CapabilityMetricsSubmit = "metrics:submit"
        CapabilityMetricsAll    = "metrics:*"

        // Organization capabilities
        CapabilityOrganizationRead  = "organization:read"
        CapabilityOrganizationWrite = "organization:write"
        CapabilityOrganizationAll   = "organization:*"

        // Admin capabilities
        CapabilityAdminRead  = "admin:read"
        CapabilityAdminWrite = "admin:write"
        CapabilityAdminAll   = "admin:*"

        // Wildcard capability (full access)
        CapabilityAll = "*"
)

// AgentVersion represents an agent version
type AgentVersion struct {
        GormModel
        Version             string                 `json:"version"`
        Environment         string                 `json:"environment,omitempty"`
        Platform            string                 `json:"platform"`
        Architectures       []string               `json:"architectures,omitempty"`
        DownloadURLs        map[string]string      `json:"download_urls,omitempty"`
        UpdaterURLs         map[string]string      `json:"updater_urls,omitempty"`
        ReleaseNotes        string                 `json:"release_notes,omitempty"`
        MinimumAPIVersion   string                 `json:"minimum_api_version,omitempty"`
        ReleaseDate         *CustomTime            `json:"release_date,omitempty"`
        IsStable            bool                   `json:"is_stable"`
        IsPrerelease        bool                   `json:"is_prerelease"`
        Metadata            map[string]interface{} `json:"metadata,omitempty"`
}

// AgentVersionRequest represents a request to register a new agent version
type AgentVersionRequest struct {
        Version           string                 `json:"version"`
        Environment       string                 `json:"environment,omitempty"`
        Platform          string                 `json:"platform"`
        Architectures     []string               `json:"architectures,omitempty"`
        DownloadURLs      map[string]string      `json:"download_urls,omitempty"`
        UpdaterURLs       map[string]string      `json:"updater_urls,omitempty"`
        ReleaseNotes      string                 `json:"release_notes,omitempty"`
        MinimumAPIVersion string                 `json:"minimum_api_version,omitempty"`
        IsStable          *bool                  `json:"is_stable,omitempty"`
        IsPrerelease      *bool                  `json:"is_prerelease,omitempty"`
        Metadata          map[string]interface{} `json:"metadata,omitempty"`
}

// AgentBinaryRequest represents a request to add a binary for an agent version
type AgentBinaryRequest struct {
        Platform     string `json:"platform"`
        Architecture string `json:"architecture"`
        DownloadURL  string `json:"download_url"`
        FileHash     string `json:"file_hash"`
}

// OrganizationUsageMetrics represents the current usage snapshot for billing purposes
// This stores the most recent usage metrics for each organization
type OrganizationUsageMetrics struct {
        ID               uint64          `json:"id"`
        OrganizationID   uint            `json:"organization_id"`
        ActiveAgentCount int             `json:"active_agent_count"`
        TotalAgentCount  int             `json:"total_agent_count"`
        FeaturesEnabled  interface{}     `json:"features_enabled"` // JSON object
        RetentionDays    int             `json:"retention_days"`
        StorageUsedBytes int64           `json:"storage_used_bytes"`
        StorageUsedGB    float64         `json:"storage_used_gb"`
        CollectedAt      *CustomTime     `json:"collected_at"`
        CreatedAt        *CustomTime     `json:"created_at"`
        UpdatedAt        *CustomTime     `json:"updated_at"`
}

// UsageMetricsHistory stores historical usage metrics for billing and analytics
// This is a TimescaleDB hypertable optimized for time-series data
type UsageMetricsHistory struct {
        ID               uint64      `json:"id"`
        OrganizationID   uint        `json:"organization_id"`
        ActiveAgentCount int         `json:"active_agent_count"`
        TotalAgentCount  int         `json:"total_agent_count"`
        FeaturesEnabled  interface{} `json:"features_enabled"` // JSON object
        RetentionDays    int         `json:"retention_days"`
        StorageUsedGB    float64     `json:"storage_used_gb"`
        CollectedAt      *CustomTime `json:"collected_at"`
        CreatedAt        *CustomTime `json:"created_at"`
}

// UsageSummary represents aggregated usage statistics over a time period
type UsageSummary struct {
        OrganizationID        uint            `json:"organization_id"`
        StartDate             *CustomTime     `json:"start_date"`
        EndDate               *CustomTime     `json:"end_date"`
        AverageAgentCount     float64         `json:"average_agent_count"`
        MaxAgentCount         int             `json:"max_agent_count"`
        AverageStorageGB      float64         `json:"average_storage_gb"`
        MaxStorageGB          float64         `json:"max_storage_gb"`
        FeaturesEnabled       map[string]bool `json:"features_enabled"`
        RetentionDays         int             `json:"retention_days"`
        TotalDataPoints       int             `json:"total_data_points"`
        BillingRecommendation string          `json:"billing_recommendation,omitempty"`
}

// OrganizationUsageOverview represents a summary of usage across all organizations (admin)
type OrganizationUsageOverview struct {
        TotalOrganizations int                          `json:"total_organizations"`
        TotalActiveAgents  int                          `json:"total_active_agents"`
        TotalStorageGB     float64                      `json:"total_storage_gb"`
        Organizations      []OrganizationUsageMetrics   `json:"organizations"`
}

// UsageMetricsRecordRequest represents the request body for recording usage metrics
// Used by org-management-controller to submit usage metrics to the API
type UsageMetricsRecordRequest struct {
        OrganizationID   uint            `json:"organization_id"`
        ActiveAgentCount int             `json:"active_agent_count"`
        TotalAgentCount  int             `json:"total_agent_count"`
        FeaturesEnabled  map[string]bool `json:"features_enabled"`
        RetentionDays    int             `json:"retention_days"`
        StorageUsedBytes int64           `json:"storage_used_bytes"`
        CollectedAt      time.Time       `json:"collected_at"`
}

// AgentCountsResponse represents agent count statistics for billing
type AgentCountsResponse struct {
        OrganizationID uint `json:"organization_id"`
        ActiveCount    int  `json:"active_count"`
        TotalCount     int  `json:"total_count"`
}

// StorageUsageResponse represents storage usage statistics for billing
type StorageUsageResponse struct {
        OrganizationID uint    `json:"organization_id"`
        StorageBytes   int64   `json:"storage_bytes"`
        StorageGB      float64 `json:"storage_gb"`
}

// ============================================================================
// Tag Management
// ============================================================================

// Tag represents a tag in the system
type Tag struct {
        ID             uint       `json:"id"`
        OrganizationID uint       `json:"organization_id"`
        Namespace      string     `json:"namespace"`
        Key            string     `json:"key"`
        Value          string     `json:"value"`
        Source         string     `json:"source"`
        Description    string     `json:"description,omitempty"`
        CreatedByID    *uint      `json:"created_by_id,omitempty"`
        CreatedByEmail string     `json:"created_by_email,omitempty"`
        CreatedAt      CustomTime `json:"created_at"`
        UpdatedAt      CustomTime `json:"updated_at"`
        ServerCount    int64      `json:"server_count"`
}

// TagCreateRequest represents the request structure for creating a tag
type TagCreateRequest struct {
        Namespace   string `json:"namespace"`
        Key         string `json:"key"`
        Value       string `json:"value"`
        Description string `json:"description,omitempty"`
}

// TagAssignRequest represents the request structure for assigning tags to a server
type TagAssignRequest struct {
        TagIDs []uint `json:"tag_ids"`
}

// TagAssignmentResult represents the result of a tag assignment operation
type TagAssignmentResult struct {
        Assigned        int `json:"assigned"`
        AlreadyAssigned int `json:"already_assigned"`
        Total           int `json:"total"`
}

// ServerTag represents a tag assigned to a server
type ServerTag struct {
        ID              uint       `json:"id"`
        TagID           uint       `json:"tag_id"`
        Namespace       string     `json:"namespace"`
        Key             string     `json:"key"`
        Value           string     `json:"value"`
        Source          string     `json:"source"`
        Description     string     `json:"description,omitempty"`
        AssignedAt      CustomTime `json:"assigned_at"`
        AssignedByEmail string     `json:"assigned_by_email,omitempty"`
        ConfidenceScore *float64   `json:"confidence_score,omitempty"`
}

// TagListOptions represents filtering and pagination options for listing tags
type TagListOptions struct {
        Namespace string // Filter by namespace
        Source    string // Filter by source (automatic, manual, inherited)
        Key       string // Filter by key pattern (partial match)
        Page      int    // Page number (default: 1)
        Limit     int    // Items per page (default: 50)
}

// ToQuery converts TagListOptions to a query parameter map
func (o *TagListOptions) ToQuery() map[string]string <span class="cov2" title="2">{
        query := make(map[string]string)

        if o.Namespace != "" </span><span class="cov2" title="2">{
                query["namespace"] = o.Namespace
        }</span>
        <span class="cov2" title="2">if o.Source != "" </span><span class="cov2" title="2">{
                query["source"] = o.Source
        }</span>
        <span class="cov2" title="2">if o.Key != "" </span><span class="cov1" title="1">{
                query["key"] = o.Key
        }</span>
        <span class="cov2" title="2">if o.Page &gt; 0 </span><span class="cov2" title="2">{
                query["page"] = fmt.Sprintf("%d", o.Page)
        }</span>
        <span class="cov2" title="2">if o.Limit &gt; 0 </span><span class="cov2" title="2">{
                query["limit"] = fmt.Sprintf("%d", o.Limit)
        }</span>

        <span class="cov2" title="2">return query</span>
}

// TagNamespace represents a tag namespace definition
type TagNamespace struct {
        ID               uint       `json:"id"`
        Namespace        string     `json:"namespace"`
        ParentNamespace  string     `json:"parent_namespace,omitempty"`
        Type             string     `json:"type"`
        Description      string     `json:"description"`
        KeyPattern       string     `json:"key_pattern,omitempty"`
        ValuePattern     string     `json:"value_pattern,omitempty"`
        AllowedValues    []string   `json:"allowed_values,omitempty"`
        RequiresApproval bool       `json:"requires_approval"`
        IsActive         bool       `json:"is_active"`
        CreatedByID      *uint      `json:"created_by_id,omitempty"`
        CreatedByEmail   string     `json:"created_by_email,omitempty"`
        CreatedAt        CustomTime `json:"created_at"`
        UpdatedAt        CustomTime `json:"updated_at"`
}

// TagNamespaceCreateRequest represents the request structure for creating a namespace
type TagNamespaceCreateRequest struct {
        Namespace        string   `json:"namespace"`
        ParentNamespace  string   `json:"parent_namespace,omitempty"`
        Type             string   `json:"type,omitempty"`
        Description      string   `json:"description,omitempty"`
        KeyPattern       string   `json:"key_pattern,omitempty"`
        ValuePattern     string   `json:"value_pattern,omitempty"`
        AllowedValues    []string `json:"allowed_values,omitempty"`
        RequiresApproval bool     `json:"requires_approval,omitempty"`
}

// TagNamespacePermissionRequest represents the request structure for setting namespace permissions
type TagNamespacePermissionRequest struct {
        UserID     *uint  `json:"user_id,omitempty"`
        RoleName   string `json:"role_name,omitempty"`
        CanCreate  bool   `json:"can_create"`
        CanRead    bool   `json:"can_read"`
        CanUpdate  bool   `json:"can_update"`
        CanDelete  bool   `json:"can_delete"`
        CanApprove bool   `json:"can_approve"`
}

// TagNamespaceListOptions represents filtering options for listing namespaces
type TagNamespaceListOptions struct {
        Type      string // Filter by namespace type
        Parent    string // Filter by parent namespace
        Active    *bool  // Filter by active status (nil = all, true = active only, false = inactive only)
        Search    string // Search in namespace name and description
        Hierarchy bool   // Return hierarchical structure
}

// ToQuery converts TagNamespaceListOptions to a query parameter map
func (o *TagNamespaceListOptions) ToQuery() map[string]string <span class="cov2" title="3">{
        query := make(map[string]string)

        if o.Type != "" </span><span class="cov1" title="1">{
                query["type"] = o.Type
        }</span>
        <span class="cov2" title="3">if o.Parent != "" </span><span class="cov1" title="1">{
                query["parent"] = o.Parent
        }</span>
        <span class="cov2" title="3">if o.Active != nil </span><span class="cov2" title="2">{
                if *o.Active </span><span class="cov1" title="1">{
                        query["active"] = "true"
                }</span> else<span class="cov1" title="1"> {
                        query["active"] = "false"
                }</span>
        }
        <span class="cov2" title="3">if o.Search != "" </span><span class="cov1" title="1">{
                query["search"] = o.Search
        }</span>
        <span class="cov2" title="3">if o.Hierarchy </span><span class="cov0" title="0">{
                query["hierarchy"] = "true"
        }</span>

        <span class="cov2" title="3">return query</span>
}

// ============================================================================
// Tag Inheritance Models
// ============================================================================

// Type aliases for inheritance enums
type InheritanceSource string
type InheritanceTarget string

// TagInheritanceRule represents an inheritance rule for automatic tag propagation
type TagInheritanceRule struct {
        ID             uint              `json:"id"`
        OrganizationID uint              `json:"organization_id"`
        Name           string            `json:"name"`
        Description    string            `json:"description,omitempty"`
        SourceType     InheritanceSource `json:"source_type"`
        TargetType     InheritanceTarget `json:"target_type"`
        Namespace      string            `json:"namespace,omitempty"`
        KeyPattern     string            `json:"key_pattern,omitempty"`
        ValuePattern   string            `json:"value_pattern,omitempty"`
        Conditions     string            `json:"conditions,omitempty"`
        Enabled        bool              `json:"enabled"`
        Priority       int               `json:"priority"`
        CreatedBy      *UserInfo         `json:"created_by,omitempty"`
        LastRunAt      *string           `json:"last_run_at,omitempty"`
        LastRunStatus  string            `json:"last_run_status,omitempty"`
        ProcessedCount int               `json:"processed_count"`
        CreatedAt      CustomTime        `json:"created_at"`
        UpdatedAt      CustomTime        `json:"updated_at"`
}

// TagInheritanceRuleCreateRequest represents a request to create an inheritance rule
type TagInheritanceRuleCreateRequest struct {
        Name         string            `json:"name"`
        Description  string            `json:"description,omitempty"`
        SourceType   InheritanceSource `json:"source_type"`
        TargetType   InheritanceTarget `json:"target_type"`
        Namespace    string            `json:"namespace,omitempty"`
        KeyPattern   string            `json:"key_pattern,omitempty"`
        ValuePattern string            `json:"value_pattern,omitempty"`
        Conditions   string            `json:"conditions,omitempty"`
        Enabled      bool              `json:"enabled"`
        Priority     int               `json:"priority"`
}

// OrganizationTag represents a tag set at the organization level
type OrganizationTag struct {
        ID             uint       `json:"id"`
        OrganizationID uint       `json:"organization_id"`
        Tag            TagInfo    `json:"tag"`
        InheritToAll   bool       `json:"inherit_to_all"`
        InheritRules   string     `json:"inherit_rules,omitempty"`
        CreatedBy      *UserInfo  `json:"created_by,omitempty"`
        CreatedAt      CustomTime `json:"created_at"`
        UpdatedAt      CustomTime `json:"updated_at"`
}

// OrganizationTagRequest represents a request to set an organization tag
type OrganizationTagRequest struct {
        TagID        uint   `json:"tag_id"`
        InheritToAll bool   `json:"inherit_to_all"`
        InheritRules string `json:"inherit_rules,omitempty"`
}

// ServerParentRelationship represents a parent-child relationship between servers
type ServerParentRelationship struct {
        ID             uint       `json:"id"`
        OrganizationID uint       `json:"organization_id"`
        ParentServer   ServerInfo `json:"parent_server"`
        ChildServer    ServerInfo `json:"child_server"`
        RelationType   string     `json:"relation_type"`
        InheritTags    bool       `json:"inherit_tags"`
        CreatedBy      *UserInfo  `json:"created_by,omitempty"`
        CreatedAt      CustomTime `json:"created_at"`
        UpdatedAt      CustomTime `json:"updated_at"`
}

// ServerRelationshipRequest represents a request to create a server relationship
type ServerRelationshipRequest struct {
        ParentServerID string `json:"parent_server_id"`
        ChildServerID  string `json:"child_server_id"`
        RelationType   string `json:"relation_type"`
        InheritTags    bool   `json:"inherit_tags"`
}

// TagInfo represents basic tag information
type TagInfo struct {
        ID          uint   `json:"id"`
        Namespace   string `json:"namespace"`
        Key         string `json:"key"`
        Value       string `json:"value"`
        Description string `json:"description,omitempty"`
}

// UserInfo represents basic user information
type UserInfo struct {
        ID    uint   `json:"id"`
        Email string `json:"email"`
}

// ServerInfo represents basic server information
type ServerInfo struct {
        ID         uint   `json:"id"`
        ServerUUID string `json:"server_uuid"`
        Name       string `json:"name"`
}

// OrganizationTagListOptions provides filtering options for organization tags
type OrganizationTagListOptions struct {
        InheritOnly bool
}

func (o *OrganizationTagListOptions) ToQuery() map[string]string <span class="cov0" title="0">{
        query := make(map[string]string)
        if o.InheritOnly </span><span class="cov0" title="0">{
                query["inherit_only"] = "true"
        }</span>
        <span class="cov0" title="0">return query</span>
}

// ServerRelationshipListOptions provides filtering options for server relationships
type ServerRelationshipListOptions struct {
        ServerID     string
        RelationType string
        InheritOnly  bool
}

func (o *ServerRelationshipListOptions) ToQuery() map[string]string <span class="cov0" title="0">{
        query := make(map[string]string)
        if o.ServerID != "" </span><span class="cov0" title="0">{
                query["server_id"] = o.ServerID
        }</span>
        <span class="cov0" title="0">if o.RelationType != "" </span><span class="cov0" title="0">{
                query["relation_type"] = o.RelationType
        }</span>
        <span class="cov0" title="0">if o.InheritOnly </span><span class="cov0" title="0">{
                query["inherit_only"] = "true"
        }</span>
        <span class="cov0" title="0">return query</span>
}

// ============================================================================
// Tag History Models
// ============================================================================

// TagHistoryResponse represents a single tag history entry
type TagHistoryResponse struct {
        ID            string                `json:"id"`
        Action        string                `json:"action"`
        Tag           TagHistoryTag         `json:"tag"`
        PreviousValue *string               `json:"previous_value,omitempty"`
        Timestamp     string                `json:"timestamp"`
        User          *TagHistoryUser       `json:"user,omitempty"`
        Metadata      TagHistoryMetadataRes `json:"metadata"`
}

// TagHistoryTag represents tag information in history response
type TagHistoryTag struct {
        ID        uint    `json:"id,omitempty"`
        Key       string  `json:"key"`
        Value     string  `json:"value"`
        Namespace *string `json:"namespace,omitempty"`
}

// TagHistoryUser represents user information in history response
type TagHistoryUser struct {
        ID    uint   `json:"id"`
        Name  string `json:"name"`
        Email string `json:"email"`
}

// TagHistoryMetadataRes represents metadata in history response
type TagHistoryMetadataRes struct {
        Source     string   `json:"source"`
        Reason     *string  `json:"reason,omitempty"`
        Confidence *float64 `json:"confidence,omitempty"`
}

// TagHistorySummary represents aggregated statistics for tag history
type TagHistorySummary struct {
        TotalChanges       int                 `json:"total_changes"`
        ChangesByAction    map[string]int      `json:"changes_by_action"`
        ChangesByNamespace map[string]int      `json:"changes_by_namespace"`
        MostActiveUsers    []ActiveUser        `json:"most_active_users"`
        RecentActivity     RecentActivityStats `json:"recent_activity"`
}

// ActiveUser represents a user with their change count
type ActiveUser struct {
        UserID      uint   `json:"user_id"`
        Name        string `json:"name"`
        ChangeCount int    `json:"change_count"`
}

// RecentActivityStats represents recent activity statistics
type RecentActivityStats struct {
        Last24h int `json:"last_24h"`
        Last7d  int `json:"last_7d"`
        Last30d int `json:"last_30d"`
}

// TagHistoryQueryParams represents query parameters for filtering tag history
type TagHistoryQueryParams struct {
        Action    string `json:"action,omitempty"`
        Namespace string `json:"namespace,omitempty"`
        Source    string `json:"source,omitempty"`
        TagID     uint   `json:"tag_id,omitempty"`
        StartDate string `json:"start_date,omitempty"`
        EndDate   string `json:"end_date,omitempty"`
        Page      int    `json:"page,omitempty"`
        Limit     int    `json:"limit,omitempty"`
}

func (o *TagHistoryQueryParams) ToQuery() map[string]string <span class="cov2" title="2">{
        query := make(map[string]string)
        if o.Action != "" </span><span class="cov2" title="2">{
                query["action"] = o.Action
        }</span>
        <span class="cov2" title="2">if o.Namespace != "" </span><span class="cov1" title="1">{
                query["namespace"] = o.Namespace
        }</span>
        <span class="cov2" title="2">if o.Source != "" </span><span class="cov1" title="1">{
                query["source"] = o.Source
        }</span>
        <span class="cov2" title="2">if o.TagID &gt; 0 </span><span class="cov1" title="1">{
                query["tag_id"] = fmt.Sprintf("%d", o.TagID)
        }</span>
        <span class="cov2" title="2">if o.StartDate != "" </span><span class="cov1" title="1">{
                query["start_date"] = o.StartDate
        }</span>
        <span class="cov2" title="2">if o.EndDate != "" </span><span class="cov1" title="1">{
                query["end_date"] = o.EndDate
        }</span>
        <span class="cov2" title="2">if o.Page &gt; 0 </span><span class="cov2" title="2">{
                query["page"] = fmt.Sprintf("%d", o.Page)
        }</span>
        <span class="cov2" title="2">if o.Limit &gt; 0 </span><span class="cov2" title="2">{
                query["limit"] = fmt.Sprintf("%d", o.Limit)
        }</span>
        <span class="cov2" title="2">return query</span>
}

// ============================================================================
// Bulk Tag Operation Models
// ============================================================================

// BulkTagCreateRequest represents a request to create multiple tags
type BulkTagCreateRequest struct {
        Tags []BulkTagCreateItem `json:"tags"`
}

// BulkTagCreateItem represents a single tag in bulk create
type BulkTagCreateItem struct {
        Namespace   string `json:"namespace"`
        Key         string `json:"key"`
        Value       string `json:"value"`
        Description string `json:"description,omitempty"`
}

// BulkTagCreateResult represents the result of bulk tag creation
type BulkTagCreateResult struct {
        Created      []Tag    `json:"created"`
        Skipped      []string `json:"skipped"`
        CreatedCount int      `json:"created_count"`
        SkippedCount int      `json:"skipped_count"`
}

// BulkTagAssignRequest represents a request to assign tags to multiple servers
type BulkTagAssignRequest struct {
        ServerIDs []string `json:"server_ids"`
        TagIDs    []uint   `json:"tag_ids"`
}

// BulkTagAssignResult represents the result of bulk tag assignment
type BulkTagAssignResult struct {
        Assigned int `json:"assigned"`
        Skipped  int `json:"skipped"`
        Total    int `json:"total"`
}

// BulkGroupAssignRequest represents a request to assign servers to multiple groups
type BulkGroupAssignRequest struct {
        ServerIDs []string `json:"server_ids"`
        GroupIDs  []uint   `json:"group_ids"`
}

// BulkGroupAssignResult represents the result of bulk group assignment
type BulkGroupAssignResult struct {
        Assigned int `json:"assigned"`
        Skipped  int `json:"skipped"`
        Total    int `json:"total"`
}

// ============================================================================
// Tag Detection Rule Models
// ============================================================================

// TagDetectionRule represents a rule for automatic tag assignment
type TagDetectionRule struct {
        ID             uint            `json:"id"`
        OrganizationID uint            `json:"organization_id"`
        Name           string          `json:"name"`
        Description    string          `json:"description"`
        Namespace      string          `json:"namespace"`
        TagKey         string          `json:"tag_key"`
        TagValue       string          `json:"tag_value"`
        Conditions     json.RawMessage `json:"conditions"`
        Priority       int             `json:"priority"`
        Confidence     float64         `json:"confidence"`
        Enabled        bool            `json:"enabled"`
        CreatedByID    *uint           `json:"created_by_id,omitempty"`
        CreatedByEmail string          `json:"created_by_email,omitempty"`
        CreatedAt      string          `json:"created_at"`
        UpdatedAt      string          `json:"updated_at"`
}

// TagDetectionRuleListOptions provides filtering options for listing tag detection rules
type TagDetectionRuleListOptions struct {
        Enabled   *bool
        Namespace string
        Page      int
        Limit     int
}

func (o *TagDetectionRuleListOptions) ToQuery() map[string]string <span class="cov2" title="2">{
        query := make(map[string]string)
        if o.Enabled != nil </span><span class="cov2" title="2">{
                if *o.Enabled </span><span class="cov2" title="2">{
                        query["enabled"] = "true"
                }</span> else<span class="cov0" title="0"> {
                        query["enabled"] = "false"
                }</span>
        }
        <span class="cov2" title="2">if o.Namespace != "" </span><span class="cov1" title="1">{
                query["namespace"] = o.Namespace
        }</span>
        <span class="cov2" title="2">if o.Page &gt; 0 </span><span class="cov2" title="2">{
                query["page"] = fmt.Sprintf("%d", o.Page)
        }</span>
        <span class="cov2" title="2">if o.Limit &gt; 0 </span><span class="cov2" title="2">{
                query["limit"] = fmt.Sprintf("%d", o.Limit)
        }</span>
        <span class="cov2" title="2">return query</span>
}

// DefaultRulesCreateResult represents the result of creating default rules
type DefaultRulesCreateResult struct {
        CreatedCount int `json:"created_count"`
}

// EvaluateRulesRequest represents a request to evaluate tag detection rules
type EvaluateRulesRequest struct {
        ServerIDs  []string `json:"server_ids,omitempty"`
        AllServers bool     `json:"all_servers,omitempty"`
}

// EvaluateRulesResult represents the result of rule evaluation
type EvaluateRulesResult struct {
        ProcessingCount int `json:"processing_count"`
}

// ============================================================================
// Analytics Models
// ============================================================================

// AI Analytics Models

// AICapabilities represents available AI analytics features
type AICapabilities struct {
        AnomalyDetection    bool     `json:"anomaly_detection"`
        PredictiveAnalytics bool     `json:"predictive_analytics"`
        RootCauseAnalysis   bool     `json:"root_cause_analysis"`
        CapacityPlanning    bool     `json:"capacity_planning"`
        AvailableModels     []string `json:"available_models"`
        Status              string   `json:"status"` // "operational", "degraded", "unavailable"
}

// AIAnalysisRequest represents a request for AI-powered metric analysis
type AIAnalysisRequest struct {
        ServerUUIDs  []string               `json:"server_uuids,omitempty"`
        MetricTypes  []string               `json:"metric_types,omitempty"` // ["cpu", "memory", "disk", "network"]
        TimeRange    TimeRange              `json:"time_range"`
        AnalysisType string                 `json:"analysis_type"` // "anomaly", "prediction", "root_cause", "capacity"
        Context      map[string]interface{} `json:"context,omitempty"`
}

// AIAnalysisResult represents the result of AI-powered analysis
type AIAnalysisResult struct {
        AnalysisID  string                 `json:"analysis_id"`
        Timestamp   CustomTime             `json:"timestamp"`
        Insights    []AIInsight            `json:"insights"`
        Anomalies   []AIAnomaly            `json:"anomalies,omitempty"`
        Predictions []AIPrediction         `json:"predictions,omitempty"`
        Confidence  float64                `json:"confidence"` // 0.0 to 1.0
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// AIInsight represents an AI-generated insight
type AIInsight struct {
        Type        string   `json:"type"` // "recommendation", "warning", "info"
        Title       string   `json:"title"`
        Description string   `json:"description"`
        Severity    string   `json:"severity"` // "low", "medium", "high", "critical"
        Confidence  float64  `json:"confidence"`
        Actions     []string `json:"actions,omitempty"`
}

// AIAnomaly represents a detected anomaly
type AIAnomaly struct {
        MetricType    string     `json:"metric_type"`
        ServerUUID    string     `json:"server_uuid"`
        DetectedAt    CustomTime `json:"detected_at"`
        Severity      string     `json:"severity"`
        ExpectedValue float64    `json:"expected_value"`
        ActualValue   float64    `json:"actual_value"`
        Deviation     float64    `json:"deviation"`
        Description   string     `json:"description"`
}

// AIPrediction represents a prediction for future metrics
type AIPrediction struct {
        MetricType  string     `json:"metric_type"`
        ServerUUID  string     `json:"server_uuid,omitempty"`
        PredictedAt CustomTime `json:"predicted_at"`
        Value       float64    `json:"value"`
        Confidence  float64    `json:"confidence"`
        UpperBound  float64    `json:"upper_bound,omitempty"`
        LowerBound  float64    `json:"lower_bound,omitempty"`
}

// AIServiceStatus represents the health status of AI services
type AIServiceStatus struct {
        Status          string     `json:"status"` // "operational", "degraded", "unavailable"
        LastCheck       CustomTime `json:"last_check"`
        ModelsAvailable int        `json:"models_available"`
        QueueLength     int        `json:"queue_length"`
        AverageLatency  float64    `json:"average_latency_ms"`
        Uptime          float64    `json:"uptime_percentage"`
}

// Hardware Analytics Models

// HardwareTrends represents historical hardware trends for a server
type HardwareTrends struct {
        ServerUUID   string                 `json:"server_uuid"`
        StartTime    CustomTime             `json:"start_time"`
        EndTime      CustomTime             `json:"end_time"`
        CPUTrend     MetricTrendData        `json:"cpu_trend,omitempty"`
        MemoryTrend  MetricTrendData        `json:"memory_trend,omitempty"`
        DiskTrend    MetricTrendData        `json:"disk_trend,omitempty"`
        NetworkTrend MetricTrendData        `json:"network_trend,omitempty"`
        Summary      map[string]interface{} `json:"summary,omitempty"`
}

// MetricTrendData represents trend data for a specific metric
type MetricTrendData struct {
        Average    float64      `json:"average"`
        Minimum    float64      `json:"minimum"`
        Maximum    float64      `json:"maximum"`
        TrendLine  []TrendPoint `json:"trend_line"`
        Growth     float64      `json:"growth_percentage"`
        Volatility float64      `json:"volatility"`
}

// TrendPoint represents a single point in a trend line
type TrendPoint struct {
        Timestamp CustomTime `json:"timestamp"`
        Value     float64    `json:"value"`
}

// HardwareHealth represents current hardware health score and diagnostics
type HardwareHealth struct {
        ServerUUID      string             `json:"server_uuid"`
        OverallScore    int                `json:"overall_score"` // 0-100
        LastCheck       CustomTime         `json:"last_check"`
        ComponentScores ComponentHealthMap `json:"component_scores"`
        Issues          []HealthIssue      `json:"issues,omitempty"`
        Recommendations []string           `json:"recommendations,omitempty"`
}

// ComponentHealthMap represents health scores for individual components
type ComponentHealthMap struct {
        CPU     int `json:"cpu"`
        Memory  int `json:"memory"`
        Disk    int `json:"disk"`
        Network int `json:"network"`
}

// HealthIssue represents a detected health issue
type HealthIssue struct {
        Component   string `json:"component"`
        Severity    string `json:"severity"` // "info", "warning", "critical"
        Description string `json:"description"`
        Impact      string `json:"impact,omitempty"`
}

// HardwarePrediction represents predictive analytics for hardware failures
type HardwarePrediction struct {
        ServerUUID           string                `json:"server_uuid"`
        PredictionHorizon    int                   `json:"prediction_horizon_days"`
        FailureProbability   float64               `json:"failure_probability"`
        ComponentPredictions []ComponentPrediction `json:"component_predictions"`
        RecommendedActions   []string              `json:"recommended_actions"`
        ConfidenceLevel      float64               `json:"confidence_level"`
}

// ComponentPrediction represents failure prediction for a specific component
type ComponentPrediction struct {
        Component          string     `json:"component"`
        FailureProbability float64    `json:"failure_probability"`
        EstimatedFailure   CustomTime `json:"estimated_failure,omitempty"`
        WarningLevel       string     `json:"warning_level"` // "none", "low", "medium", "high"
}

// Fleet Analytics Models

// FleetOverview represents organization-wide fleet statistics
type FleetOverview struct {
        TotalServers        int                 `json:"total_servers"`
        ActiveServers       int                 `json:"active_servers"`
        InactiveServers     int                 `json:"inactive_servers"`
        HealthDistribution  HealthDistribution  `json:"health_distribution"`
        ResourceUtilization ResourceUtilization `json:"resource_utilization"`
        TopIssues           []FleetIssue        `json:"top_issues,omitempty"`
        LastUpdated         CustomTime          `json:"last_updated"`
}

// HealthDistribution represents distribution of server health scores
type HealthDistribution struct {
        Healthy  int `json:"healthy"`  // Score &gt;= 80
        Warning  int `json:"warning"`  // Score 50-79
        Critical int `json:"critical"` // Score &lt; 50
        Unknown  int `json:"unknown"`  // No data
}

// ResourceUtilization represents aggregate resource utilization
type ResourceUtilization struct {
        AverageCPU    float64 `json:"average_cpu"`
        AverageMemory float64 `json:"average_memory"`
        AverageDisk   float64 `json:"average_disk"`
        TotalStorage  float64 `json:"total_storage_gb"`
}

// FleetIssue represents a common issue across the fleet
type FleetIssue struct {
        Type            string `json:"type"`
        Description     string `json:"description"`
        Severity        string `json:"severity"`
        AffectedServers int    `json:"affected_servers"`
}

// OrganizationDashboard represents comprehensive dashboard data
type OrganizationDashboard struct {
        FleetOverview            FleetOverview     `json:"fleet_overview"`
        RecentAlerts             []DashboardAlert  `json:"recent_alerts"`
        TrendingMetrics          []TrendingMetric  `json:"trending_metrics"`
        CapacityForecasts        []CapacityForecast `json:"capacity_forecasts,omitempty"`
        TopPerformingServers     []ServerSummary   `json:"top_performing_servers,omitempty"`
        BottomPerformingServers  []ServerSummary   `json:"bottom_performing_servers,omitempty"`
        LastUpdated              CustomTime        `json:"last_updated"`
}

// DashboardAlert represents an alert summary for the dashboard
type DashboardAlert struct {
        AlertID    uint       `json:"alert_id"`
        Severity   string     `json:"severity"`
        Title      string     `json:"title"`
        ServerUUID string     `json:"server_uuid,omitempty"`
        ServerName string     `json:"server_name,omitempty"`
        Timestamp  CustomTime `json:"timestamp"`
}

// TrendingMetric represents a metric with trend information
type TrendingMetric struct {
        MetricType string  `json:"metric_type"`
        Value      float64 `json:"value"`
        Change     float64 `json:"change_percentage"`
        Trend      string  `json:"trend"` // "up", "down", "stable"
}

// CapacityForecast represents capacity planning forecast
type CapacityForecast struct {
        ResourceType         string     `json:"resource_type"` // "cpu", "memory", "storage"
        CurrentUtilization   float64    `json:"current_utilization"`
        ForecastedDate       CustomTime `json:"forecasted_exhaustion_date,omitempty"`
        DaysUntilExhaustion  int        `json:"days_until_exhaustion"`
        Recommendation       string     `json:"recommendation"`
}

// ServerSummary represents a summary of server performance
type ServerSummary struct {
        UUID        string  `json:"uuid"`
        Hostname    string  `json:"hostname"`
        HealthScore int     `json:"health_score"`
        CPUUsage    float64 `json:"cpu_usage"`
        MemoryUsage float64 `json:"memory_usage"`
}

// Advanced Analytics Models

// CorrelationAnalysisRequest represents a request for correlation analysis
type CorrelationAnalysisRequest struct {
        ServerUUIDs []string  `json:"server_uuids,omitempty"`
        MetricTypes []string  `json:"metric_types"` // Metrics to correlate
        TimeRange   TimeRange `json:"time_range"`
        Method      string    `json:"method,omitempty"` // "pearson", "spearman", "kendall"
}

// CorrelationResult represents the result of correlation analysis
type CorrelationResult struct {
        Correlations     []MetricCorrelation `json:"correlations"`
        Matrix           [][]float64         `json:"matrix,omitempty"` // Correlation matrix
        MetricLabels     []string            `json:"metric_labels"`
        SignificantPairs []CorrelationPair   `json:"significant_pairs,omitempty"`
        AnalyzedAt       CustomTime          `json:"analyzed_at"`
}

// MetricCorrelation represents correlation between two metrics
type MetricCorrelation struct {
        Metric1     string  `json:"metric1"`
        Metric2     string  `json:"metric2"`
        Coefficient float64 `json:"coefficient"` // -1.0 to 1.0
        Strength    string  `json:"strength"`    // "weak", "moderate", "strong"
        PValue      float64 `json:"p_value,omitempty"`
}

// CorrelationPair represents a significant correlation pair
type CorrelationPair struct {
        Metrics      []string `json:"metrics"`
        Relationship string   `json:"relationship"` // "positive", "negative"
        Insight      string   `json:"insight,omitempty"`
}

// DependencyGraph represents infrastructure dependency relationships
type DependencyGraph struct {
        Nodes         []DependencyNode `json:"nodes"`
        Edges         []DependencyEdge `json:"edges"`
        CriticalPaths [][]string       `json:"critical_paths,omitempty"`
        GeneratedAt   CustomTime       `json:"generated_at"`
}

// DependencyNode represents a node in the dependency graph
type DependencyNode struct {
        ID       string                 `json:"id"`
        Type     string                 `json:"type"` // "server", "service", "database", "load_balancer"
        Name     string                 `json:"name"`
        Status   string                 `json:"status"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// DependencyEdge represents an edge between nodes
type DependencyEdge struct {
        From   string `json:"from"`
        To     string `json:"to"`
        Type   string `json:"type"`          // "depends_on", "provides_to", "connected_to"
        Weight int    `json:"weight,omitempty"` // Importance/traffic weight
}

// ============================================================================
// Machine Learning Models
// ============================================================================

// TagSuggestion represents an ML-generated tag suggestion for a server
type TagSuggestion struct {
        ID           uint                   `json:"id"`
        ServerID     uint                   `json:"server_id"`
        ServerUUID   string                 `json:"server_uuid"`
        PredictionID string                 `json:"prediction_id"`
        TagKey       string                 `json:"tag_key"`
        TagValue     string                 `json:"tag_value"`
        Namespace    string                 `json:"namespace,omitempty"`
        Confidence   float64                `json:"confidence"`    // 0.0 to 1.0
        Reason       string                 `json:"reason"`        // Explanation for suggestion
        Applied      bool                   `json:"applied"`       // Whether suggestion was applied
        Rejected     bool                   `json:"rejected"`      // Whether suggestion was rejected
        Feedback     string                 `json:"feedback,omitempty"` // User feedback if rejected
        CreatedAt    CustomTime             `json:"created_at"`
        UpdatedAt    CustomTime             `json:"updated_at"`
        Metadata     map[string]interface{} `json:"metadata,omitempty"` // Additional context
}

// TagPrediction represents an ML prediction for tag assignment
type TagPrediction struct {
        TagKey     string                 `json:"tag_key"`
        TagValue   string                 `json:"tag_value"`
        Confidence float64                `json:"confidence"`
        Reasoning  string                 `json:"reasoning"`
        Features   map[string]interface{} `json:"features,omitempty"` // Features used for prediction
}

// GroupSuggestion represents an ML-generated server grouping suggestion
type GroupSuggestion struct {
        ID              uint       `json:"id"`
        OrganizationID  uint       `json:"organization_id"`
        GroupName       string     `json:"group_name"`
        Description     string     `json:"description"`
        ServerIDs       []uint     `json:"server_ids"`
        ServerUUIDs     []string   `json:"server_uuids"`
        Confidence      float64    `json:"confidence"`      // 0.0 to 1.0
        Reason          string     `json:"reason"`          // Why these servers should be grouped
        Criteria        []string   `json:"criteria"`        // Criteria used (location, tags, specs, etc.)
        Accepted        bool       `json:"accepted"`        // Whether suggestion was accepted
        Rejected        bool       `json:"rejected"`        // Whether suggestion was rejected
        CreatedGroupID  *uint      `json:"created_group_id,omitempty"` // ID of created group if accepted
        CreatedAt       CustomTime `json:"created_at"`
        UpdatedAt       CustomTime `json:"updated_at"`
        EstimatedBenefit string    `json:"estimated_benefit,omitempty"` // Estimated benefits of grouping
}

// MLModel represents a machine learning model configuration and status
type MLModel struct {
        ID              uint       `json:"id"`
        Name            string     `json:"name"`
        ModelType       string     `json:"model_type"`       // "tag_prediction", "group_suggestion", etc.
        Version         string     `json:"version"`
        Status          string     `json:"status"`           // "active", "inactive", "training", "deprecated"
        Enabled         bool       `json:"enabled"`
        Accuracy        float64    `json:"accuracy,omitempty"` // Model accuracy (0.0 to 1.0)
        Precision       float64    `json:"precision,omitempty"`
        Recall          float64    `json:"recall,omitempty"`
        F1Score         float64    `json:"f1_score,omitempty"`
        TrainedAt       *CustomTime `json:"trained_at,omitempty"`
        TrainingDataSize int        `json:"training_data_size,omitempty"`
        CreatedAt       CustomTime `json:"created_at"`
        UpdatedAt       CustomTime `json:"updated_at"`
        Description     string     `json:"description,omitempty"`
        Metadata        map[string]interface{} `json:"metadata,omitempty"`
}

// ModelPerformance represents detailed performance metrics for an ML model
type ModelPerformance struct {
        ModelID          uint                   `json:"model_id,omitempty"`
        ModelType        string                 `json:"model_type,omitempty"`
        Accuracy         float64                `json:"accuracy"`
        Precision        float64                `json:"precision"`
        Recall           float64                `json:"recall"`
        F1Score          float64                `json:"f1_score"`
        ConfusionMatrix  map[string]int         `json:"confusion_matrix,omitempty"`
        PredictionsCount int                    `json:"predictions_count,omitempty"`
        CorrectCount     int                    `json:"correct_count,omitempty"`
        IncorrectCount   int                    `json:"incorrect_count,omitempty"`
        AverageConfidence float64               `json:"average_confidence,omitempty"`
        EvaluatedAt      *CustomTime            `json:"evaluated_at,omitempty"`
        Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// TrainingJob represents a machine learning model training job
type TrainingJob struct {
        ID              uint       `json:"id"`
        ModelID         uint       `json:"model_id"`
        ModelType       string     `json:"model_type"`
        Status          string     `json:"status"`         // "pending", "running", "completed", "failed"
        Progress        int        `json:"progress"`       // 0-100
        TrainingDataSize int       `json:"training_data_size,omitempty"`
        ValidationDataSize int     `json:"validation_data_size,omitempty"`
        StartedAt       *CustomTime `json:"started_at,omitempty"`
        CompletedAt     *CustomTime `json:"completed_at,omitempty"`
        Duration        int        `json:"duration,omitempty"`  // Duration in seconds
        ErrorMessage    string     `json:"error_message,omitempty"`
        Metrics         *ModelPerformance `json:"metrics,omitempty"` // Performance metrics after training
        CreatedAt       CustomTime `json:"created_at"`
        UpdatedAt       CustomTime `json:"updated_at"`
        Parameters      map[string]interface{} `json:"parameters,omitempty"` // Training parameters
        Logs            []string   `json:"logs,omitempty"` // Training logs
}

// TrainingJobStatus represents the current status of a training job
type TrainingJobStatus struct {
        JobID       uint       `json:"job_id"`
        Status      string     `json:"status"`
        Progress    int        `json:"progress"`
        Message     string     `json:"message,omitempty"`
        UpdatedAt   CustomTime `json:"updated_at"`
}

// ============================================================================
// Virtual Machine Models
// ============================================================================

// VirtualMachine represents a virtual machine instance
type VirtualMachine struct {
        ID             uint       `json:"id"`
        OrganizationID uint       `json:"organization_id"`
        Name           string     `json:"name"`
        Description    string     `json:"description,omitempty"`
        Status         string     `json:"status"` // "running", "stopped", "paused", "error"

        // Resource specifications
        CPUCores   int    `json:"cpu_cores"`
        MemoryMB   int    `json:"memory_mb"`
        StorageGB  int    `json:"storage_gb"`

        // Network configuration
        IPAddress      string   `json:"ip_address,omitempty"`
        MACAddress     string   `json:"mac_address,omitempty"`

        // Host information
        HostServerID   *uint  `json:"host_server_id,omitempty"`
        HostServerUUID string `json:"host_server_uuid,omitempty"`

        // Operating system
        OSType    string `json:"os_type,omitempty"`    // "linux", "windows", "other"
        OSVersion string `json:"os_version,omitempty"`

        // Lifecycle timestamps
        CreatedAt   CustomTime  `json:"created_at"`
        UpdatedAt   CustomTime  `json:"updated_at"`
        StartedAt   *CustomTime `json:"started_at,omitempty"`
        StoppedAt   *CustomTime `json:"stopped_at,omitempty"`

        // Metadata
        Tags     []string               `json:"tags,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// VMConfiguration represents virtual machine configuration for creation/updates
type VMConfiguration struct {
        Name           string                 `json:"name"`
        Description    string                 `json:"description,omitempty"`

        // Required resources
        CPUCores   int `json:"cpu_cores"`
        MemoryMB   int `json:"memory_mb"`
        StorageGB  int `json:"storage_gb"`

        // Optional configuration
        OSType         string   `json:"os_type,omitempty"`
        OSVersion      string   `json:"os_version,omitempty"`
        HostServerID   *uint    `json:"host_server_id,omitempty"`
        HostServerUUID string   `json:"host_server_uuid,omitempty"`

        // Network settings
        NetworkConfig map[string]interface{} `json:"network_config,omitempty"`

        // Additional settings
        Tags     []string               `json:"tags,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// VMStatus represents the current status of a virtual machine
type VMStatus struct {
        ID        uint       `json:"id"`
        VMID      uint       `json:"vm_id"`
        Status    string     `json:"status"`    // "running", "stopped", "paused", "error"
        Health    string     `json:"health"`    // "healthy", "degraded", "unhealthy"

        // Resource usage
        CPUUsagePercent    float64 `json:"cpu_usage_percent,omitempty"`
        MemoryUsageMB      int     `json:"memory_usage_mb,omitempty"`
        MemoryUsagePercent float64 `json:"memory_usage_percent,omitempty"`
        DiskUsageGB        int     `json:"disk_usage_gb,omitempty"`
        DiskUsagePercent   float64 `json:"disk_usage_percent,omitempty"`

        // Network statistics
        NetworkInMBps  float64 `json:"network_in_mbps,omitempty"`
        NetworkOutMBps float64 `json:"network_out_mbps,omitempty"`

        // Status details
        Message   string     `json:"message,omitempty"`
        UpdatedAt CustomTime `json:"updated_at"`
}

// VMOperation represents an asynchronous virtual machine operation
type VMOperation struct {
        ID           uint       `json:"id"`
        VMID         uint       `json:"vm_id"`
        OperationType string    `json:"operation_type"` // "start", "stop", "restart", "delete", "create"
        Status       string     `json:"status"`         // "pending", "in_progress", "completed", "failed"
        Progress     int        `json:"progress"`       // 0-100

        // Operation details
        RequestedBy string     `json:"requested_by,omitempty"`
        Message     string     `json:"message,omitempty"`
        ErrorDetails string    `json:"error_details,omitempty"`

        // Timestamps
        CreatedAt   CustomTime  `json:"created_at"`
        StartedAt   *CustomTime `json:"started_at,omitempty"`
        CompletedAt *CustomTime `json:"completed_at,omitempty"`

        // Result
        Result map[string]interface{} `json:"result,omitempty"`
}

// Report represents a generated report
type Report struct {
        ID             uint                   `json:"id"`
        OrganizationID uint                   `json:"organization_id"`
        Name           string                 `json:"name"`
        Description    string                 `json:"description,omitempty"`
        ReportType     string                 `json:"report_type"` // "usage", "performance", "compliance", "billing"
        Status         string                 `json:"status"`      // "pending", "generating", "completed", "failed"
        Format         string                 `json:"format"`      // "pdf", "csv", "json", "html"
        FileURL        string                 `json:"file_url,omitempty"`
        FilePath       string                 `json:"file_path,omitempty"`
        FileSize       int64                  `json:"file_size,omitempty"`
        Configuration  *ReportConfiguration   `json:"configuration,omitempty"`
        CreatedBy      uint                   `json:"created_by,omitempty"`
        CreatedAt      CustomTime             `json:"created_at"`
        StartedAt      *CustomTime            `json:"started_at,omitempty"`
        CompletedAt    *CustomTime            `json:"completed_at,omitempty"`
        ExpiresAt      *CustomTime            `json:"expires_at,omitempty"`
        ErrorMessage   string                 `json:"error_message,omitempty"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// ReportConfiguration defines report generation parameters
type ReportConfiguration struct {
        ReportType   string                 `json:"report_type"` // "usage", "performance", "compliance", "billing"
        Format       string                 `json:"format"`      // "pdf", "csv", "json", "html"
        Name         string                 `json:"name,omitempty"`
        Description  string                 `json:"description,omitempty"`
        TimeRange    *ReportTimeRange       `json:"time_range,omitempty"`
        Filters      *ReportFilter          `json:"filters,omitempty"`
        Parameters   map[string]interface{} `json:"parameters,omitempty"`
        IncludeSections []string            `json:"include_sections,omitempty"`
        Delivery     *ReportDeliveryOptions `json:"delivery,omitempty"`
}

// ReportTimeRange defines the time period for report data
type ReportTimeRange struct {
        StartDate string `json:"start_date"` // ISO 8601 format
        EndDate   string `json:"end_date"`   // ISO 8601 format
        Preset    string `json:"preset,omitempty"` // "last_7_days", "last_30_days", "last_month", "last_quarter", "ytd"
}

// ReportFilter defines filtering criteria for report data
type ReportFilter struct {
        ServerIDs      []uint   `json:"server_ids,omitempty"`
        ServerUUIDs    []string `json:"server_uuids,omitempty"`
        ServerTags     []string `json:"server_tags,omitempty"`
        Locations      []string `json:"locations,omitempty"`
        Environments   []string `json:"environments,omitempty"`
        MetricTypes    []string `json:"metric_types,omitempty"`
        AlertTypes     []string `json:"alert_types,omitempty"`
        Severity       []string `json:"severity,omitempty"`
        IncludeInactive bool    `json:"include_inactive,omitempty"`
}

// ReportDeliveryOptions defines how reports should be delivered
type ReportDeliveryOptions struct {
        EmailRecipients []string `json:"email_recipients,omitempty"`
        EmailSubject    string   `json:"email_subject,omitempty"`
        EmailBody       string   `json:"email_body,omitempty"`
        WebhookURL      string   `json:"webhook_url,omitempty"`
        AutoDelete      bool     `json:"auto_delete,omitempty"`
        RetentionDays   int      `json:"retention_days,omitempty"`
}

// ReportSchedule represents a scheduled report
type ReportSchedule struct {
        ID             uint                   `json:"id"`
        OrganizationID uint                   `json:"organization_id"`
        Name           string                 `json:"name"`
        Description    string                 `json:"description,omitempty"`
        Configuration  *ReportConfiguration   `json:"configuration"`
        Schedule       string                 `json:"schedule"` // Cron expression
        Enabled        bool                   `json:"enabled"`
        NextRunAt      *CustomTime            `json:"next_run_at,omitempty"`
        LastRunAt      *CustomTime            `json:"last_run_at,omitempty"`
        LastReportID   *uint                  `json:"last_report_id,omitempty"`
        CreatedBy      uint                   `json:"created_by,omitempty"`
        CreatedAt      CustomTime             `json:"created_at"`
        UpdatedAt      CustomTime             `json:"updated_at"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// ReportStatus represents the current status of a report generation process
type ReportStatus struct {
        ReportID   uint    `json:"report_id"`
        Status     string  `json:"status"` // "pending", "generating", "completed", "failed"
        Progress   int     `json:"progress"` // 0-100
        Message    string  `json:"message,omitempty"`
        Error      string  `json:"error,omitempty"`
        EstimatedCompletionTime *CustomTime `json:"estimated_completion_time,omitempty"`
}

// ServerGroup represents a logical group of servers
type ServerGroup struct {
        ID             uint                   `json:"id"`
        OrganizationID uint                   `json:"organization_id"`
        Name           string                 `json:"name"`
        Description    string                 `json:"description,omitempty"`
        ServerCount    int                    `json:"server_count"`
        Tags           []string               `json:"tags,omitempty"`
        CreatedBy      uint                   `json:"created_by,omitempty"`
        CreatedAt      CustomTime             `json:"created_at"`
        UpdatedAt      CustomTime             `json:"updated_at"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// ServerGroupMembership represents a server's membership in a group
type ServerGroupMembership struct {
        GroupID      uint       `json:"group_id"`
        GroupName    string     `json:"group_name,omitempty"`
        ServerID     uint       `json:"server_id"`
        ServerUUID   string     `json:"server_uuid"`
        ServerName   string     `json:"server_name,omitempty"`
        ServerStatus string     `json:"server_status,omitempty"`
        AddedAt      CustomTime `json:"added_at"`
        AddedBy      uint       `json:"added_by,omitempty"`
}

// SearchResult represents a server search result with relevance scoring
type SearchResult struct {
        ServerID       uint                   `json:"server_id"`
        ServerUUID     string                 `json:"server_uuid"`
        ServerName     string                 `json:"server_name"`
        Hostname       string                 `json:"hostname,omitempty"`
        OrganizationID uint                   `json:"organization_id"`
        Location       string                 `json:"location,omitempty"`
        Environment    string                 `json:"environment,omitempty"`
        Classification string                 `json:"classification,omitempty"`
        Status         string                 `json:"status"`
        IPAddresses    []string               `json:"ip_addresses,omitempty"`
        Tags           []string               `json:"tags,omitempty"`
        RelevanceScore float64                `json:"relevance_score"`
        MatchedFields  []string               `json:"matched_fields,omitempty"`
        LastSeenAt     *CustomTime            `json:"last_seen_at,omitempty"`
        CreatedAt      CustomTime             `json:"created_at"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// TagSearchResult represents a tag search result with usage information
type TagSearchResult struct {
        TagID          uint                   `json:"tag_id"`
        TagName        string                 `json:"tag_name"`
        TagType        string                 `json:"tag_type"`        // "manual", "auto", "system"
        Scope          string                 `json:"scope"`           // "organization", "user", "server"
        Description    string                 `json:"description,omitempty"`
        Color          string                 `json:"color,omitempty"`
        UsageCount     int                    `json:"usage_count"`     // Number of resources using this tag
        ServerCount    int                    `json:"server_count"`    // Number of servers with this tag
        RelevanceScore float64                `json:"relevance_score"`
        MatchedFields  []string               `json:"matched_fields,omitempty"`
        CreatedAt      CustomTime             `json:"created_at"`
        UpdatedAt      CustomTime             `json:"updated_at"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// TagStatistics represents comprehensive statistics about tag usage
type TagStatistics struct {
        TotalTags       int                    `json:"total_tags"`
        ManualTags      int                    `json:"manual_tags"`
        AutoTags        int                    `json:"auto_tags"`
        SystemTags      int                    `json:"system_tags"`
        TagsByScope     map[string]int         `json:"tags_by_scope"`     // Breakdown by scope
        MostUsedTags    []TagUsageStats        `json:"most_used_tags"`    // Top 10 most used tags
        RecentlyCreated []TagSearchResult      `json:"recently_created"`  // Recently created tags
        UnusedTags      int                    `json:"unused_tags"`       // Tags with no usage
        AveragePerServer float64               `json:"average_per_server"`
        Metadata        map[string]interface{} `json:"metadata,omitempty"`
}

// TagUsageStats represents usage statistics for a specific tag
type TagUsageStats struct {
        TagID       uint       `json:"tag_id"`
        TagName     string     `json:"tag_name"`
        TagType     string     `json:"tag_type"`
        UsageCount  int        `json:"usage_count"`
        ServerCount int        `json:"server_count"`
        LastUsedAt  CustomTime `json:"last_used_at"`
}

// ============================================================================
// Audit Models
// ============================================================================

// AuditLog represents a single audit log entry tracking system activity
type AuditLog struct {
        ID               uint                   `json:"id"`
        OrganizationID   uint                   `json:"organization_id"`
        UserID           *uint                  `json:"user_id,omitempty"`
        UserEmail        string                 `json:"user_email,omitempty"`
        UserName         string                 `json:"user_name,omitempty"`
        Action           string                 `json:"action"`           // create, update, delete, login, logout, etc.
        ResourceType     string                 `json:"resource_type"`    // server, user, organization, alert, etc.
        ResourceID       string                 `json:"resource_id,omitempty"`
        ResourceName     string                 `json:"resource_name,omitempty"`
        Description      string                 `json:"description"`
        IPAddress        string                 `json:"ip_address,omitempty"`
        UserAgent        string                 `json:"user_agent,omitempty"`
        Severity         string                 `json:"severity"`         // info, warning, critical
        Status           string                 `json:"status"`           // success, failure, pending
        Changes          map[string]interface{} `json:"changes,omitempty"`          // Before/after values
        RequestID        string                 `json:"request_id,omitempty"`
        SessionID        string                 `json:"session_id,omitempty"`
        Location         string                 `json:"location,omitempty"`         // Geographic location
        DeviceType       string                 `json:"device_type,omitempty"`      // desktop, mobile, tablet
        ErrorMessage     string                 `json:"error_message,omitempty"`
        DurationMs       int                    `json:"duration_ms,omitempty"`      // Operation duration
        ComplianceFlags  []string               `json:"compliance_flags,omitempty"` // GDPR, HIPAA, SOC2, etc.
        CreatedAt        CustomTime             `json:"created_at"`
        Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// AuditStatistics represents comprehensive audit activity statistics
type AuditStatistics struct {
        TotalLogs           int                    `json:"total_logs"`
        TotalUsers          int                    `json:"total_users"`            // Unique users with activity
        TotalActions        int                    `json:"total_actions"`          // Distinct action types
        ActionBreakdown     map[string]int         `json:"action_breakdown"`       // Count by action type
        ResourceBreakdown   map[string]int         `json:"resource_breakdown"`     // Count by resource type
        SeverityBreakdown   map[string]int         `json:"severity_breakdown"`     // Count by severity
        StatusBreakdown     map[string]int         `json:"status_breakdown"`       // Count by status
        TopUsers            []AuditUserActivity    `json:"top_users"`              // Most active users
        TopActions          []AuditActionCount     `json:"top_actions"`            // Most common actions
        TopResources        []AuditResourceCount   `json:"top_resources"`          // Most accessed resources
        FailedAttempts      int                    `json:"failed_attempts"`        // Failed operations
        CriticalEvents      int                    `json:"critical_events"`        // Critical severity events
        ComplianceBreakdown map[string]int         `json:"compliance_breakdown"`   // Count by compliance flag
        AverageDurationMs   float64                `json:"average_duration_ms"`    // Average operation duration
        TimeRange           AuditTimeRange         `json:"time_range"`             // Statistics time range
        Metadata            map[string]interface{} `json:"metadata,omitempty"`
}

// AuditUserActivity represents audit activity for a specific user
type AuditUserActivity struct {
        UserID          uint       `json:"user_id"`
        UserEmail       string     `json:"user_email"`
        UserName        string     `json:"user_name,omitempty"`
        ActionCount     int        `json:"action_count"`
        FailedAttempts  int        `json:"failed_attempts"`
        LastActivity    CustomTime `json:"last_activity"`
        TopActions      []string   `json:"top_actions,omitempty"`
}

// AuditActionCount represents count of a specific action type
type AuditActionCount struct {
        Action      string `json:"action"`
        Count       int    `json:"count"`
        SuccessRate float64 `json:"success_rate"` // Percentage of successful operations
}

// AuditResourceCount represents access count for a specific resource
type AuditResourceCount struct {
        ResourceType string `json:"resource_type"`
        ResourceID   string `json:"resource_id,omitempty"`
        ResourceName string `json:"resource_name,omitempty"`
        AccessCount  int    `json:"access_count"`
}

// AuditTimeRange represents the time range for audit statistics
type AuditTimeRange struct {
        StartDate  CustomTime `json:"start_date"`
        EndDate    CustomTime `json:"end_date"`
        DurationMs int64      `json:"duration_ms"` // Range duration in milliseconds
}

// ============================================================================
// Task Models
// ============================================================================

// Task represents a background task or scheduled job
type Task struct {
        ID               uint                   `json:"id"`
        OrganizationID   uint                   `json:"organization_id"`
        Name             string                 `json:"name"`
        Type             string                 `json:"type"`             // report_generation, data_export, cleanup, notification, etc.
        Status           string                 `json:"status"`           // pending, running, completed, failed, cancelled
        Priority         string                 `json:"priority"`         // low, normal, high, critical
        Parameters       map[string]interface{} `json:"parameters,omitempty"`
        Result           map[string]interface{} `json:"result,omitempty"` // Result data for completed tasks
        ErrorMessage     string                 `json:"error_message,omitempty"`
        Progress         int                    `json:"progress"`          // 0-100 percentage
        Schedule         string                 `json:"schedule,omitempty"` // Cron expression for recurring tasks
        ScheduledAt      *CustomTime            `json:"scheduled_at,omitempty"`
        StartedAt        *CustomTime            `json:"started_at,omitempty"`
        CompletedAt      *CustomTime            `json:"completed_at,omitempty"`
        ExecutionCount   int                    `json:"execution_count"`    // Number of times executed
        LastExecutionID  *uint                  `json:"last_execution_id,omitempty"`
        NextExecutionAt  *CustomTime            `json:"next_execution_at,omitempty"` // For recurring tasks
        MaxRetries       int                    `json:"max_retries"`
        CurrentRetry     int                    `json:"current_retry"`
        TimeoutSeconds   int                    `json:"timeout_seconds,omitempty"`
        CreatedBy        uint                   `json:"created_by,omitempty"`
        CreatedAt        CustomTime             `json:"created_at"`
        UpdatedAt        CustomTime             `json:"updated_at"`
        Metadata         map[string]interface{} `json:"metadata,omitempty"`
}

// TaskConfiguration represents parameters for creating a new task
type TaskConfiguration struct {
        Name           string                 `json:"name"`
        Type           string                 `json:"type"`
        Priority       string                 `json:"priority,omitempty"`        // Default: normal
        Parameters     map[string]interface{} `json:"parameters,omitempty"`
        Schedule       string                 `json:"schedule,omitempty"`        // Cron expression
        ScheduledAt    *CustomTime            `json:"scheduled_at,omitempty"`    // One-time scheduled task
        MaxRetries     int                    `json:"max_retries,omitempty"`     // Default: 3
        TimeoutSeconds int                    `json:"timeout_seconds,omitempty"` // Default: 300
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// TaskExecution represents a single execution of a task
type TaskExecution struct {
        ID             uint                   `json:"id"`
        TaskID         uint                   `json:"task_id"`
        Status         string                 `json:"status"`        // running, completed, failed
        Progress       int                    `json:"progress"`      // 0-100 percentage
        Result         map[string]interface{} `json:"result,omitempty"`
        ErrorMessage   string                 `json:"error_message,omitempty"`
        StartedAt      CustomTime             `json:"started_at"`
        CompletedAt    *CustomTime            `json:"completed_at,omitempty"`
        DurationMs     int                    `json:"duration_ms,omitempty"`
        RetryCount     int                    `json:"retry_count"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
}

// TaskStatistics represents aggregated statistics about task execution
type TaskStatistics struct {
        TotalTasks          int                  `json:"total_tasks"`
        PendingTasks        int                  `json:"pending_tasks"`
        RunningTasks        int                  `json:"running_tasks"`
        CompletedTasks      int                  `json:"completed_tasks"`
        FailedTasks         int                  `json:"failed_tasks"`
        CancelledTasks      int                  `json:"cancelled_tasks"`
        TasksByType         map[string]int       `json:"tasks_by_type"`
        TasksByPriority     map[string]int       `json:"tasks_by_priority"`
        AverageDurationMs   float64              `json:"average_duration_ms"`
        SuccessRate         float64              `json:"success_rate"`          // Percentage
        TotalExecutions     int                  `json:"total_executions"`
        FailedExecutions    int                  `json:"failed_executions"`
        AverageRetries      float64              `json:"average_retries"`
        LongestRunningTask  *TaskSummary         `json:"longest_running_task,omitempty"`
        MostRecentFailure   *TaskSummary         `json:"most_recent_failure,omitempty"`
        Metadata            map[string]interface{} `json:"metadata,omitempty"`
}

// TaskSummary represents a simplified task summary for statistics
type TaskSummary struct {
        ID           uint       `json:"id"`
        Name         string     `json:"name"`
        Type         string     `json:"type"`
        Status       string     `json:"status"`
        DurationMs   int        `json:"duration_ms,omitempty"`
        ErrorMessage string     `json:"error_message,omitempty"`
        CreatedAt    CustomTime `json:"created_at"`
}

// ============================================================================
// Notification Models
// ============================================================================

// NotificationRequest represents a request to send a notification
type NotificationRequest struct {
        OrganizationID uint                   `json:"organization_id"`
        ChannelIDs     []uint                 `json:"channel_ids,omitempty"`
        ChannelTypes   []string               `json:"channel_types,omitempty"`
        Subject        string                 `json:"subject"`
        Content        string                 `json:"content"`
        ContentType    string                 `json:"content_type,omitempty"` // "text" or "html"
        Recipients     []string               `json:"recipients,omitempty"`
        Priority       NotificationPriority   `json:"priority,omitempty"`
        Metadata       map[string]interface{} `json:"metadata,omitempty"`
        AlertID        *uint                  `json:"alert_id,omitempty"`
        ProbeID        *uint                  `json:"probe_id,omitempty"`
        ScheduledAt    *CustomTime            `json:"scheduled_at,omitempty"`
        ExpiresAt      *CustomTime            `json:"expires_at,omitempty"`
        MaxRetries     *int                   `json:"max_retries,omitempty"`
        RetryDelay     *int                   `json:"retry_delay_minutes,omitempty"`
}

// BatchNotificationRequest represents a request to send multiple notifications
type BatchNotificationRequest struct {
        Notifications []NotificationRequest `json:"notifications"`
}

// NotificationPriority represents the priority level of a notification
type NotificationPriority string

const (
        NotificationPriorityLow      NotificationPriority = "low"
        NotificationPriorityNormal   NotificationPriority = "normal"
        NotificationPriorityHigh     NotificationPriority = "high"
        NotificationPriorityCritical NotificationPriority = "critical"
)

// String returns the string representation of NotificationPriority
func (np NotificationPriority) String() string <span class="cov3" title="4">{
        return string(np)
}</span>

// NotificationResponse represents the response to a notification request
type NotificationResponse struct {
        ID             uint              `json:"id"`
        OrganizationID uint              `json:"organization_id"`
        Status         string            `json:"status"`
        ChannelsUsed   []ChannelUsageInfo `json:"channels_used"`
        CreatedAt      CustomTime        `json:"created_at"`
        ScheduledAt    *CustomTime       `json:"scheduled_at,omitempty"`
        SentAt         *CustomTime       `json:"sent_at,omitempty"`
        Message        string            `json:"message,omitempty"`
}

// BatchNotificationResponse represents the response to a batch notification request
type BatchNotificationResponse struct {
        TotalRequested int                    `json:"total_requested"`
        TotalAccepted  int                    `json:"total_accepted"`
        TotalRejected  int                    `json:"total_rejected"`
        Results        []NotificationResponse `json:"results"`
        Errors         []string               `json:"errors,omitempty"`
}

// ChannelUsageInfo provides information about how a channel was used for a notification
type ChannelUsageInfo struct {
        ChannelID   uint   `json:"channel_id"`
        ChannelName string `json:"channel_name"`
        ChannelType string `json:"channel_type"`
        Status      string `json:"status"`
        Recipient   string `json:"recipient"`
        Error       string `json:"error,omitempty"`
}

// NotificationStatusRequest represents a request to get notification status
type NotificationStatusRequest struct {
        NotificationIDs []uint `json:"notification_ids"`
}

// NotificationStatusResponse represents the response to a notification status request
type NotificationStatusResponse struct {
        Notifications []NotificationStatusInfo `json:"notifications"`
}

// NotificationStatusInfo provides detailed status information for a notification
type NotificationStatusInfo struct {
        ID              uint                   `json:"id"`
        OrganizationID  uint                   `json:"organization_id"`
        Status          string                 `json:"status"`
        Subject         string                 `json:"subject"`
        CreatedAt       CustomTime             `json:"created_at"`
        ScheduledAt     *CustomTime            `json:"scheduled_at,omitempty"`
        SentAt          *CustomTime            `json:"sent_at,omitempty"`
        DeliveredAt     *CustomTime            `json:"delivered_at,omitempty"`
        FailedAt        *CustomTime            `json:"failed_at,omitempty"`
        RetryCount      int                    `json:"retry_count"`
        NextRetryAt     *CustomTime            `json:"next_retry_at,omitempty"`
        ErrorMessage    string                 `json:"error_message,omitempty"`
        ChannelDelivery []ChannelDeliveryInfo  `json:"channel_delivery"`
}

// ChannelDeliveryInfo provides delivery information for a specific channel
type ChannelDeliveryInfo struct {
        ChannelID      uint        `json:"channel_id"`
        ChannelName    string      `json:"channel_name"`
        ChannelType    string      `json:"channel_type"`
        Status         string      `json:"status"`
        Recipient      string      `json:"recipient"`
        SentAt         *CustomTime `json:"sent_at,omitempty"`
        DeliveredAt    *CustomTime `json:"delivered_at,omitempty"`
        FailedAt       *CustomTime `json:"failed_at,omitempty"`
        RetryCount     int         `json:"retry_count"`
        NextRetryAt    *CustomTime `json:"next_retry_at,omitempty"`
        ErrorMessage   string      `json:"error_message,omitempty"`
        ExternalID     string      `json:"external_id,omitempty"`
        ProviderStatus string      `json:"provider_status,omitempty"`
}

// ============================================================================
// Cluster Models
// ============================================================================

// Cluster represents a remote Kubernetes cluster for deployment and monitoring
type Cluster struct {
        ID            uint         `json:"id"`
        Name          string       `json:"name"`                // Unique cluster name
        APIServerURL  string       `json:"api_server_url"`      // Kubernetes API server URL
        Token         string       `json:"token"`               // Service account token for authentication
        CACert        string       `json:"ca_cert,omitempty"`   // CA certificate for secure connection
        Status        string       `json:"status"`              // online, offline, error, unknown
        LastChecked   *CustomTime  `json:"last_checked,omitempty"`        // Last health check time
        LastConnected *CustomTime  `json:"last_connected,omitempty"`      // Last successful connection time
        ErrorMessage  string       `json:"error_message,omitempty"` // Error details if connection failed
        NodeCount     int          `json:"node_count"`          // Number of nodes in cluster
        PodCount      int          `json:"pod_count"`           // Number of pods running
        IsActive      bool         `json:"is_active"`           // Whether cluster monitoring is active
        CreatedAt     CustomTime   `json:"created_at"`
        UpdatedAt     CustomTime   `json:"updated_at"`
}

// ClusterCreateRequest represents a request to create a new cluster
type ClusterCreateRequest struct {
        Name         string `json:"name"`                   // Unique cluster name (required)
        APIServerURL string `json:"api_server_url"`         // Kubernetes API server URL (required)
        Token        string `json:"token"`                  // Service account token (required)
        CACert       string `json:"ca_cert,omitempty"`      // CA certificate (optional)
        IsActive     *bool  `json:"is_active,omitempty"`    // Enable/disable monitoring (default: true)
}

// ClusterUpdateRequest represents a request to update an existing cluster
type ClusterUpdateRequest struct {
        Name         *string `json:"name,omitempty"`          // Updated cluster name
        APIServerURL *string `json:"api_server_url,omitempty"` // Updated API server URL
        Token        *string `json:"token,omitempty"`         // Updated service account token
        CACert       *string `json:"ca_cert,omitempty"`       // Updated CA certificate
        IsActive     *bool   `json:"is_active,omitempty"`     // Enable/disable monitoring
}

// ClusterStatistics provides aggregate statistics across all monitored clusters
type ClusterStatistics struct {
        TotalClusters      int                  `json:"total_clusters"`       // Total number of clusters
        OnlineClusters     int                  `json:"online_clusters"`      // Clusters currently online
        OfflineClusters    int                  `json:"offline_clusters"`     // Clusters currently offline
        ErrorClusters      int                  `json:"error_clusters"`       // Clusters with errors
        TotalNodes         int                  `json:"total_nodes"`          // Total nodes across all clusters
        TotalPods          int                  `json:"total_pods"`           // Total pods across all clusters
        AverageNodeCount   float64              `json:"average_node_count"`   // Average nodes per cluster
        AveragePodCount    float64              `json:"average_pod_count"`    // Average pods per cluster
        ClustersByStatus   map[string]int       `json:"clusters_by_status"`   // Count grouped by status
        LastCheckTime      CustomTime           `json:"last_check_time"`      // Most recent health check
}

// ============================================================================
// Package/Tier Models
// ============================================================================

// OrganizationPackage represents an organization's subscription package and limits
type OrganizationPackage struct {
        ID                    uint64     `json:"id"`
        OrganizationID        uint       `json:"organization_id"`
        OrganizationUUID      string     `json:"organization_uuid"`
        PackageTier           string     `json:"package_tier"`                // starter, professional, enterprise
        MaxProbes             int        `json:"max_probes"`                  // Maximum number of probes allowed
        MaxRegions            int        `json:"max_regions"`                 // Maximum number of regions for probes
        MinFrequency          int        `json:"min_frequency"`               // Minimum probe check frequency (seconds)
        ProbeFrequencySeconds int        `json:"probe_frequency_seconds"`     // Default probe frequency (seconds)
        MaxAlertChannels      int        `json:"max_alert_channels"`          // Maximum alert notification channels
        MaxStatusPages        int        `json:"max_status_pages"`            // Maximum public status pages
        AllowedProbeTypes     []string   `json:"allowed_probe_types"`         // HTTP, ICMP, TCP, DNS, etc.
        Features              []string   `json:"features"`                    // Enabled features for this package
        SelectedRegions       []string   `json:"selected_regions,omitempty"`  // Regions selected for probes
        Active                bool       `json:"active"`                      // Whether package is currently active
        SubscriptionStatus    string     `json:"subscription_status"`         // active, canceled, past_due, etc.
        CurrentPeriodStart    CustomTime `json:"current_period_start"`        // Billing period start
        CurrentPeriodEnd      CustomTime `json:"current_period_end"`          // Billing period end
        CancelAtPeriodEnd     bool       `json:"cancel_at_period_end"`        // Whether to cancel at period end
        TrialEndsAt           *CustomTime `json:"trial_ends_at,omitempty"`    // Trial expiration date
        CreatedAt             CustomTime `json:"created_at"`
        UpdatedAt             CustomTime `json:"updated_at"`
}

// PackageUpgradeRequest represents a request to upgrade organization package tier
type PackageUpgradeRequest struct {
        NewTier         string                 `json:"new_tier"`                    // Target tier: starter, professional, enterprise
        PaymentMethodID *string                `json:"payment_method_id,omitempty"` // Stripe payment method ID (optional)
        BillingEmail    *string                `json:"billing_email,omitempty"`     // Billing contact email (optional)
        Metadata        map[string]interface{} `json:"metadata,omitempty"`          // Additional upgrade metadata
}

// ProbeConfigValidationRequest represents a request to validate probe configuration against package limits
type ProbeConfigValidationRequest struct {
        ProbeType        string   `json:"probe_type"`                   // HTTP, ICMP, TCP, DNS, etc.
        Frequency        int      `json:"frequency"`                    // Check frequency in seconds
        Regions          []string `json:"regions"`                      // Regions for probe execution
        AdditionalProbes *int     `json:"additional_probes,omitempty"`  // Number of new probes being created (optional)
}

// ProbeConfigValidationResult represents the result of probe configuration validation
type ProbeConfigValidationResult struct {
        Valid              bool     `json:"valid"`                           // Whether configuration is valid
        ProbeTypeAllowed   bool     `json:"probe_type_allowed"`              // Whether probe type is allowed
        FrequencyAllowed   bool     `json:"frequency_allowed"`               // Whether frequency is allowed
        RegionsAllowed     bool     `json:"regions_allowed"`                 // Whether number of regions is allowed
        ProbeCountAllowed  bool     `json:"probe_count_allowed"`             // Whether probe count is within limits
        Violations         []string `json:"violations,omitempty"`            // List of limit violations
        CurrentProbeCount  int      `json:"current_probe_count"`             // Current number of probes
        MaxProbes          int      `json:"max_probes"`                      // Maximum probes allowed
        MinFrequency       int      `json:"min_frequency"`                   // Minimum frequency allowed (seconds)
        MaxRegions         int      `json:"max_regions"`                     // Maximum regions allowed
        AllowedProbeTypes  []string `json:"allowed_probe_types,omitempty"`   // List of allowed probe types
        UpgradeSuggestion  string   `json:"upgrade_suggestion,omitempty"`    // Suggested tier for meeting requirements
}

// ============================================================
// Quota History Types
// ============================================================

// QuotaUsageRecordRequest represents a batch of quota usage records to store
type QuotaUsageRecordRequest struct {
        Records []QuotaUsageRecord `json:"records"`
}

// QuotaUsageRecord represents a single quota usage data point
type QuotaUsageRecord struct {
        OrganizationID uint      `json:"organization_id"`
        ResourceType   string    `json:"resource_type"` // cpu, memory, storage, pods, services, configmaps, secrets, persistentvolumeclaims
        UsedAmount     int64     `json:"used_amount"`
        HardLimit      int64     `json:"hard_limit"`
        CollectedAt    time.Time `json:"collected_at"`
}

// QuotaUsageHistory represents a historical quota usage record
type QuotaUsageHistory struct {
        ID                 uint64    `json:"id"`
        OrganizationID     uint      `json:"organization_id"`
        ResourceType       string    `json:"resource_type"`
        UsedAmount         int64     `json:"used_amount"`
        HardLimit          int64     `json:"hard_limit"`
        UtilizationPercent float64   `json:"utilization_percent"`
        CollectedAt        time.Time `json:"collected_at"`
        CreatedAt          time.Time `json:"created_at"`
}

// AverageUtilizationResponse represents average utilization statistics
type AverageUtilizationResponse struct {
        OrganizationID     uint    `json:"organization_id"`
        ResourceType       string  `json:"resource_type"`
        AverageUtilization float64 `json:"average_utilization"`
        AverageUsedAmount  float64 `json:"average_used_amount"`
        AverageHardLimit   float64 `json:"average_hard_limit"`
        StartDate          string  `json:"start_date"`
        EndDate            string  `json:"end_date"`
        SampleCount        int     `json:"sample_count"`
}

// DailyAggregateResponse represents daily aggregated quota statistics
type DailyAggregateResponse struct {
        Date               string  `json:"date"`
        AverageUtilization float64 `json:"average_utilization"`
        MaxUtilization     float64 `json:"max_utilization"`
        MinUtilization     float64 `json:"min_utilization"`
        AverageUsedAmount  float64 `json:"average_used_amount"`
        SampleCount        int     `json:"sample_count"`
}

// ResourceSummaryResponse represents summary statistics for a single resource type
type ResourceSummaryResponse struct {
        ResourceType       string  `json:"resource_type"`
        CurrentUtilization float64 `json:"current_utilization"`
        AverageUtilization float64 `json:"average_utilization"`
        PeakUtilization    float64 `json:"peak_utilization"`
        CurrentUsedAmount  int64   `json:"current_used_amount"`
        CurrentHardLimit   int64   `json:"current_hard_limit"`
        SampleCount        int     `json:"sample_count"`
}

// UsageTrendResponse represents trend analysis results
type UsageTrendResponse struct {
        OrganizationID uint    `json:"organization_id"`
        ResourceType   string  `json:"resource_type"`
        TrendSlope     float64 `json:"trend_slope"`
        TrendDirection string  `json:"trend_direction"` // increasing, decreasing, stable
        CurrentValue   float64 `json:"current_value"`
        PredictedValue float64 `json:"predicted_value"`
        DaysAnalyzed   int     `json:"days_analyzed"`
        SampleCount    int     `json:"sample_count"`
        StartDate      string  `json:"start_date"`
        EndDate        string  `json:"end_date"`
}

// UsagePattern represents a detected usage pattern
type UsagePattern struct {
        PatternType      string  `json:"pattern_type"` // high_utilization, rapid_growth, high_volatility, near_limit
        Description      string  `json:"description"`
        Severity         string  `json:"severity"` // info, warning, critical
        AffectedResource string  `json:"affected_resource"`
        DetectedValue    float64 `json:"detected_value"`
        ThresholdValue   float64 `json:"threshold_value"`
        Recommendation   string  `json:"recommendation"`
}

// UsagePatternsResponse contains all detected patterns
type UsagePatternsResponse struct {
        OrganizationID uint           `json:"organization_id"`
        AnalysisDate   string         `json:"analysis_date"`
        Patterns       []UsagePattern `json:"patterns"`
        PatternCount   int            `json:"pattern_count"`
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
        "time"
)

// CreateProbe creates a new monitoring probe
func (s *MonitoringService) CreateProbe(ctx context.Context, probe *MonitoringProbe) (*MonitoringProbe, error) <span class="cov3" title="2">{
        var resp StandardResponse
        resp.Data = &amp;MonitoringProbe{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/monitoring/probes",
                Body:   probe,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if created, ok := resp.Data.(*MonitoringProbe); ok </span><span class="cov1" title="1">{
                return created, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetProbe retrieves a monitoring probe by ID
func (s *MonitoringService) GetProbe(ctx context.Context, id string) (*MonitoringProbe, error) <span class="cov10" title="9">{
        var resp StandardResponse
        resp.Data = &amp;MonitoringProbe{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/monitoring/probes/%s", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov3" title="2">{
                return nil, err
        }</span>

        <span class="cov8" title="7">if probe, ok := resp.Data.(*MonitoringProbe); ok </span><span class="cov8" title="7">{
                return probe, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ListProbes retrieves a list of monitoring probes
func (s *MonitoringService) ListProbes(ctx context.Context, opts *ListOptions) ([]*MonitoringProbe, *PaginationMeta, error) <span class="cov7" title="5">{
        var resp PaginatedResponse
        var probes []*MonitoringProbe
        resp.Data = &amp;probes

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/monitoring/probes",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov5" title="3">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov7" title="5">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov7" title="5">return probes, resp.Meta, nil</span>
}

// UpdateProbe updates a monitoring probe
func (s *MonitoringService) UpdateProbe(ctx context.Context, id string, probe *MonitoringProbe) (*MonitoringProbe, error) <span class="cov8" title="6">{
        var resp StandardResponse
        resp.Data = &amp;MonitoringProbe{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/monitoring/probes/%s", id),
                Body:   probe,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov7" title="5">if updated, ok := resp.Data.(*MonitoringProbe); ok </span><span class="cov7" title="5">{
                return updated, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// DeleteProbe deletes a monitoring probe
func (s *MonitoringService) DeleteProbe(ctx context.Context, id string) error <span class="cov6" title="4">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/monitoring/probes/%s", id),
                Result: &amp;resp,
        })
        return err
}</span>

// GetProbeResults retrieves test results for a probe
func (s *MonitoringService) GetProbeResults(ctx context.Context, probeID string, opts *ListOptions) ([]*ProbeTestResult, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp PaginatedResponse
        var results []*ProbeTestResult
        resp.Data = &amp;results

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/monitoring/probes/%s/results", probeID),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov0" title="0">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return results, resp.Meta, nil</span>
}

// GetMonitoringAgents retrieves monitoring agents
func (s *MonitoringService) GetAgents(ctx context.Context, opts *ListOptions) ([]*MonitoringAgent, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp PaginatedResponse
        var agents []*MonitoringAgent
        resp.Data = &amp;agents

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/monitoring/agents",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return agents, resp.Meta, nil</span>
}

// GetMonitoringStatus retrieves monitoring status for an organization
func (s *MonitoringService) GetStatus(ctx context.Context, organizationID string) (*MonitoringStatus, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;MonitoringStatus{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/monitoring/organizations/%s/status", organizationID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if status, ok := resp.Data.(*MonitoringStatus); ok </span><span class="cov1" title="1">{
                return status, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// TestProbe manually triggers a probe test
func (s *MonitoringService) TestProbe(ctx context.Context, probeID string) (*ProbeTestResult, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;ProbeTestResult{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/monitoring/probes/%s/test", probeID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if result, ok := resp.Data.(*ProbeTestResult); ok </span><span class="cov1" title="1">{
                return result, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// MonitoringProbe represents a monitoring probe configuration
type MonitoringProbe struct {
        GormModel
        ProbeUUID      string                 `json:"probe_uuid"`
        Name           string                 `json:"name"`
        Description    string                 `json:"description,omitempty"`
        Type           string                 `json:"type"` // http, https, tcp, icmp, dns
        Target         string                 `json:"target"`
        Interval       int                    `json:"interval"` // seconds
        Timeout        int                    `json:"timeout"`  // seconds
        Enabled        bool                   `json:"enabled"`
        OrganizationID uint                   `json:"organization_id"`
        ServerID       *uint                  `json:"server_id,omitempty"`
        Regions        []string               `json:"regions,omitempty"`
        Config         map[string]interface{} `json:"config,omitempty"`
        AlertConfig    *ProbeAlertConfig      `json:"alert_config,omitempty"`
        Tags           []string               `json:"tags,omitempty"`
}

// ProbeAlertConfig represents alert configuration for a probe
type ProbeAlertConfig struct {
        Enabled           bool     `json:"enabled"`
        FailureThreshold  int      `json:"failure_threshold"`
        SuccessThreshold  int      `json:"success_threshold"`
        NotificationDelay int      `json:"notification_delay,omitempty"`
        Channels          []string `json:"channels,omitempty"`
        Recipients        []string `json:"recipients,omitempty"`
}

// MonitoringStatus represents the monitoring status for an organization
type MonitoringStatus struct {
        ActiveProbes    int                    `json:"active_probes"`
        TotalProbes     int                    `json:"total_probes"`
        ActiveAgents    int                    `json:"active_agents"`
        TotalAgents     int                    `json:"total_agents"`
        HealthyProbes   int                    `json:"healthy_probes"`
        FailingProbes   int                    `json:"failing_probes"`
        ProbesByType    map[string]int         `json:"probes_by_type"`
        ProbesByRegion  map[string]int         `json:"probes_by_region"`
        RecentIncidents []MonitoringIncident   `json:"recent_incidents,omitempty"`
        Metrics         map[string]interface{} `json:"metrics,omitempty"`
}

// MonitoringIncident represents a monitoring incident
type MonitoringIncident struct {
        ID         uint        `json:"id"`
        ProbeID    uint        `json:"probe_id"`
        ProbeName  string      `json:"probe_name"`
        StartedAt  *CustomTime `json:"started_at"`
        ResolvedAt *CustomTime `json:"resolved_at,omitempty"`
        Duration   int         `json:"duration,omitempty"`
        Status     string      `json:"status"`
        Reason     string      `json:"reason"`
        Details    string      `json:"details,omitempty"`
}

// GetAgentStatus retrieves the status of a monitoring agent
func (s *MonitoringService) GetAgentStatus(ctx context.Context, agentID string) (*AgentStatusResponse, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;AgentStatusResponse{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/monitoring/agents/%s/status", agentID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if status, ok := resp.Data.(*AgentStatusResponse); ok </span><span class="cov1" title="1">{
                return status, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// AgentStatusResponse represents the status response for a monitoring agent
type AgentStatusResponse struct {
        AgentID       string      `json:"agent_id"`
        Status        string      `json:"status"`
        LastHeartbeat *CustomTime `json:"last_heartbeat"`
        Uptime        float64     `json:"uptime"`
        ProbesRunning int         `json:"probes_running"`
        ProbesFailed  int64       `json:"probes_failed"`
        ProbesSuccess int64       `json:"probes_success"`
        ErrorRate     float64     `json:"error_rate"`
}

// ListAgents retrieves a list of monitoring agents
func (s *MonitoringService) ListAgents(ctx context.Context, opts *MonitoringAgentListOptions) ([]*MonitoringAgent, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp PaginatedResponse
        var agents []*MonitoringAgent
        resp.Data = &amp;agents

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/monitoring/agents",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return agents, resp.Meta, nil</span>
}

// RegisterAgent registers a new monitoring agent
func (s *MonitoringService) RegisterAgent(ctx context.Context, registration *AgentRegistration) (*MonitoringAgent, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;MonitoringAgent{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/monitoring/agents",
                Body:   registration,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if agent, ok := resp.Data.(*MonitoringAgent); ok </span><span class="cov1" title="1">{
                return agent, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// MonitoringAgentListOptions represents options for listing monitoring agents
type MonitoringAgentListOptions struct {
        ListOptions
        Status  string `url:"status,omitempty"`
        Region  string `url:"region,omitempty"`
        Type    string `url:"type,omitempty"`
        Enabled *bool  `url:"enabled,omitempty"`
}

// ToQuery converts options to query parameters
func (o *MonitoringAgentListOptions) ToQuery() map[string]string <span class="cov3" title="2">{
        params := o.ListOptions.ToQuery()
        if o.Status != "" </span><span class="cov1" title="1">{
                params["status"] = o.Status
        }</span>
        <span class="cov3" title="2">if o.Region != "" </span><span class="cov1" title="1">{
                params["region"] = o.Region
        }</span>
        <span class="cov3" title="2">if o.Type != "" </span><span class="cov3" title="2">{
                params["type"] = o.Type
        }</span>
        <span class="cov3" title="2">if o.Enabled != nil </span><span class="cov1" title="1">{
                params["enabled"] = fmt.Sprintf("%t", *o.Enabled)
        }</span>
        <span class="cov3" title="2">return params</span>
}

// UpdateAgent updates a monitoring agent
func (s *MonitoringService) UpdateAgent(ctx context.Context, uuid string, updates map[string]interface{}) (*MonitoringAgent, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;MonitoringAgent{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/monitoring/agents/%s", uuid),
                Body:   updates,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if agent, ok := resp.Data.(*MonitoringAgent); ok </span><span class="cov1" title="1">{
                return agent, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetAgent retrieves a monitoring agent by UUID
func (s *MonitoringService) GetAgent(ctx context.Context, uuid string) (*MonitoringAgent, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;MonitoringAgent{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/monitoring/agents/%s", uuid),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if agent, ok := resp.Data.(*MonitoringAgent); ok </span><span class="cov1" title="1">{
                return agent, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// DeleteAgent deletes a monitoring agent
func (s *MonitoringService) DeleteAgent(ctx context.Context, uuid string) error <span class="cov1" title="1">{
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/monitoring/agents/%s", uuid),
        })
        return err
}</span>

// AgentRegistration represents a monitoring agent registration request
type AgentRegistration struct {
        Name         string                 `json:"name"`
        Type         string                 `json:"type"`
        Region       string                 `json:"region"`
        Location     string                 `json:"location,omitempty"`
        Provider     string                 `json:"provider,omitempty"`
        Version      string                 `json:"version"`
        Capabilities []string               `json:"capabilities"`
        Config       map[string]interface{} `json:"config,omitempty"`
        MaxProbes    int                    `json:"max_probes,omitempty"`
}

// MonitoringDeployment represents a monitoring deployment
type MonitoringDeployment struct {
        ID             uint      `json:"id"`
        OrganizationID uint      `json:"organization_id"`
        Region         string    `json:"region"`
        NamespaceName  string    `json:"namespace_name"`
        DeploymentName string    `json:"deployment_name"`
        Status         string    `json:"status"`
        ErrorCount     int       `json:"error_count"`
        CurrentVersion string    `json:"current_version,omitempty"`
        TargetVersion  string    `json:"target_version,omitempty"`
        CreatedAt      time.Time `json:"created_at,omitempty"`
        UpdatedAt      time.Time `json:"updated_at,omitempty"`
}

// ListDeployments retrieves a list of monitoring deployments
func (s *MonitoringService) ListDeployments(ctx context.Context, opts *MonitoringDeploymentListOptions) ([]*MonitoringDeployment, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp PaginatedResponse
        var deployments []*MonitoringDeployment
        resp.Data = &amp;deployments

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/monitoring/deployments",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return deployments, resp.Meta, nil</span>
}

// MonitoringDeploymentListOptions represents options for listing monitoring deployments
type MonitoringDeploymentListOptions struct {
        ListOptions
        Environment string `url:"environment,omitempty"`
        Region      string `url:"region,omitempty"`
        Status      string `url:"status,omitempty"`
}

// ToQuery converts options to query parameters
func (o *MonitoringDeploymentListOptions) ToQuery() map[string]string <span class="cov3" title="2">{
        params := o.ListOptions.ToQuery()
        if o.Environment != "" </span><span class="cov3" title="2">{
                params["environment"] = o.Environment
        }</span>
        <span class="cov3" title="2">if o.Region != "" </span><span class="cov1" title="1">{
                params["region"] = o.Region
        }</span>
        <span class="cov3" title="2">if o.Status != "" </span><span class="cov1" title="1">{
                params["status"] = o.Status
        }</span>
        <span class="cov3" title="2">return params</span>
}

// ProbeResult represents a probe test result
type ProbeResult struct {
        ProbeID      uint                `json:"probe_id"`
        ProbeUUID    string              `json:"probe_uuid"`
        Region       string              `json:"region"`
        Status       string              `json:"status"`
        ResponseTime int                 `json:"response_time"`
        ExecutedAt   *CustomTime         `json:"executed_at"`
        StatusCode   int                 `json:"status_code,omitempty"`
        Error        string              `json:"error,omitempty"`
        Details      *ProbeResultDetails `json:"details,omitempty"`
}

// ProbeResultDetails represents detailed probe result information
type ProbeResultDetails struct {
        StatusCode   *int  `json:"status_code,omitempty"`
        ResponseSize *int  `json:"response_size,omitempty"`
        ContentMatch *bool `json:"content_match,omitempty"`
        DNSTime      *int  `json:"dns_time,omitempty"`
        ConnectTime  *int  `json:"connect_time,omitempty"`
        TLSTime      *int  `json:"tls_time,omitempty"`
}

// ListProbeResults retrieves a list of probe results
func (s *MonitoringService) ListProbeResults(ctx context.Context, opts *ProbeResultListOptions) ([]*ProbeResult, *PaginationMeta, error) <span class="cov6" title="4">{
        var resp PaginatedResponse
        var results []*ProbeResult
        resp.Data = &amp;results

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/monitoring/probe-results",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov5" title="3">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov6" title="4">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov6" title="4">return results, resp.Meta, nil</span>
}

// ProbeResultListOptions represents options for listing probe results
type ProbeResultListOptions struct {
        ListOptions
        ProbeUUID string `url:"probe_uuid,omitempty"`
        Status    string `url:"status,omitempty"`
        Region    string `url:"region,omitempty"`
}

// ToQuery converts options to query parameters
func (o *ProbeResultListOptions) ToQuery() map[string]string <span class="cov6" title="4">{
        params := o.ListOptions.ToQuery()
        if o.ProbeUUID != "" </span><span class="cov5" title="3">{
                params["probe_uuid"] = o.ProbeUUID
        }</span>
        <span class="cov6" title="4">if o.Status != "" </span><span class="cov1" title="1">{
                params["status"] = o.Status
        }</span>
        <span class="cov6" title="4">if o.Region != "" </span><span class="cov1" title="1">{
                params["region"] = o.Region
        }</span>
        <span class="cov6" title="4">return params</span>
}

// ProbeMetrics represents probe metrics
type ProbeMetrics struct {
        ProbeID          uint        `json:"probe_id,omitempty"`
        ProbeUUID        string      `json:"probe_uuid"`
        Region           string      `json:"region,omitempty"`
        Uptime           float64     `json:"uptime,omitempty"`
        UptimePercentage float64     `json:"uptime_percentage,omitempty"`
        AvgResponseTime  float64     `json:"avg_response_time"`
        SuccessRate      float64     `json:"success_rate,omitempty"`
        TotalTests       int64       `json:"total_tests,omitempty"`
        TotalChecks      int64       `json:"total_checks,omitempty"`
        SuccessfulTests  int64       `json:"successful_tests,omitempty"`
        SuccessfulChecks int64       `json:"successful_checks,omitempty"`
        FailedTests      int64       `json:"failed_tests,omitempty"`
        FailedChecks     int64       `json:"failed_checks,omitempty"`
        LastCheck        *CustomTime `json:"last_check,omitempty"`
        LastStatus       string      `json:"last_status,omitempty"`
}

// GetProbeMetrics retrieves metrics for a specific probe
func (s *MonitoringService) GetProbeMetrics(ctx context.Context, probeUUID string, timeRange ...*TimeRange) (*ProbeMetrics, error) <span class="cov5" title="3">{
        var resp StandardResponse
        resp.Data = &amp;ProbeMetrics{}

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/monitoring/probes/%s/metrics", probeUUID),
                Result: &amp;resp,
        }

        if len(timeRange) &gt; 0 &amp;&amp; timeRange[0] != nil </span><span class="cov3" title="2">{
                req.Query = map[string]string{
                        "start": timeRange[0].Start,
                        "end":   timeRange[0].End,
                }
        }</span>

        <span class="cov5" title="3">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov5" title="3">if metrics, ok := resp.Data.(*ProbeMetrics); ok </span><span class="cov5" title="3">{
                return metrics, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ProbeRequest represents a request to create or update a monitoring probe
type ProbeRequest struct {
        Name           string       `json:"name"`
        Description    string       `json:"description,omitempty"`
        Type           string       `json:"type"`
        Scope          string       `json:"scope,omitempty"`
        Target         string       `json:"target"`
        Interval       int          `json:"interval"`
        Timeout        int          `json:"timeout"`
        Enabled        bool         `json:"enabled"`
        Config         *ProbeConfig `json:"config,omitempty"`
        Regions        []string     `json:"regions,omitempty"`
        AlertThreshold int          `json:"alert_threshold,omitempty"`
        AlertEnabled   bool         `json:"alert_enabled,omitempty"`
}

// ProbeConfig represents the configuration for a monitoring probe
type ProbeConfig struct {
        Method             *string           `json:"method,omitempty"`
        ExpectedStatusCode *int              `json:"expected_status_code,omitempty"`
        FollowRedirects    *bool             `json:"follow_redirects,omitempty"`
        Headers            map[string]string `json:"headers,omitempty"`
        Body               *string           `json:"body,omitempty"`
        UserAgent          *string           `json:"user_agent,omitempty"`
        Keyword            *string           `json:"keyword,omitempty"`
        Port               *int              `json:"port,omitempty"`
}

// ProbeAlertChannel represents an alert channel for a probe
type ProbeAlertChannel struct {
        ProbeID uint         `json:"probe_id"`
        Type    string       `json:"type"`
        Name    string       `json:"name"`
        Enabled bool         `json:"enabled"`
        Config  *AlertConfig `json:"config,omitempty"`
}

// AlertConfig represents alert configuration
type AlertConfig struct {
        Recipients []string `json:"recipients,omitempty"`
        Webhook    string   `json:"webhook,omitempty"`
        SlackToken string   `json:"slack_token,omitempty"`
        Channel    string   `json:"channel,omitempty"`
}

// ========================
// Monitoring Agent Methods
// ========================

// GetAssignedProbes retrieves probes assigned to a monitoring agent for a specific region
func (s *MonitoringService) GetAssignedProbes(ctx context.Context, region string) ([]*ProbeAssignment, error) <span class="cov3" title="2">{
        var resp StandardResponse
        var assignments []*ProbeAssignment
        resp.Data = &amp;assignments

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/monitoring/probes",
                Result: &amp;resp,
        }

        // Add region as query parameter if provided
        if region != "" </span><span class="cov3" title="2">{
                req.Query = map[string]string{
                        "region": region,
                }
        }</span>

        <span class="cov3" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return assignments, nil</span>
}

// SubmitResults submits probe execution results from a monitoring agent
func (s *MonitoringService) SubmitResults(ctx context.Context, results []ProbeExecutionResult) error <span class="cov6" title="4">{
        var resp StandardResponse

        resultsPayload := &amp;ProbeResultsSubmission{
                Results: results,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/monitoring/results",
                Body:   resultsPayload,
                Result: &amp;resp,
        })
        
        return err
}</span>

// Heartbeat sends a heartbeat from a monitoring agent with node information
func (s *MonitoringService) Heartbeat(ctx context.Context, nodeInfo NodeInfo) error <span class="cov3" title="2">{
        var resp StandardResponse

        heartbeatPayload := &amp;MonitoringAgentHeartbeat{
                NodeInfo:  nodeInfo,
                Timestamp: time.Now(),
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/monitoring/heartbeat",
                Body:   heartbeatPayload,
                Result: &amp;resp,
        })
        
        return err
}</span>

// ==========================================
// Monitoring Agent Data Structures
// ==========================================

// ProbeAssignment represents a probe assignment to a monitoring agent
type ProbeAssignment struct {
        ProbeID        uint                   `json:"probe_id"`
        ProbeUUID      string                 `json:"probe_uuid"`
        Name           string                 `json:"name"`
        Type           string                 `json:"type"`           // http, https, tcp, icmp, dns
        Target         string                 `json:"target"`
        Interval       int                    `json:"interval"`       // seconds
        Timeout        int                    `json:"timeout"`        // seconds
        Enabled        bool                   `json:"enabled"`
        Configuration  map[string]interface{} `json:"configuration,omitempty"`
        Region         string                 `json:"region"`
        OrganizationID uint                   `json:"organization_id"`
        AssignedAt     *CustomTime            `json:"assigned_at,omitempty"`
        LastExecuted   *CustomTime            `json:"last_executed,omitempty"`
}

// ProbeExecutionResult represents the result of executing a probe
type ProbeExecutionResult struct {
        ProbeID        uint                   `json:"probe_id"`
        ProbeUUID      string                 `json:"probe_uuid"`
        ExecutedAt     time.Time              `json:"executed_at"`
        Region         string                 `json:"region"`
        Status         string                 `json:"status"`         // success, failed, timeout, error
        ResponseTime   int                    `json:"response_time"`  // milliseconds
        StatusCode     int                    `json:"status_code,omitempty"`
        Error          string                 `json:"error,omitempty"`
        Details        map[string]interface{} `json:"details,omitempty"`
        
        // Additional timing metrics
        DNSTime        int `json:"dns_time,omitempty"`        // milliseconds
        ConnectTime    int `json:"connect_time,omitempty"`    // milliseconds
        TLSTime        int `json:"tls_time,omitempty"`        // milliseconds
        FirstByteTime  int `json:"first_byte_time,omitempty"` // milliseconds
        TotalTime      int `json:"total_time,omitempty"`      // milliseconds
        
        // Content validation
        ContentMatch   *bool   `json:"content_match,omitempty"`
        ResponseSize   int     `json:"response_size,omitempty"`   // bytes
        ResponseBody   string  `json:"response_body,omitempty"`   // truncated for large responses
}

// ProbeResultsSubmission represents a submission of multiple probe results
type ProbeResultsSubmission struct {
        Results   []ProbeExecutionResult `json:"results"`
        AgentInfo *NodeInfo              `json:"agent_info,omitempty"`
        Timestamp time.Time              `json:"timestamp"`
}

// NodeInfo represents information about the monitoring agent node
type NodeInfo struct {
        AgentID       string                 `json:"agent_id"`
        AgentVersion  string                 `json:"agent_version"`
        Region        string                 `json:"region"`
        Hostname      string                 `json:"hostname,omitempty"`
        IPAddress     string                 `json:"ip_address,omitempty"`
        Status        string                 `json:"status"`         // healthy, degraded, unhealthy
        Uptime        time.Duration          `json:"uptime"`         // how long agent has been running
        LastSeen      time.Time              `json:"last_seen"`
        
        // Resource usage
        CPUUsage      float64                `json:"cpu_usage,omitempty"`      // percentage
        MemoryUsage   int64                  `json:"memory_usage,omitempty"`   // bytes
        DiskUsage     int64                  `json:"disk_usage,omitempty"`     // bytes
        NetworkRx     int64                  `json:"network_rx,omitempty"`     // bytes
        NetworkTx     int64                  `json:"network_tx,omitempty"`     // bytes
        
        // Probe execution statistics
        ProbesAssigned     int     `json:"probes_assigned"`
        ProbesExecuted     int64   `json:"probes_executed"`
        ProbesSuccessful   int64   `json:"probes_successful"`
        ProbesFailed       int64   `json:"probes_failed"`
        SuccessRate        float64 `json:"success_rate"`          // percentage
        AvgResponseTime    float64 `json:"avg_response_time"`     // milliseconds
        
        // Configuration and capabilities
        MaxConcurrency int      `json:"max_concurrency,omitempty"`
        SupportedTypes []string `json:"supported_types,omitempty"`
        Capabilities   []string `json:"capabilities,omitempty"`
        
        // Additional metadata
        Environment string                 `json:"environment,omitempty"`
        Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// MonitoringAgentHeartbeat represents a heartbeat message from a monitoring agent
type MonitoringAgentHeartbeat struct {
        NodeInfo  NodeInfo  `json:"node_info"`
        Timestamp time.Time `json:"timestamp"`
}

</pre>
		
		<pre class="file" id="file37" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// MonitoringAgentKey represents a monitoring agent API key
type MonitoringAgentKey struct {
        GormModel
        KeyID              string          `json:"key_id"`
        KeyPrefix          string          `json:"key_prefix"`       // First few characters for display
        OrganizationID     uint            `json:"organization_id"`
        Organization       *Organization   `json:"organization,omitempty"`
        RemoteClusterID    *uint           `json:"remote_cluster_id,omitempty"`
        RemoteCluster      *RemoteCluster  `json:"remote_cluster,omitempty"`
        NamespaceName      string          `json:"namespace_name"`
        Description        string          `json:"description"`
        Capabilities       string          `json:"capabilities,omitempty"`
        AgentType          string          `json:"agent_type"`           // public or private
        AllowedProbeScopes string          `json:"allowed_probe_scopes"` // JSON array of allowed scopes
        RegionCode         string          `json:"region_code,omitempty"`
        Status             string          `json:"status"` // active, revoked
        LastUsedAt         *CustomTime     `json:"last_used_at,omitempty"`
        UsageCount         int             `json:"usage_count"`
}


// CreateMonitoringAgentKeyRequest represents the request to create a monitoring agent key
type CreateMonitoringAgentKeyRequest struct {
        OrganizationID     uint     `json:"organization_id,omitempty"`        // Only for admin endpoints
        RemoteClusterID    *uint    `json:"remote_cluster_id,omitempty"`
        Description        string   `json:"description"`
        NamespaceName      string   `json:"namespace_name"`
        Capabilities       string   `json:"capabilities,omitempty"`
        AgentType          string   `json:"agent_type"`                       // public or private
        RegionCode         string   `json:"region_code,omitempty"`            // Required for public agents
        AllowedProbeScopes []string `json:"allowed_probe_scopes"`             // ["public"] or ["public", "private"]
}

// CreateMonitoringAgentKeyResponse represents the response when creating a monitoring agent key
type CreateMonitoringAgentKeyResponse struct {
        KeyID              string              `json:"key_id"`
        SecretKey          string              `json:"secret_key"`
        FullToken          string              `json:"full_token"`
        AgentType          string              `json:"agent_type"`
        AllowedProbeScopes []string            `json:"allowed_probe_scopes"`
        Key                *MonitoringAgentKey `json:"key"`
}

// ListMonitoringAgentKeysOptions represents options for listing monitoring agent keys
type ListMonitoringAgentKeysOptions struct {
        Page        int    `json:"page,omitempty"`
        Limit       int    `json:"limit,omitempty"`
        Namespace   string `json:"namespace,omitempty"`
        Enabled     *bool  `json:"enabled,omitempty"`
        ClusterID   *uint  `json:"cluster_id,omitempty"`
}

// ToQuery converts options to query parameters
func (o *ListMonitoringAgentKeysOptions) ToQuery() map[string]string <span class="cov5" title="2">{
        query := make(map[string]string)
        if o.Page &gt; 0 </span><span class="cov5" title="2">{
                query["page"] = fmt.Sprintf("%d", o.Page)
        }</span>
        <span class="cov5" title="2">if o.Limit &gt; 0 </span><span class="cov5" title="2">{
                query["limit"] = fmt.Sprintf("%d", o.Limit)
        }</span>
        <span class="cov5" title="2">if o.Namespace != "" </span><span class="cov5" title="2">{
                query["namespace"] = o.Namespace
        }</span>
        <span class="cov5" title="2">if o.Enabled != nil </span><span class="cov1" title="1">{
                query["enabled"] = fmt.Sprintf("%t", *o.Enabled)
        }</span>
        <span class="cov5" title="2">if o.ClusterID != nil </span><span class="cov1" title="1">{
                query["cluster_id"] = fmt.Sprintf("%d", *o.ClusterID)
        }</span>
        <span class="cov5" title="2">return query</span>
}

// Admin Methods

// CreateMonitoringAgentKey creates a new monitoring agent key (admin only)
func (s *MonitoringAgentKeysService) CreateAdmin(ctx context.Context, req *CreateMonitoringAgentKeyRequest) (*CreateMonitoringAgentKeyResponse, error) <span class="cov8" title="3">{
        var resp StandardResponse
        result := &amp;CreateMonitoringAgentKeyResponse{}
        resp.Data = result

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/admin/monitoring-agent-keys",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// Customer Organization Methods

// Create creates a new monitoring agent key for the organization
func (s *MonitoringAgentKeysService) Create(ctx context.Context, organizationID string, req *CreateMonitoringAgentKeyRequest) (*CreateMonitoringAgentKeyResponse, error) <span class="cov8" title="3">{
        // Clear organization ID as it's provided in the path for org endpoints
        req.OrganizationID = 0

        var resp StandardResponse
        result := &amp;CreateMonitoringAgentKeyResponse{}
        resp.Data = result

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/organizations/%s/monitoring-agent-keys", organizationID),
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return result, nil</span>
}

// List retrieves monitoring agent keys for an organization
func (s *MonitoringAgentKeysService) List(ctx context.Context, organizationID string, opts *ListMonitoringAgentKeysOptions) ([]*MonitoringAgentKey, *PaginationMeta, error) <span class="cov10" title="4">{
        var resp struct {
                StandardResponse
                Keys       []*MonitoringAgentKey `json:"keys"`
                Pagination *PaginationMeta       `json:"pagination"`
        }

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/organizations/%s/monitoring-agent-keys", organizationID),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov10" title="4">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov5" title="2">{
                return nil, nil, err
        }</span>

        <span class="cov5" title="2">return resp.Keys, resp.Pagination, nil</span>
}

// Revoke revokes a monitoring agent key
func (s *MonitoringAgentKeysService) Revoke(ctx context.Context, organizationID, keyID string) error <span class="cov8" title="3">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/organizations/%s/monitoring-agent-keys/%s/revoke", organizationID, keyID),
                Result: &amp;resp,
        })
        return err
}</span>

// IsActive returns true if the monitoring agent key is active
func (k *MonitoringAgentKey) IsActive() bool <span class="cov5" title="2">{
        return k.Status == "active"
}</span>

// IsRevoked returns true if the monitoring agent key is revoked
func (k *MonitoringAgentKey) IsRevoked() bool <span class="cov5" title="2">{
        return k.Status == "revoked"
}</span>

// IsPublic returns true if the monitoring agent key is for a public agent
func (k *MonitoringAgentKey) IsPublic() bool <span class="cov5" title="2">{
        return k.AgentType == "public"
}</span>

// IsPrivate returns true if the monitoring agent key is for a private agent
func (k *MonitoringAgentKey) IsPrivate() bool <span class="cov5" title="2">{
        return k.AgentType == "private"
}</span>

// Helper functions for creating monitoring agent keys

// NewPublicAgentKeyRequest creates a request for a public monitoring agent key
func NewPublicAgentKeyRequest(description, namespaceName, regionCode string) *CreateMonitoringAgentKeyRequest <span class="cov1" title="1">{
        return &amp;CreateMonitoringAgentKeyRequest{
                Description:        description,
                NamespaceName:      namespaceName,
                AgentType:          "public",
                RegionCode:         regionCode,
                AllowedProbeScopes: []string{"public"},
        }
}</span>

// NewPrivateAgentKeyRequest creates a request for a private monitoring agent key
func NewPrivateAgentKeyRequest(description, namespaceName string, regionCode string) *CreateMonitoringAgentKeyRequest <span class="cov1" title="1">{
        return &amp;CreateMonitoringAgentKeyRequest{
                Description:        description,
                NamespaceName:      namespaceName,
                AgentType:          "private",
                RegionCode:         regionCode, // Optional for private agents
                AllowedProbeScopes: []string{"public", "private"},
        }
}</pre>
		
		<pre class="file" id="file38" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
        "time"
)

// NetworkHardwareService handles network hardware operations
type NetworkHardwareService struct {
        client *Client
}

// NetworkHardwareRequest represents the request to submit network hardware information
type NetworkHardwareRequest struct {
        ServerUUID string                `json:"server_uuid"`
        Interfaces []NetworkHardwareInfo `json:"interfaces"`
}

// NetworkHardwareInfo represents comprehensive network hardware data
type NetworkHardwareInfo struct {
        // Interface identification
        InterfaceName   string `json:"interface_name"`
        InterfaceType   string `json:"interface_type,omitempty"`
        InterfaceAlias  string `json:"interface_alias,omitempty"`
        MacAddress      string `json:"mac_address,omitempty"`
        HardwareAddress string `json:"hardware_address,omitempty"`

        // Physical hardware specifications
        Manufacturer    string `json:"manufacturer,omitempty"`
        DeviceName      string `json:"device_name,omitempty"`
        DriverName      string `json:"driver_name,omitempty"`
        DriverVersion   string `json:"driver_version,omitempty"`
        FirmwareVersion string `json:"firmware_version,omitempty"`
        PCISlot         string `json:"pci_slot,omitempty"`
        BusInfo         string `json:"bus_info,omitempty"`

        // Physical port specifications
        PortType       string   `json:"port_type,omitempty"`
        ConnectorType  string   `json:"connector_type,omitempty"`
        SupportedPorts []string `json:"supported_ports,omitempty"`

        // Speed and duplex capabilities
        SpeedMbps       int    `json:"speed_mbps,omitempty"`
        MaxSpeedMbps    int    `json:"max_speed_mbps,omitempty"`
        SupportedSpeeds []int  `json:"supported_speeds,omitempty"`
        Duplex          string `json:"duplex,omitempty"`
        AutoNegotiation bool   `json:"auto_negotiation,omitempty"`

        // Link status and configuration
        LinkDetected        bool   `json:"link_detected,omitempty"`
        CarrierStatus       bool   `json:"carrier_status,omitempty"`
        OperationalState    string `json:"operational_state,omitempty"`
        AdministrativeState string `json:"administrative_state,omitempty"`
        MTU                 int    `json:"mtu,omitempty"`

        // Network configuration
        IPAddresses      []string `json:"ip_addresses,omitempty"`
        IPv6Addresses    []string `json:"ipv6_addresses,omitempty"`
        SubnetMasks      []string `json:"subnet_masks,omitempty"`
        GatewayAddresses []string `json:"gateway_addresses,omitempty"`
        DNSServers       []string `json:"dns_servers,omitempty"`
        Domains          []string `json:"domains,omitempty"`

        // VLAN configuration
        VlanID       int    `json:"vlan_id,omitempty"`
        VlanParent   string `json:"vlan_parent,omitempty"`
        NativeVlan   int    `json:"native_vlan,omitempty"`
        AllowedVlans []int  `json:"allowed_vlans,omitempty"`

        // Bonding/Teaming configuration
        BondMode        string   `json:"bond_mode,omitempty"`
        BondMaster      string   `json:"bond_master,omitempty"`
        BondSlaves      []string `json:"bond_slaves,omitempty"`
        BondPrimary     string   `json:"bond_primary,omitempty"`
        BondActiveSlave string   `json:"bond_active_slave,omitempty"`
        LACPRate        string   `json:"lacp_rate,omitempty"`
        XmitHashPolicy  string   `json:"xmit_hash_policy,omitempty"`

        // Bridge configuration
        BridgeMaster       string   `json:"bridge_master,omitempty"`
        BridgePorts        []string `json:"bridge_ports,omitempty"`
        BridgeSTP          bool     `json:"bridge_stp,omitempty"`
        BridgeForwardDelay int      `json:"bridge_forward_delay,omitempty"`
        BridgeHelloTime    int      `json:"bridge_hello_time,omitempty"`
        BridgeMaxAge       int      `json:"bridge_max_age,omitempty"`
        BridgePriority     int      `json:"bridge_priority,omitempty"`

        // Wake-on-LAN configuration
        WOLEnabled bool     `json:"wol_enabled,omitempty"`
        WOLModes   []string `json:"wol_modes,omitempty"`

        // Power management
        PowerManagement         bool `json:"power_management,omitempty"`
        EnergyEfficientEthernet bool `json:"energy_efficient_ethernet,omitempty"`

        // Statistics and metrics
        RxBytes       int64 `json:"rx_bytes,omitempty"`
        TxBytes       int64 `json:"tx_bytes,omitempty"`
        RxPackets     int64 `json:"rx_packets,omitempty"`
        TxPackets     int64 `json:"tx_packets,omitempty"`
        RxErrors      int64 `json:"rx_errors,omitempty"`
        TxErrors      int64 `json:"tx_errors,omitempty"`
        RxDropped     int64 `json:"rx_dropped,omitempty"`
        TxDropped     int64 `json:"tx_dropped,omitempty"`
        RxFifoErrors  int64 `json:"rx_fifo_errors,omitempty"`
        TxFifoErrors  int64 `json:"tx_fifo_errors,omitempty"`
        RxFrameErrors int64 `json:"rx_frame_errors,omitempty"`
        RxCRCErrors   int64 `json:"rx_crc_errors,omitempty"`
        Collisions    int64 `json:"collisions,omitempty"`

        // Advanced statistics
        Multicast       int64 `json:"multicast,omitempty"`
        RxLengthErrors  int64 `json:"rx_length_errors,omitempty"`
        RxOverErrors    int64 `json:"rx_over_errors,omitempty"`
        TxAbortedErrors int64 `json:"tx_aborted_errors,omitempty"`
        TxCarrierErrors int64 `json:"tx_carrier_errors,omitempty"`
        TxWindowErrors  int64 `json:"tx_window_errors,omitempty"`
        RxCompressed    int64 `json:"rx_compressed,omitempty"`
        TxCompressed    int64 `json:"tx_compressed,omitempty"`

        // Quality metrics
        SignalStrengthDBM  float64 `json:"signal_strength_dbm,omitempty"`
        LinkQualityPercent float64 `json:"link_quality_percent,omitempty"`
        NoiseLevelDBM      float64 `json:"noise_level_dbm,omitempty"`

        // Wireless specific
        IsWireless           bool    `json:"is_wireless,omitempty"`
        WirelessMode         string  `json:"wireless_mode,omitempty"`
        WirelessProtocol     string  `json:"wireless_protocol,omitempty"`
        WirelessFrequencyMHz float64 `json:"wireless_frequency_mhz,omitempty"`
        WirelessChannel      int     `json:"wireless_channel,omitempty"`
        WirelessSSID         string  `json:"wireless_ssid,omitempty"`
        WirelessBSSID        string  `json:"wireless_bssid,omitempty"`
        WirelessEncryption   string  `json:"wireless_encryption,omitempty"`

        // Status and health
        Status        string    `json:"status,omitempty"`
        LastSeen      time.Time `json:"last_seen,omitempty"`
        UptimeSeconds int64     `json:"uptime_seconds,omitempty"`
}

// Submit submits network hardware information for a server
func (s *NetworkHardwareService) Submit(ctx context.Context, serverUUID string, interfaces []NetworkHardwareInfo) (*StandardResponse, error) <span class="cov10" title="13">{
        if s.client.config.Debug </span><span class="cov4" title="3">{
                fmt.Printf("[DEBUG] NetworkHardware.Submit: Starting network hardware submission\n")
                fmt.Printf("[DEBUG] NetworkHardware.Submit: Server UUID: %s\n", serverUUID)
                fmt.Printf("[DEBUG] NetworkHardware.Submit: Number of interfaces: %d\n", len(interfaces))
        }</span>

        <span class="cov10" title="13">if serverUUID == "" </span><span class="cov3" title="2">{
                if s.client.config.Debug </span><span class="cov1" title="1">{
                        fmt.Printf("[DEBUG] NetworkHardware.Submit: ERROR - Server UUID is required\n")
                }</span>
                <span class="cov3" title="2">return nil, fmt.Errorf("server UUID is required")</span>
        }

        <span class="cov9" title="11">req := NetworkHardwareRequest{
                ServerUUID: serverUUID,
                Interfaces: interfaces,
        }

        endpoint := fmt.Sprintf("/v2/server/%s/hardware/network", serverUUID)
        if s.client.config.Debug </span><span class="cov3" title="2">{
                fmt.Printf("[DEBUG] NetworkHardware.Submit: Endpoint: POST %s\n", endpoint)
                fmt.Printf("[DEBUG] NetworkHardware.Submit: Request payload:\n")
                fmt.Printf("[DEBUG] NetworkHardware.Submit:   ServerUUID: %s\n", req.ServerUUID)
                fmt.Printf("[DEBUG] NetworkHardware.Submit:   Interfaces count: %d\n", len(req.Interfaces))

                for i, iface := range req.Interfaces </span><span class="cov6" title="5">{
                        fmt.Printf("[DEBUG] NetworkHardware.Submit:   Interface[%d]:\n", i)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit:     Name: %s\n", iface.InterfaceName)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit:     Type: %s\n", iface.InterfaceType)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit:     MAC: %s\n", iface.MacAddress)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit:     Speed: %d Mbps\n", iface.SpeedMbps)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit:     State: %s\n", iface.OperationalState)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit:     Link: %t\n", iface.LinkDetected)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit:     IPs: %v\n", iface.IPAddresses)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit:     RX Bytes: %d\n", iface.RxBytes)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit:     TX Bytes: %d\n", iface.TxBytes)

                        if iface.InterfaceType == "bond" </span><span class="cov1" title="1">{
                                fmt.Printf("[DEBUG] NetworkHardware.Submit:     Bond Mode: %s\n", iface.BondMode)
                                fmt.Printf("[DEBUG] NetworkHardware.Submit:     Bond Slaves: %v\n", iface.BondSlaves)
                        }</span>
                        <span class="cov6" title="5">if iface.InterfaceType == "vlan" </span><span class="cov1" title="1">{
                                fmt.Printf("[DEBUG] NetworkHardware.Submit:     VLAN ID: %d\n", iface.VlanID)
                                fmt.Printf("[DEBUG] NetworkHardware.Submit:     VLAN Parent: %s\n", iface.VlanParent)
                        }</span>
                        <span class="cov6" title="5">if iface.InterfaceType == "bridge" </span><span class="cov1" title="1">{
                                fmt.Printf("[DEBUG] NetworkHardware.Submit:     Bridge Ports: %v\n", iface.BridgePorts)
                                fmt.Printf("[DEBUG] NetworkHardware.Submit:     Bridge STP: %t\n", iface.BridgeSTP)
                        }</span>
                }

                <span class="cov3" title="2">fmt.Printf("[DEBUG] NetworkHardware.Submit: Using authentication method: %s\n", s.client.getAuthMethod())</span>
        }

        <span class="cov9" title="11">var resp StandardResponse
        httpResp, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   endpoint,
                Body:   req,
                Result: &amp;resp,
        })

        if s.client.config.Debug </span><span class="cov3" title="2">{
                if httpResp != nil </span><span class="cov1" title="1">{
                        fmt.Printf("[DEBUG] NetworkHardware.Submit: HTTP Response Status: %d\n", httpResp.StatusCode)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit: HTTP Response Headers: %v\n", httpResp.Headers)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit: HTTP Response Body Size: %d bytes\n", len(httpResp.Body))
                        if len(httpResp.Body) &gt; 0 &amp;&amp; len(httpResp.Body) &lt; 1000 </span><span class="cov1" title="1">{
                                fmt.Printf("[DEBUG] NetworkHardware.Submit: HTTP Response Body: %s\n", string(httpResp.Body))
                        }</span>
                }

                <span class="cov3" title="2">if err != nil </span><span class="cov1" title="1">{
                        fmt.Printf("[DEBUG] NetworkHardware.Submit: ERROR - Request failed: %v\n", err)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit: Error type: %T\n", err)

                        // Check if it's an API error and log details
                        if apiErr, ok := err.(*APIError); ok </span><span class="cov1" title="1">{
                                fmt.Printf("[DEBUG] NetworkHardware.Submit: API Error Details:\n")
                                fmt.Printf("[DEBUG] NetworkHardware.Submit:   Status: %s\n", apiErr.Status)
                                fmt.Printf("[DEBUG] NetworkHardware.Submit:   ErrorCode: %s\n", apiErr.ErrorCode)
                                fmt.Printf("[DEBUG] NetworkHardware.Submit:   Message: %s\n", apiErr.Message)
                                fmt.Printf("[DEBUG] NetworkHardware.Submit:   ErrorType: %s\n", apiErr.ErrorType)
                        }</span>
                } else<span class="cov1" title="1"> {
                        fmt.Printf("[DEBUG] NetworkHardware.Submit: Request successful\n")
                        fmt.Printf("[DEBUG] NetworkHardware.Submit: Response Status: %s\n", resp.Status)
                        fmt.Printf("[DEBUG] NetworkHardware.Submit: Response Message: %s\n", resp.Message)
                        if resp.Data != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[DEBUG] NetworkHardware.Submit: Response Data: %+v\n", resp.Data)
                        }</span> else<span class="cov1" title="1"> {
                                fmt.Printf("[DEBUG] NetworkHardware.Submit: Response Data: &lt;nil&gt;\n")
                        }</span>
                }
        }

        <span class="cov9" title="11">if err != nil </span><span class="cov5" title="4">{
                return nil, err
        }</span>

        <span class="cov7" title="7">return &amp;resp, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package nexmonyx

import (
        "context"
)

// NotificationsService handles operations related to notifications
type NotificationsService struct {
        client *Client
}

// SendNotification sends a notification through configured channels
func (s *NotificationsService) SendNotification(ctx context.Context, req *NotificationRequest) (*NotificationResponse, error) <span class="cov10" title="6">{
        var resp StandardResponse
        resp.Data = &amp;NotificationResponse{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/notifications/send",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov6" title="3">{
                return nil, err
        }</span>

        <span class="cov6" title="3">if notification, ok := resp.Data.(*NotificationResponse); ok </span><span class="cov6" title="3">{
                return notification, nil
        }</span>
        <span class="cov0" title="0">return nil, ErrUnexpectedResponse</span>
}

// SendBatchNotifications sends multiple notifications in a single request
func (s *NotificationsService) SendBatchNotifications(ctx context.Context, req *BatchNotificationRequest) (*BatchNotificationResponse, error) <span class="cov6" title="3">{
        var resp StandardResponse
        resp.Data = &amp;BatchNotificationResponse{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/notifications/send/batch",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if batchResp, ok := resp.Data.(*BatchNotificationResponse); ok </span><span class="cov1" title="1">{
                return batchResp, nil
        }</span>
        <span class="cov0" title="0">return nil, ErrUnexpectedResponse</span>
}

// GetNotificationStatus retrieves status information for notifications
func (s *NotificationsService) GetNotificationStatus(ctx context.Context, req *NotificationStatusRequest) (*NotificationStatusResponse, error) <span class="cov6" title="3">{
        var resp StandardResponse
        resp.Data = &amp;NotificationStatusResponse{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/notifications/status",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov4" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if statusResp, ok := resp.Data.(*NotificationStatusResponse); ok </span><span class="cov1" title="1">{
                return statusResp, nil
        }</span>
        <span class="cov0" title="0">return nil, ErrUnexpectedResponse</span>
}

// SendQuotaAlert is a convenience method for sending quota-related notifications
func (s *NotificationsService) SendQuotaAlert(ctx context.Context, orgID uint, subject, content string, priority NotificationPriority, metadata map[string]interface{}) (*NotificationResponse, error) <span class="cov6" title="3">{
        req := &amp;NotificationRequest{
                OrganizationID: orgID,
                Subject:        subject,
                Content:        content,
                ContentType:    "html",
                Priority:       priority,
                Metadata:       metadata,
                // Use all available channels - notification-service will filter appropriately
        }

        return s.SendNotification(ctx, req)
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// GetOrganization retrieves an organization by ID
func (s *OrganizationsService) Get(ctx context.Context, id string) (*Organization, error) <span class="cov10" title="3">{
        var resp StandardResponse
        resp.Data = &amp;Organization{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/organizations/%s", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov6" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if org, ok := resp.Data.(*Organization); ok </span><span class="cov1" title="1">{
                return org, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ListOrganizations retrieves a list of organizations
func (s *OrganizationsService) List(ctx context.Context, opts *ListOptions) ([]*Organization, *PaginationMeta, error) <span class="cov6" title="2">{
        var resp PaginatedResponse
        var orgs []*Organization
        resp.Data = &amp;orgs

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/organizations",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov6" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov6" title="2">return orgs, resp.Meta, nil</span>
}

// CreateOrganization creates a new organization
func (s *OrganizationsService) Create(ctx context.Context, org *Organization) (*Organization, error) <span class="cov10" title="3">{
        var resp StandardResponse
        resp.Data = &amp;Organization{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/organizations",
                Body:   org,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov6" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if created, ok := resp.Data.(*Organization); ok </span><span class="cov1" title="1">{
                return created, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// UpdateOrganization updates an existing organization
func (s *OrganizationsService) Update(ctx context.Context, id string, org *Organization) (*Organization, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;Organization{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/organizations/%s", id),
                Body:   org,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if updated, ok := resp.Data.(*Organization); ok </span><span class="cov1" title="1">{
                return updated, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// DeleteOrganization deletes an organization
func (s *OrganizationsService) Delete(ctx context.Context, id string) error <span class="cov10" title="3">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/organizations/%s", id),
                Result: &amp;resp,
        })
        return err
}</span>

// GetOrganizationByUUID retrieves an organization by UUID
func (s *OrganizationsService) GetByUUID(ctx context.Context, uuid string) (*Organization, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;Organization{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/organizations/uuid/%s", uuid),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if org, ok := resp.Data.(*Organization); ok </span><span class="cov1" title="1">{
                return org, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetOrganizationServers retrieves servers for an organization
func (s *OrganizationsService) GetServers(ctx context.Context, id string, opts *ListOptions) ([]*Server, *PaginationMeta, error) <span class="cov6" title="2">{
        var resp PaginatedResponse
        var servers []*Server
        resp.Data = &amp;servers

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/organizations/%s/servers", id),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov6" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return servers, resp.Meta, nil</span>
}

// GetOrganizationUsers retrieves users for an organization
func (s *OrganizationsService) GetUsers(ctx context.Context, id string, opts *ListOptions) ([]*User, *PaginationMeta, error) <span class="cov6" title="2">{
        var resp PaginatedResponse
        var users []*User
        resp.Data = &amp;users

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/organizations/%s/users", id),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov6" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return users, resp.Meta, nil</span>
}

// GetOrganizationAlerts retrieves alerts for an organization
func (s *OrganizationsService) GetAlerts(ctx context.Context, id string, opts *ListOptions) ([]*Alert, *PaginationMeta, error) <span class="cov6" title="2">{
        var resp PaginatedResponse
        var alerts []*Alert
        resp.Data = &amp;alerts

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/organizations/%s/alerts", id),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov6" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return alerts, resp.Meta, nil</span>
}

// UpdateOrganizationSettings updates organization settings
func (s *OrganizationsService) UpdateSettings(ctx context.Context, id string, settings map[string]interface{}) (*Organization, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;Organization{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/organizations/%s/settings", id),
                Body:   settings,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if org, ok := resp.Data.(*Organization); ok </span><span class="cov1" title="1">{
                return org, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetOrganizationBilling retrieves billing information for an organization
func (s *OrganizationsService) GetBilling(ctx context.Context, id string) (map[string]interface{}, error) <span class="cov6" title="2">{
        var resp StandardResponse
        var billing map[string]interface{}
        resp.Data = &amp;billing

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/organizations/%s/billing", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return billing, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package nexmonyx

import (
        "context"
)

// PackagesService handles organization package/tier management and limits
type PackagesService struct {
        client *Client
}

// GetAvailablePackageTiers retrieves information about all available package tiers
// Authentication: Public (no authentication required)
// Endpoint: GET /v1/package/tiers
// Returns: Map of available package tiers with their features and limits
func (s *PackagesService) GetAvailablePackageTiers(ctx context.Context) (map[string]interface{}, error) <span class="cov1" title="1">{
        var resp struct {
                Data    map[string]interface{} `json:"data"`
                Status  string                 `json:"status"`
                Message string                 `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/package/tiers",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// GetOrganizationPackage retrieves the current package information for the authenticated organization
// Authentication: JWT Token required
// Endpoint: GET /v1/organization/package
// Returns: OrganizationPackage with current limits and usage information
func (s *PackagesService) GetOrganizationPackage(ctx context.Context) (*OrganizationPackage, error) <span class="cov10" title="5">{
        var resp struct {
                Data    *OrganizationPackage `json:"data"`
                Status  string               `json:"status"`
                Message string               `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/organization/package",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov8" title="4">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// UpgradeOrganizationPackage upgrades the organization to a new package tier
// Authentication: JWT Token required
// Endpoint: POST /v1/organization/package/upgrade
// Parameters:
//   - req: Upgrade request containing new tier and optional payment information
// Returns: Updated OrganizationPackage
func (s *PackagesService) UpgradeOrganizationPackage(ctx context.Context, req *PackageUpgradeRequest) (*OrganizationPackage, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *OrganizationPackage `json:"data"`
                Status  string               `json:"status"`
                Message string               `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/organization/package/upgrade",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// ValidateProbeConfig validates if a probe configuration is allowed under the current package limits
// Authentication: JWT Token required
// Endpoint: POST /v1/organization/package/validate-probe-config
// Parameters:
//   - req: Probe configuration to validate
// Returns: Validation result indicating if configuration is allowed
func (s *PackagesService) ValidateProbeConfig(ctx context.Context, req *ProbeConfigValidationRequest) (*ProbeConfigValidationResult, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *ProbeConfigValidationResult `json:"data"`
                Status  string                       `json:"status"`
                Message string                       `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/organization/package/validate-probe-config",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// ProbeAlertsService handles communication with the probe alerts endpoints
type ProbeAlertsService struct {
        client *Client
}

// ProbeAlert represents a monitoring probe alert
type ProbeAlert struct {
        ID               uint                 `json:"id"`
        ProbeID          uint                 `json:"probe_id"`
        Name             string               `json:"name"`
        Status           string               `json:"status"` // active, acknowledged, resolved
        Message          string               `json:"message"`
        Conditions       ProbeAlertConditions `json:"conditions"`
        TriggeredAt      *CustomTime          `json:"triggered_at"`
        AcknowledgedBy   *uint                `json:"acknowledged_by,omitempty"`
        AcknowledgedAt   *CustomTime          `json:"acknowledged_at,omitempty"`
        ResolvedAt       *CustomTime          `json:"resolved_at,omitempty"`
        Resolution       *string              `json:"resolution,omitempty"`
        NotificationSent bool                 `json:"notification_sent"`
        CreatedAt        *CustomTime          `json:"created_at"`
        UpdatedAt        *CustomTime          `json:"updated_at"`
}

// ProbeAlertConditions represents the conditions that triggered an alert
type ProbeAlertConditions struct {
        FailureThreshold  int `json:"failure_threshold"`
        RecoveryThreshold int `json:"recovery_threshold"`
}

// ProbeAlertListOptions represents options for listing probe alerts
type ProbeAlertListOptions struct {
        ListOptions
        Status  string // Filter by status
        ProbeID int    // Filter by probe ID
}

// ToQuery converts ProbeAlertListOptions to query parameters
func (opts *ProbeAlertListOptions) ToQuery() map[string]string <span class="cov8" title="1">{
        params := opts.ListOptions.ToQuery()

        if opts.Status != "" </span><span class="cov8" title="1">{
                params["status"] = opts.Status
        }</span>
        <span class="cov8" title="1">if opts.ProbeID &gt; 0 </span><span class="cov8" title="1">{
                params["probe_id"] = fmt.Sprintf("%d", opts.ProbeID)
        }</span>

        <span class="cov8" title="1">return params</span>
}

// List retrieves all probe alerts for the organization
func (s *ProbeAlertsService) List(ctx context.Context, opts *ProbeAlertListOptions) ([]*ProbeAlert, *PaginationMeta, error) <span class="cov8" title="1">{
        var resp struct {
                Status  string `json:"status"`
                Message string `json:"message"`
                Data    struct {
                        Alerts     []*ProbeAlert   `json:"alerts"`
                        Pagination *PaginationMeta `json:"pagination"`
                } `json:"data"`
        }

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/probe-alerts",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov8" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov8" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return resp.Data.Alerts, resp.Data.Pagination, nil</span>
}

// Get retrieves a specific probe alert by ID
func (s *ProbeAlertsService) Get(ctx context.Context, id uint) (*ProbeAlert, error) <span class="cov8" title="1">{
        var resp struct {
                Status  string `json:"status"`
                Message string `json:"message"`
                Data    struct {
                        Alert *ProbeAlert `json:"alert"`
                        Probe struct {
                                ID   uint   `json:"id"`
                                UUID string `json:"uuid"`
                                Name string `json:"name"`
                                Type string `json:"type"`
                        } `json:"probe"`
                } `json:"data"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/probe-alerts/%d", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return resp.Data.Alert, nil</span>
}

// Acknowledge acknowledges a probe alert
func (s *ProbeAlertsService) Acknowledge(ctx context.Context, id uint, note string) (*ProbeAlert, error) <span class="cov8" title="1">{
        var resp struct {
                Status  string `json:"status"`
                Message string `json:"message"`
                Data    struct {
                        Alert *ProbeAlert `json:"alert"`
                } `json:"data"`
        }

        body := map[string]string{}
        if note != "" </span><span class="cov8" title="1">{
                body["note"] = note
        }</span>

        <span class="cov8" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/probe-alerts/%d/acknowledge", id),
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return resp.Data.Alert, nil</span>
}

// Resolve resolves a probe alert
func (s *ProbeAlertsService) Resolve(ctx context.Context, id uint, resolution string) (*ProbeAlert, error) <span class="cov8" title="1">{
        var resp struct {
                Status  string `json:"status"`
                Message string `json:"message"`
                Data    struct {
                        Alert *ProbeAlert `json:"alert"`
                } `json:"data"`
        }

        body := map[string]string{}
        if resolution != "" </span><span class="cov8" title="1">{
                body["resolution"] = resolution
        }</span>

        <span class="cov8" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/probe-alerts/%d/resolve", id),
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return resp.Data.Alert, nil</span>
}

// AdminProbeAlert represents a probe alert with additional organization information (admin view)
type AdminProbeAlert struct {
        ProbeAlert
        OrganizationName string `json:"organization_name"`
        OrganizationID   uint   `json:"organization_id"`
        ProbeName        string `json:"probe_name"`
        ProbeType        string `json:"probe_type"`
        ProbeTarget      string `json:"probe_target"`
}

// AdminProbeAlertListOptions represents options for listing probe alerts as admin
type AdminProbeAlertListOptions struct {
        ListOptions
        Status         string // Filter by status
        OrganizationID int    // Filter by organization
}

// ToQuery converts AdminProbeAlertListOptions to query parameters
func (opts *AdminProbeAlertListOptions) ToQuery() map[string]string <span class="cov8" title="1">{
        params := opts.ListOptions.ToQuery()

        if opts.Status != "" </span><span class="cov0" title="0">{
                params["status"] = opts.Status
        }</span>
        <span class="cov8" title="1">if opts.OrganizationID &gt; 0 </span><span class="cov8" title="1">{
                params["organization_id"] = fmt.Sprintf("%d", opts.OrganizationID)
        }</span>

        <span class="cov8" title="1">return params</span>
}

// ListAdmin retrieves all probe alerts across all organizations (admin only)
func (s *ProbeAlertsService) ListAdmin(ctx context.Context, opts *AdminProbeAlertListOptions) ([]*AdminProbeAlert, *PaginationMeta, error) <span class="cov8" title="1">{
        var resp struct {
                Status  string `json:"status"`
                Message string `json:"message"`
                Data    struct {
                        Alerts     []*AdminProbeAlert `json:"alerts"`
                        Pagination *PaginationMeta    `json:"pagination"`
                } `json:"data"`
        }

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/admin/probe-alerts",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov8" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov8" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return resp.Data.Alerts, resp.Data.Pagination, nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
        "time"
)

// ProbeControllerService handles probe controller operations for orchestrating
// probe executions across regional monitoring nodes. This service manages
// assignments, regional results, consensus calculations, and health state tracking.
//
// This service is designed for internal controller-to-API communication and requires
// appropriate authentication (monitoring key or API key/secret).
type ProbeControllerService struct {
        client *Client
}

// ProbeControllerAssignment represents a probe execution assignment that links
// a probe to a specific monitoring node in a region for execution.
type ProbeControllerAssignment struct {
        ID               uint       `json:"id"`
        ProbeID          uint       `json:"probe_id"`
        ProbeUUID        string     `json:"probe_uuid"`
        MonitoringNodeID *uint      `json:"monitoring_node_id"`
        Region           string     `json:"region"`
        AssignedAt       time.Time  `json:"assigned_at"`
        LastExecution    *time.Time `json:"last_execution"`
        Status           string     `json:"status"`
        CreatedAt        time.Time  `json:"created_at"`
        UpdatedAt        time.Time  `json:"updated_at"`
}

// ProbeControllerAssignmentCreateRequest contains the fields required to create
// a new probe execution assignment.
type ProbeControllerAssignmentCreateRequest struct {
        ProbeID          uint   `json:"probe_id"`
        ProbeUUID        string `json:"probe_uuid"`
        MonitoringNodeID *uint  `json:"monitoring_node_id,omitempty"`
        Region           string `json:"region"`
        Status           string `json:"status,omitempty"`
}

// ProbeControllerAssignmentUpdateRequest contains the fields that can be updated
// on an existing probe execution assignment.
type ProbeControllerAssignmentUpdateRequest struct {
        MonitoringNodeID *uint  `json:"monitoring_node_id,omitempty"`
        Status           string `json:"status,omitempty"`
}

// ProbeControllerAssignmentListOptions provides filtering options when listing
// probe execution assignments. All fields are optional - use nil to skip filtering.
type ProbeControllerAssignmentListOptions struct {
        ProbeUUID        *string
        Region           *string
        Status           *string
        MonitoringNodeID *uint
}

// ProbeControllerRegionalResult represents the execution result from a single
// monitoring region for a probe. These results are aggregated by the consensus
// engine to determine global probe status.
type ProbeControllerRegionalResult struct {
        ID               uint       `json:"id"`
        ProbeUUID        string     `json:"probe_uuid"`
        Region           string     `json:"region"`
        Status           string     `json:"status"`
        ResponseTime     *int       `json:"response_time"`
        Success          bool       `json:"success"`
        ErrorMessage     *string    `json:"error_message"`
        IsCustomerRegion bool       `json:"is_customer_region"`
        AgentID          *string    `json:"agent_id"`
        Timestamp        time.Time  `json:"timestamp"`
        ExpiresAt        *time.Time `json:"expires_at"`
        CreatedAt        time.Time  `json:"created_at"`
}

// ProbeControllerRegionalResultStoreRequest contains the fields required to store
// a regional probe execution result. The TTLSeconds field controls how long the
// result is kept before expiration.
type ProbeControllerRegionalResultStoreRequest struct {
        ProbeUUID        string  `json:"probe_uuid"`
        Region           string  `json:"region"`
        Status           string  `json:"status"`
        ResponseTime     *int    `json:"response_time,omitempty"`
        Success          bool    `json:"success"`
        ErrorMessage     *string `json:"error_message,omitempty"`
        IsCustomerRegion bool    `json:"is_customer_region"`
        AgentID          *string `json:"agent_id,omitempty"`
        TTLSeconds       int     `json:"ttl_seconds,omitempty"`
}

// ProbeControllerRegionalResultListOptions provides filtering options when listing
// regional probe execution results. All fields are optional - use nil to skip filtering.
type ProbeControllerRegionalResultListOptions struct {
        Region           *string
        Status           *string
        IsCustomerRegion *bool
        Since            *string
}

// ProbeControllerConsensusResult represents the aggregated consensus calculation
// from all regional probe execution results. This determines the global status
// and whether alerts should be triggered.
type ProbeControllerConsensusResult struct {
        ID              uint      `json:"id"`
        ProbeID         uint      `json:"probe_id"`
        ProbeUUID       string    `json:"probe_uuid"`
        GlobalStatus    string    `json:"global_status"`
        ConsensusType   string    `json:"consensus_type"`
        ShouldAlert     bool      `json:"should_alert"`
        UpRegions       int       `json:"up_regions"`
        DownRegions     int       `json:"down_regions"`
        DegradedRegions int       `json:"degraded_regions"`
        UnknownRegions  int       `json:"unknown_regions"`
        TotalRegions    int       `json:"total_regions"`
        ConsensusRatio  float64   `json:"consensus_ratio"`
        CalculatedAt    time.Time `json:"calculated_at"`
        AlertTriggered  bool      `json:"alert_triggered"`
        CreatedAt       time.Time `json:"created_at"`
        UpdatedAt       time.Time `json:"updated_at"`
}

// ProbeControllerConsensusResultStoreRequest contains the fields required to store
// a consensus calculation result. This is typically called after the consensus engine
// aggregates all regional results for a probe.
type ProbeControllerConsensusResultStoreRequest struct {
        ProbeID         uint    `json:"probe_id"`
        ProbeUUID       string  `json:"probe_uuid"`
        GlobalStatus    string  `json:"global_status"`
        ConsensusType   string  `json:"consensus_type"`
        ShouldAlert     bool    `json:"should_alert"`
        UpRegions       int     `json:"up_regions"`
        DownRegions     int     `json:"down_regions"`
        DegradedRegions int     `json:"degraded_regions"`
        UnknownRegions  int     `json:"unknown_regions"`
        TotalRegions    int     `json:"total_regions"`
        ConsensusRatio  float64 `json:"consensus_ratio"`
        AlertTriggered  bool    `json:"alert_triggered"`
}

// ConsensusHistoryOptions provides filtering options when retrieving historical
// consensus results for a probe. All fields are optional - use nil to skip filtering.
type ConsensusHistoryOptions struct {
        Since *string
        Limit *int
}

// ProbeControllerHealthState represents a key-value health state entry for
// the probe controller. This can be used to track controller status, metrics,
// or operational information.
type ProbeControllerHealthState struct {
        ID        uint      `json:"id"`
        Key       string    `json:"key"`
        Value     string    `json:"value"`
        UpdatedAt time.Time `json:"updated_at"`
}

// ProbeControllerHealthUpdateRequest contains the fields required to update
// or create a health state entry.
type ProbeControllerHealthUpdateRequest struct {
        Key   string `json:"key"`
        Value string `json:"value"`
}

// CreateAssignment creates a new probe execution assignment, linking a probe to a
// specific monitoring node in a region. This is used by the controller to distribute
// probe execution work across the monitoring infrastructure.
//
// Example:
//
//        assignment, err := client.ProbeController.CreateAssignment(ctx, &amp;nexmonyx.ProbeControllerAssignmentCreateRequest{
//            ProbeID:   123,
//            ProbeUUID: "probe-uuid-here",
//            Region:    "us-east-1",
//            Status:    "active",
//        })
func (s *ProbeControllerService) CreateAssignment(ctx context.Context, req *ProbeControllerAssignmentCreateRequest) (*ProbeControllerAssignment, error) <span class="cov10" title="3">{
        // Validate required fields
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request cannot be nil")
        }</span>
        <span class="cov10" title="3">if req.ProbeID == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("probe_id is required")
        }</span>
        <span class="cov10" title="3">if req.ProbeUUID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("probe_uuid is required")
        }</span>
        <span class="cov10" title="3">if req.Region == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("region is required")
        }</span>

        <span class="cov10" title="3">var result struct {
                Status  string                     `json:"status"`
                Data    *ProbeControllerAssignment `json:"data"`
                Message string                     `json:"message"`
        }
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/controllers/probe/assignments",
                Body:   req,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov6" title="2">return result.Data, nil</span>
}

// ListAssignments retrieves probe execution assignments with optional filtering.
// Use the options parameter to filter by probe UUID, region, status, or monitoring node.
//
// Example:
//
//        assignments, err := client.ProbeController.ListAssignments(ctx, &amp;nexmonyx.ProbeControllerAssignmentListOptions{
//            ProbeUUID: "probe-uuid-here",
//            Region:    "us-east-1",
//            Status:    "active",
//        })
func (s *ProbeControllerService) ListAssignments(ctx context.Context, opts *ProbeControllerAssignmentListOptions) ([]*ProbeControllerAssignment, error) <span class="cov10" title="3">{
        var result struct {
                Status  string                       `json:"status"`
                Data    []*ProbeControllerAssignment `json:"data"`
                Message string                       `json:"message"`
        }
        query := make(map[string]string)
        if opts != nil </span><span class="cov6" title="2">{
                if opts.ProbeUUID != nil &amp;&amp; *opts.ProbeUUID != "" </span><span class="cov6" title="2">{
                        query["probe_uuid"] = *opts.ProbeUUID
                }</span>
                <span class="cov6" title="2">if opts.Region != nil &amp;&amp; *opts.Region != "" </span><span class="cov1" title="1">{
                        query["region"] = *opts.Region
                }</span>
                <span class="cov6" title="2">if opts.Status != nil &amp;&amp; *opts.Status != "" </span><span class="cov1" title="1">{
                        query["status"] = *opts.Status
                }</span>
                <span class="cov6" title="2">if opts.MonitoringNodeID != nil </span><span class="cov0" title="0">{
                        query["monitoring_node_id"] = fmt.Sprintf("%d", *opts.MonitoringNodeID)
                }</span>
        }
        <span class="cov10" title="3">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/controllers/probe/assignments",
                Query:  query,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="3">return result.Data, nil</span>
}

// UpdateAssignment updates an existing probe execution assignment. This can be used
// to change the assigned monitoring node or update the assignment status.
//
// Example:
//
//        newNodeID := uint(456)
//        assignment, err := client.ProbeController.UpdateAssignment(ctx, assignmentID, &amp;nexmonyx.ProbeControllerAssignmentUpdateRequest{
//            MonitoringNodeID: &amp;newNodeID,
//            Status:           "paused",
//        })
func (s *ProbeControllerService) UpdateAssignment(ctx context.Context, id uint, req *ProbeControllerAssignmentUpdateRequest) (*ProbeControllerAssignment, error) <span class="cov6" title="2">{
        // Validate required fields
        if id == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assignment id is required")
        }</span>
        <span class="cov6" title="2">if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request cannot be nil")
        }</span>

        <span class="cov6" title="2">var result struct {
                Status  string                     `json:"status"`
                Data    *ProbeControllerAssignment `json:"data"`
                Message string                     `json:"message"`
        }
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/controllers/probe/assignments/%d", id),
                Body:   req,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">return result.Data, nil</span>
}

// DeleteAssignment removes a probe execution assignment. This unassigns the probe
// from its monitoring node in the specified region. The deleted assignment is returned.
//
// Example:
//
//        deletedAssignment, err := client.ProbeController.DeleteAssignment(ctx, assignmentID)
func (s *ProbeControllerService) DeleteAssignment(ctx context.Context, id uint) (*ProbeControllerAssignment, error) <span class="cov1" title="1">{
        // Validate required fields
        if id == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("assignment id is required")
        }</span>

        <span class="cov1" title="1">var result struct {
                Status  string                     `json:"status"`
                Data    *ProbeControllerAssignment `json:"data"`
                Message string                     `json:"message"`
        }
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/controllers/probe/assignments/%d", id),
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return result.Data, nil</span>
}

// StoreRegionalResult stores a probe execution result from a specific region.
// These regional results are used by the consensus engine to calculate global probe status.
// The TTLSeconds field controls how long the result is retained.
//
// Example:
//
//        responseTime := 150
//        result, err := client.ProbeController.StoreRegionalResult(ctx, &amp;nexmonyx.ProbeControllerRegionalResultStoreRequest{
//            ProbeUUID:        "probe-uuid-here",
//            Region:           "us-east-1",
//            Status:           "up",
//            ResponseTime:     &amp;responseTime,
//            Success:          true,
//            IsCustomerRegion: false,
//            TTLSeconds:       3600, // 1 hour
//        })
func (s *ProbeControllerService) StoreRegionalResult(ctx context.Context, req *ProbeControllerRegionalResultStoreRequest) (*ProbeControllerRegionalResult, error) <span class="cov6" title="2">{
        // Validate required fields
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request cannot be nil")
        }</span>
        <span class="cov6" title="2">if req.ProbeUUID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("probe_uuid is required")
        }</span>
        <span class="cov6" title="2">if req.Region == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("region is required")
        }</span>
        <span class="cov6" title="2">if req.Status == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("status is required")
        }</span>

        <span class="cov6" title="2">var result struct {
                Status  string                         `json:"status"`
                Data    *ProbeControllerRegionalResult `json:"data"`
                Message string                         `json:"message"`
        }
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/controllers/probe/results/regional",
                Body:   req,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">return result.Data, nil</span>
}

// GetRegionalResults retrieves regional probe execution results for a specific probe.
// This is used by the consensus engine to aggregate results from all regions and
// calculate global probe status. Use options to filter by region, status, or customer regions.
//
// Example:
//
//        results, err := client.ProbeController.GetRegionalResults(ctx, "probe-uuid-here", &amp;nexmonyx.ProbeControllerRegionalResultListOptions{
//            Region: "us-east-1",
//            Since:  "2024-01-01T00:00:00Z",
//        })
func (s *ProbeControllerService) GetRegionalResults(ctx context.Context, probeUUID string, opts *ProbeControllerRegionalResultListOptions) ([]*ProbeControllerRegionalResult, error) <span class="cov10" title="3">{
        // Validate required fields
        if probeUUID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("probe_uuid is required")
        }</span>

        <span class="cov10" title="3">var result struct {
                Status  string                           `json:"status"`
                Data    []*ProbeControllerRegionalResult `json:"data"`
                Message string                           `json:"message"`
        }
        query := make(map[string]string)
        if opts != nil </span><span class="cov6" title="2">{
                if opts.Region != nil &amp;&amp; *opts.Region != "" </span><span class="cov1" title="1">{
                        query["region"] = *opts.Region
                }</span>
                <span class="cov6" title="2">if opts.Status != nil &amp;&amp; *opts.Status != "" </span><span class="cov0" title="0">{
                        query["status"] = *opts.Status
                }</span>
                <span class="cov6" title="2">if opts.IsCustomerRegion != nil </span><span class="cov1" title="1">{
                        query["is_customer_region"] = fmt.Sprintf("%t", *opts.IsCustomerRegion)
                }</span>
                <span class="cov6" title="2">if opts.Since != nil &amp;&amp; *opts.Since != "" </span><span class="cov0" title="0">{
                        query["since"] = *opts.Since
                }</span>
        }
        <span class="cov10" title="3">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/controllers/probe/results/regional/%s", probeUUID),
                Query:  query,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov10" title="3">return result.Data, nil</span>
}

// StoreConsensusResult stores a consensus calculation result after aggregating all
// regional execution results for a probe. This determines the global probe status
// and whether alerts should be triggered.
//
// Example:
//
//        consensus, err := client.ProbeController.StoreConsensusResult(ctx, &amp;nexmonyx.ProbeControllerConsensusResultStoreRequest{
//            ProbeID:         123,
//            ProbeUUID:       "probe-uuid-here",
//            GlobalStatus:    "up",
//            ConsensusType:   "majority",
//            ShouldAlert:     false,
//            UpRegions:       3,
//            DownRegions:     0,
//            TotalRegions:    3,
//            ConsensusRatio:  1.0,
//            AlertTriggered:  false,
//        })
func (s *ProbeControllerService) StoreConsensusResult(ctx context.Context, req *ProbeControllerConsensusResultStoreRequest) (*ProbeControllerConsensusResult, error) <span class="cov6" title="2">{
        // Validate required fields
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request cannot be nil")
        }</span>
        <span class="cov6" title="2">if req.ProbeID == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("probe_id is required")
        }</span>
        <span class="cov6" title="2">if req.ProbeUUID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("probe_uuid is required")
        }</span>
        <span class="cov6" title="2">if req.GlobalStatus == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("global_status is required")
        }</span>
        <span class="cov6" title="2">if req.ConsensusType == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("consensus_type is required")
        }</span>

        <span class="cov6" title="2">var result struct {
                Status  string                          `json:"status"`
                Data    *ProbeControllerConsensusResult `json:"data"`
                Message string                          `json:"message"`
        }
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/controllers/probe/results/consensus",
                Body:   req,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">return result.Data, nil</span>
}

// GetConsensusHistory retrieves historical consensus calculation results for a probe.
// This can be used to analyze probe health trends over time and understand alerting patterns.
//
// Example:
//
//        history, err := client.ProbeController.GetConsensusHistory(ctx, "probe-uuid-here", &amp;nexmonyx.ConsensusHistoryOptions{
//            Since: "2024-01-01T00:00:00Z",
//            Limit: 100,
//        })
func (s *ProbeControllerService) GetConsensusHistory(ctx context.Context, probeUUID string, opts *ConsensusHistoryOptions) ([]*ProbeControllerConsensusResult, error) <span class="cov1" title="1">{
        // Validate required fields
        if probeUUID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("probe_uuid is required")
        }</span>

        <span class="cov1" title="1">var result struct {
                Status  string                            `json:"status"`
                Data    []*ProbeControllerConsensusResult `json:"data"`
                Message string                            `json:"message"`
        }
        query := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Since != nil &amp;&amp; *opts.Since != "" </span><span class="cov0" title="0">{
                        query["since"] = *opts.Since
                }</span>
                <span class="cov1" title="1">if opts.Limit != nil &amp;&amp; *opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        query["limit"] = fmt.Sprintf("%d", *opts.Limit)
                }</span>
        }
        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/controllers/probe/results/consensus/%s", probeUUID),
                Query:  query,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return result.Data, nil</span>
}

// UpdateHealthState updates or creates a health state entry for the probe controller.
// This can be used to track controller status, metrics, or operational information.
// Each entry is identified by a unique key.
//
// Example:
//
//        state, err := client.ProbeController.UpdateHealthState(ctx, &amp;nexmonyx.ProbeControllerHealthUpdateRequest{
//            Key:   "controller_status",
//            Value: "healthy",
//        })
func (s *ProbeControllerService) UpdateHealthState(ctx context.Context, req *ProbeControllerHealthUpdateRequest) (*ProbeControllerHealthState, error) <span class="cov6" title="2">{
        // Validate required fields
        if req == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request cannot be nil")
        }</span>
        <span class="cov6" title="2">if req.Key == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key is required")
        }</span>

        <span class="cov6" title="2">var result struct {
                Status  string                      `json:"status"`
                Data    *ProbeControllerHealthState `json:"data"`
                Message string                      `json:"message"`
        }
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   "/v1/controllers/probe/health",
                Body:   req,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov6" title="2">return result.Data, nil</span>
}

// GetHealthStates retrieves all health state entries for the probe controller.
// This returns all key-value pairs tracking controller status and operational metrics.
//
// Example:
//
//        states, err := client.ProbeController.GetHealthStates(ctx)
//        for _, state := range states {
//            fmt.Printf("Key: %s, Value: %s, Updated: %s\n", state.Key, state.Value, state.UpdatedAt)
//        }
func (s *ProbeControllerService) GetHealthStates(ctx context.Context) ([]*ProbeControllerHealthState, error) <span class="cov1" title="1">{
        var result struct {
                Status  string                        `json:"status"`
                Data    []*ProbeControllerHealthState `json:"data"`
                Message string                        `json:"message"`
        }
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/controllers/probe/health",
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return result.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// ProbesService is defined in client.go

// Create creates a new probe
func (s *ProbesService) Create(ctx context.Context, req *ProbeCreateRequest) (*MonitoringProbe, error) <span class="cov9" title="6">{
        // Convert ProbeCreateRequest to map to match API expectations
        config := make(map[string]interface{})

        // Based on probe type, set appropriate config fields
        switch req.Type </span>{
        case "icmp":<span class="cov4" title="2">
                if req.Target != "" </span><span class="cov1" title="1">{
                        config["host"] = req.Target
                }</span>
        case "http", "https":<span class="cov4" title="2">
                if req.Target != "" </span><span class="cov4" title="2">{
                        config["url"] = req.Target
                }</span>
        case "tcp":<span class="cov1" title="1">
                if req.Target != "" </span><span class="cov1" title="1">{
                        config["host"] = req.Target
                }</span>
                <span class="cov1" title="1">if tcpPort, ok := req.Configuration["port"]; ok </span><span class="cov1" title="1">{
                        config["port"] = tcpPort
                }</span>
        case "heartbeat":<span class="cov1" title="1">
                if req.Target != "" </span><span class="cov1" title="1">{
                        config["url"] = req.Target
                }</span>
        }

        // Add any additional config from the request
        <span class="cov9" title="6">if req.Configuration != nil </span><span class="cov4" title="2">{
                for k, v := range req.Configuration </span><span class="cov6" title="3">{
                        config[k] = v
                }</span>
        }

        // Create the request body matching API expectations
        <span class="cov9" title="6">body := map[string]interface{}{
                "name":      req.Name,
                "type":      req.Type,
                "frequency": req.Interval,             // API expects "frequency", SDK has "interval"
                "regions":   []string{req.RegionCode}, // Convert single region to array
                "enabled":   req.Enabled,
                "config":    config,
        }

        // Add description if provided
        if req.Name != "" </span><span class="cov9" title="6">{
                body["description"] = req.Name // Use name as description if not provided
        }</span>

        <span class="cov9" title="6">var result struct {
                Status string `json:"status"`
                Data   struct {
                        Probe MonitoringProbe `json:"probe"`
                } `json:"data"`
                Message string `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/probes",
                Body:   body,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="5">return &amp;result.Data.Probe, nil</span>
}

// List returns all probes
func (s *ProbesService) List(ctx context.Context, opts *ListOptions) ([]*MonitoringProbe, *PaginationMeta, error) <span class="cov6" title="3">{
        return s.client.Monitoring.ListProbes(ctx, opts)
}</span>

// Get retrieves a probe by UUID
func (s *ProbesService) Get(ctx context.Context, uuid string) (*MonitoringProbe, error) <span class="cov10" title="7">{
        return s.client.Monitoring.GetProbe(ctx, uuid)
}</span>

// Update updates a probe
func (s *ProbesService) Update(ctx context.Context, uuid string, req *ProbeUpdateRequest) (*MonitoringProbe, error) <span class="cov8" title="5">{
        probe := &amp;MonitoringProbe{}

        if req.Name != nil </span><span class="cov6" title="3">{
                probe.Name = *req.Name
        }</span>
        <span class="cov8" title="5">if req.Enabled != nil </span><span class="cov4" title="2">{
                probe.Enabled = *req.Enabled
        }</span>
        <span class="cov8" title="5">if req.Interval != nil </span><span class="cov4" title="2">{
                probe.Interval = *req.Interval
        }</span>
        <span class="cov8" title="5">if req.Configuration != nil </span><span class="cov1" title="1">{
                probe.Config = req.Configuration
        }</span>

        <span class="cov8" title="5">return s.client.Monitoring.UpdateProbe(ctx, uuid, probe)</span>
}

// Delete removes a probe
func (s *ProbesService) Delete(ctx context.Context, uuid string) error <span class="cov6" title="3">{
        return s.client.Monitoring.DeleteProbe(ctx, uuid)
}</span>

// GetHealth returns the health status of a probe
func (s *ProbesService) GetHealth(ctx context.Context, uuid string) (*ProbeHealth, error) <span class="cov6" title="3">{
        var result struct {
                Status string       `json:"status"`
                Data   *ProbeHealth `json:"data"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/probes/%s/health", uuid),
                Result: &amp;result,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return result.Data, nil</span>
}

// ListResults returns probe execution results
func (s *ProbesService) ListResults(ctx context.Context, uuid string, opts *ProbeResultListOptions) ([]*ProbeResult, *PaginationMeta, error) <span class="cov4" title="2">{
        return s.client.Monitoring.ListProbeResults(ctx, opts)
}</span>

// GetAvailableRegions returns available monitoring regions
func (s *ProbesService) GetAvailableRegions(ctx context.Context) ([]*MonitoringRegion, error) <span class="cov6" title="3">{
        var result struct {
                Status string              `json:"status"`
                Data   []*MonitoringRegion `json:"data"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/monitoring/regions",
                Result: &amp;result,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return result.Data, nil</span>
}

// GetAvailableProbeTypes returns available probe types
func (s *ProbesService) GetAvailableProbeTypes(ctx context.Context) ([]string, error) <span class="cov1" title="1">{
        // For now, return static list
        return []string{"icmp", "http", "https", "tcp", "heartbeat"}, nil
}</span>

// CreateSimpleProbe creates a probe with simpler parameters
func (s *ProbesService) CreateSimpleProbe(ctx context.Context, name, probeType, target string, regions []string) (*MonitoringProbe, error) <span class="cov9" title="6">{
        // Convert to API format
        config := make(map[string]interface{})

        // Based on probe type, set appropriate config fields
        switch probeType </span>{
        case "icmp":<span class="cov1" title="1">
                config["host"] = target</span>
        case "http", "https":<span class="cov6" title="3">
                config["url"] = target</span>
        case "tcp":<span class="cov1" title="1">
                config["host"] = target
                config["port"] = 80</span> // Default port
        case "heartbeat":<span class="cov1" title="1">
                config["url"] = target</span>
        }

        // Create the request body matching API expectations
        <span class="cov9" title="6">body := map[string]interface{}{
                "name":        name,
                "description": name,
                "type":        probeType,
                "frequency":   300, // 5 minutes default
                "regions":     regions,
                "enabled":     true,
                "config":      config,
        }

        var result struct {
                Status string `json:"status"`
                Data   struct {
                        Probe MonitoringProbe `json:"probe"`
                } `json:"data"`
                Message string `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/probes",
                Body:   body,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="5">return &amp;result.Data.Probe, nil</span>
}

// ProbeHealth represents probe health status
type ProbeHealth struct {
        ProbeUUID       string               `json:"probe_uuid"`
        Name            string               `json:"name"`
        Type            string               `json:"type"`
        Target          string               `json:"target"`
        Enabled         bool                 `json:"enabled"`
        LastStatus      string               `json:"last_status"`
        LastRun         string               `json:"last_run,omitempty"`
        HealthScore     float64              `json:"health_score"`
        Availability24h float64              `json:"availability_24h"`
        AverageResponse int                  `json:"average_response_ms"`
        RegionStatus    []RegionHealthStatus `json:"region_status,omitempty"`
}

// RegionHealthStatus represents health status for a specific region
type RegionHealthStatus struct {
        Region          string  `json:"region"`
        RegionName      string  `json:"region_name"`
        LastStatus      string  `json:"last_status"`
        LastRun         string  `json:"last_run,omitempty"`
        Availability24h float64 `json:"availability_24h"`
        AverageResponse int     `json:"average_response_ms"`
}

// ========================================
// CONTROLLER-SPECIFIC METHODS
// ========================================
// These methods are used by probe-controller for orchestration.
// They require monitoring key authentication and are designed for
// internal controller-to-API communication.

// ListByOrganization retrieves all probes for a specific organization
// This method is used by probe-controller to load probe assignments on startup.
// It requires monitoring key authentication and is typically called once during
// controller initialization to populate the probe scheduler.
func (s *ProbesService) ListByOrganization(ctx context.Context, organizationID uint) ([]*MonitoringProbe, error) <span class="cov8" title="5">{
        var result struct {
                Status string             `json:"status"`
                Data   []*MonitoringProbe `json:"data"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/controllers/probes/list",
                Query:  map[string]string{"org_id": fmt.Sprintf("%d", organizationID)},
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list probes for organization %d: %w", organizationID, err)
        }</span>

        <span class="cov8" title="5">return result.Data, nil</span>
}

// GetByUUID retrieves a specific probe by its UUID
// This method is used by probe-controller to fetch probe details.
// It's a convenience wrapper around the standard Get method for consistency
// with other controller-specific methods.
func (s *ProbesService) GetByUUID(ctx context.Context, probeUUID string) (*MonitoringProbe, error) <span class="cov8" title="5">{
        probe, err := s.Get(ctx, probeUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get probe %s: %w", probeUUID, err)
        }</span>
        <span class="cov8" title="5">return probe, nil</span>
}

// GetRegionalResults retrieves recent regional execution results for a probe
// This method is used by consensus engine to calculate global status.
// It returns the latest execution result from each monitoring region for the
// specified probe, which the consensus engine uses to determine overall probe health.
func (s *ProbesService) GetRegionalResults(ctx context.Context, probeUUID string) ([]RegionalResult, error) <span class="cov4" title="2">{
        var result struct {
                Status string           `json:"status"`
                Data   []RegionalResult `json:"data"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/controllers/probes/%s/regional-results", probeUUID),
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get regional results for probe %s: %w", probeUUID, err)
        }</span>

        <span class="cov4" title="2">return result.Data, nil</span>
}

// UpdateControllerStatus updates the probe status from controller
// This method is used by probe-controller to update probe execution status.
// Valid status values are: "up", "down", "degraded", "unknown"
// This should be called after the consensus engine calculates the global status.
func (s *ProbesService) UpdateControllerStatus(ctx context.Context, probeUUID string, status string) error <span class="cov8" title="5">{
        // Validate status
        validStatuses := map[string]bool{
                "up":       true,
                "down":     true,
                "degraded": true,
                "unknown":  true,
        }
        if !validStatuses[status] </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid status '%s' for probe %s: must be one of: up, down, degraded, unknown", status, probeUUID)
        }</span>

        <span class="cov7" title="4">body := map[string]interface{}{
                "status": status,
        }

        var result struct {
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/controllers/probes/%s/status", probeUUID),
                Body:   body,
                Result: &amp;result,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update status to '%s' for probe %s: %w", status, probeUUID, err)
        }</span>

        <span class="cov7" title="4">return nil</span>
}

// GetProbeConfig retrieves probe configuration including consensus type
// This method is used by consensus engine to determine consensus algorithm
//
// UUID Handling: MonitoringProbe uses GormModel which only has an ID field.
// The probeUUID parameter is used to set ProbeConfiguration.ProbeUUID since
// the MonitoringProbe struct doesn't contain a UUID field.
//
// Default Consensus: If the probe's config doesn't specify a consensus_type,
// this method defaults to "majority" consensus. Valid consensus types are:
// - "majority": Probe is UP if more than 50% of regions report UP
// - "all": Probe is UP only if ALL regions report UP
// - "any": Probe is UP if ANY region reports UP
func (s *ProbesService) GetProbeConfig(ctx context.Context, probeUUID string) (*ProbeConfiguration, error) <span class="cov7" title="4">{
        probe, err := s.GetByUUID(ctx, probeUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get config for probe %s: %w", probeUUID, err)
        }</span>

        // Convert MonitoringProbe to ProbeConfiguration
        <span class="cov7" title="4">config := &amp;ProbeConfiguration{
                ProbeUUID:     probeUUID, // Use the provided UUID parameter (see UUID Handling above)
                Name:          probe.Name,
                Type:          probe.Type,
                Target:        probe.Target,
                Interval:      probe.Interval,
                Timeout:       probe.Timeout,
                Regions:       probe.Regions,
                ConsensusType: "majority", // Default consensus type (see Default Consensus above)
        }

        // Extract consensus type from probe config if present
        if probe.Config != nil </span><span class="cov4" title="2">{
                if consensusType, ok := probe.Config["consensus_type"].(string); ok </span><span class="cov4" title="2">{
                        config.ConsensusType = consensusType
                }</span>
        }

        <span class="cov7" title="4">return config, nil</span>
}

// RecordConsensusResult stores a consensus calculation result
// This method is used by consensus engine to persist global status.
// It records the complete consensus calculation including regional results,
// statistics, and whether an alert should be triggered. This creates a historical
// record for reporting and debugging consensus decisions.
func (s *ProbesService) RecordConsensusResult(ctx context.Context, result *ConsensusResultRequest) error <span class="cov7" title="4">{
        if result == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("consensus result cannot be nil")
        }</span>
        <span class="cov6" title="3">if result.ProbeUUID == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("probe UUID is required in consensus result")
        }</span>

        <span class="cov4" title="2">var resp struct {
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/controllers/probes/consensus-results",
                Body:   result,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to record consensus result for probe %s: %w", result.ProbeUUID, err)
        }</span>

        <span class="cov4" title="2">return nil</span>
}

// GetActiveProbes retrieves all active (enabled) probes for an organization
// This method is used by probe-controller to get probes that should be actively monitored.
// It filters for enabled=true and deleted_at IS NULL, returning only probes that
// should be executing according to their configured schedules.
//
// This is a convenience method that filters the results of ListByOrganization to
// return only probes that are currently active and should be scheduled for execution.
func (s *ProbesService) GetActiveProbes(ctx context.Context, organizationID uint) ([]*MonitoringProbe, error) <span class="cov6" title="3">{
        // Get all probes for the organization
        allProbes, err := s.ListByOrganization(ctx, organizationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list probes for organization %d: %w", organizationID, err)
        }</span>

        // Filter for active (enabled) probes only
        <span class="cov6" title="3">activeProbes := make([]*MonitoringProbe, 0, len(allProbes))
        for _, probe := range allProbes </span><span class="cov10" title="7">{
                if probe.Enabled </span><span class="cov7" title="4">{
                        activeProbes = append(activeProbes, probe)
                }</span>
        }

        <span class="cov6" title="3">return activeProbes, nil</span>
}

// SubmitResult submits a single probe execution result
// This is a convenience wrapper around Monitoring.SubmitResults for submitting a
// single probe result. For bulk submissions, use client.Monitoring.SubmitResults directly.
//
// Example usage:
//
//        result := &amp;nexmonyx.ProbeExecutionResult{
//            ProbeID:      probe.ID,
//            ProbeUUID:    probe.ProbeUUID,
//            ExecutedAt:   time.Now(),
//            Region:       "us-east-1",
//            Status:       "success",
//            ResponseTime: 150,
//            StatusCode:   200,
//        }
//        err := client.Probes.SubmitResult(ctx, result)
func (s *ProbesService) SubmitResult(ctx context.Context, result *ProbeExecutionResult) error <span class="cov7" title="4">{
        if result == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("probe result cannot be nil")
        }</span>
        <span class="cov6" title="3">if result.ProbeUUID == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("probe UUID is required in result")
        }</span>

        // Use the Monitoring service's SubmitResults method for a single result
        <span class="cov4" title="2">return s.client.Monitoring.SubmitResults(ctx, []ProbeExecutionResult{*result})</span>
}

// ========================================
// CONTROLLER-SPECIFIC TYPES
// ========================================

// RegionalResult represents the status from a single monitoring region
type RegionalResult struct {
        Region       string  `json:"region"`
        Status       string  `json:"status"`
        ResponseTime int     `json:"response_time"`
        ErrorMessage *string `json:"error_message,omitempty"`
        CheckedAt    string  `json:"checked_at"`
}

// ProbeConfiguration represents probe configuration for controller use
type ProbeConfiguration struct {
        ProbeUUID     string   `json:"probe_uuid"`
        Name          string   `json:"name"`
        Type          string   `json:"type"`
        Target        string   `json:"target"`
        Interval      int      `json:"interval"`
        Timeout       int      `json:"timeout"`
        Regions       []string `json:"regions"`
        ConsensusType string   `json:"consensus_type"` // "majority", "all", "any"
}

// ConsensusResultRequest represents a consensus result to be recorded
type ConsensusResultRequest struct {
        ProbeUUID           string           `json:"probe_uuid"`
        OrganizationID      uint             `json:"organization_id"`
        ConsensusType       string           `json:"consensus_type"`
        GlobalStatus        string           `json:"global_status"`
        RegionResults       []RegionalResult `json:"region_results"`
        TotalRegions        int              `json:"total_regions"`
        UpRegions           int              `json:"up_regions"`
        DownRegions         int              `json:"down_regions"`
        DegradedRegions     int              `json:"degraded_regions"`
        UnknownRegions      int              `json:"unknown_regions"`
        ShouldAlert         bool             `json:"should_alert"`
        AverageResponseTime int              `json:"average_response_time"`
        MinResponseTime     int              `json:"min_response_time"`
        MaxResponseTime     int              `json:"max_response_time"`
        UptimePercentage    float64          `json:"uptime_percentage"`
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
        "time"
)

// List retrieves a list of providers
func (s *ProvidersService) List(ctx context.Context, opts *ProviderListOptions) (*ProviderListResponse, *PaginationMeta, error) <span class="cov8" title="1">{
        var resp PaginatedResponse
        var providerResponse ProviderListResponse
        resp.Data = &amp;providerResponse

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/providers",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov8" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov8" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">return &amp;providerResponse, resp.Meta, nil</span>
}

// Create creates a new provider
func (s *ProvidersService) Create(ctx context.Context, req *ProviderCreateRequest) (*Provider, *Response, error) <span class="cov8" title="1">{
        var resp StandardResponse
        resp.Data = &amp;Provider{}

        apiResp, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/providers",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">if provider, ok := resp.Data.(*Provider); ok </span><span class="cov8" title="1">{
                return provider, apiResp, nil
        }</span>
        <span class="cov0" title="0">return nil, apiResp, fmt.Errorf("unexpected response type")</span>
}

// Get retrieves a provider by ID
func (s *ProvidersService) Get(ctx context.Context, providerID string) (*Provider, error) <span class="cov8" title="1">{
        var resp StandardResponse
        resp.Data = &amp;Provider{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/providers/%s", providerID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if provider, ok := resp.Data.(*Provider); ok </span><span class="cov8" title="1">{
                return provider, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// Update updates a provider
func (s *ProvidersService) Update(ctx context.Context, providerID string, req *ProviderUpdateRequest) (*Provider, error) <span class="cov8" title="1">{
        var resp StandardResponse
        resp.Data = &amp;Provider{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/providers/%s", providerID),
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if provider, ok := resp.Data.(*Provider); ok </span><span class="cov8" title="1">{
                return provider, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// Delete deletes a provider
func (s *ProvidersService) Delete(ctx context.Context, providerID string) error <span class="cov8" title="1">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/providers/%s", providerID),
                Result: &amp;resp,
        })
        return err
}</span>

// Sync syncs a provider
func (s *ProvidersService) Sync(ctx context.Context, providerID string) (*SyncResponse, error) <span class="cov8" title="1">{
        var resp StandardResponse
        resp.Data = &amp;SyncResponse{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/providers/%s/sync", providerID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if syncResp, ok := resp.Data.(*SyncResponse); ok </span><span class="cov8" title="1">{
                return syncResp, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// Provider represents a cloud provider
type Provider struct {
        ID           string    `json:"id"`
        Name         string    `json:"name"`
        ProviderType string    `json:"provider_type"`
        Status       string    `json:"status"`
        VMCount      int       `json:"vm_count"`
        Region       string    `json:"region,omitempty"`
        Description  string    `json:"description,omitempty"`
        CreatedAt    time.Time `json:"created_at,omitempty"`
        UpdatedAt    time.Time `json:"updated_at,omitempty"`
}

// ProviderListResponse represents a response containing providers
type ProviderListResponse struct {
        Providers  []Provider `json:"providers"`
        Total      int        `json:"total"`
        Page       int        `json:"page"`
        PageSize   int        `json:"page_size"`
        TotalPages int        `json:"total_pages"`
}

// ProviderCreateRequest represents a request to create a provider
type ProviderCreateRequest struct {
        Name         string                 `json:"name"`
        ProviderType string                 `json:"provider_type"`
        Region       string                 `json:"region,omitempty"`
        Description  string                 `json:"description,omitempty"`
        Credentials  map[string]interface{} `json:"credentials,omitempty"`
}

// ProviderUpdateRequest represents a request to update a provider
type ProviderUpdateRequest struct {
        Name        string                 `json:"name,omitempty"`
        Description string                 `json:"description,omitempty"`
        Credentials map[string]interface{} `json:"credentials,omitempty"`
}

// SyncResponse represents the response from a sync operation
type SyncResponse struct {
        ID          string                 `json:"id,omitempty"`
        Success     bool                   `json:"success"`
        Message     string                 `json:"message"`
        Status      string                 `json:"status,omitempty"`
        ProviderID  string                 `json:"provider_id"`
        StartedAt   string                 `json:"started_at,omitempty"`
        SyncedAt    time.Time              `json:"synced_at"`
        SyncedVMs   int                    `json:"synced_vms"`
        VMsFound    int                    `json:"vms_found,omitempty"`
        VMsAdded    int                    `json:"vms_added,omitempty"`
        VMsUpdated  int                    `json:"vms_updated,omitempty"`
        VMsRemoved  int                    `json:"vms_removed,omitempty"`
        SyncResults map[string]interface{} `json:"sync_results,omitempty"`
}

// ProviderListOptions represents options for listing providers
type ProviderListOptions struct {
        Page     int    `url:"page,omitempty"`
        PageSize int    `url:"page_size,omitempty"`
        Status   string `url:"status,omitempty"`
        Type     string `url:"type,omitempty"`
}

// ToQuery converts options to query parameters
func (o *ProviderListOptions) ToQuery() map[string]string <span class="cov8" title="1">{
        params := make(map[string]string)
        if o.Page &gt; 0 </span><span class="cov8" title="1">{
                params["page"] = fmt.Sprintf("%d", o.Page)
        }</span>
        <span class="cov8" title="1">if o.PageSize &gt; 0 </span><span class="cov8" title="1">{
                params["page_size"] = fmt.Sprintf("%d", o.PageSize)
        }</span>
        <span class="cov8" title="1">if o.Status != "" </span><span class="cov8" title="1">{
                params["status"] = o.Status
        }</span>
        <span class="cov8" title="1">if o.Type != "" </span><span class="cov0" title="0">{
                params["type"] = o.Type
        }</span>
        <span class="cov8" title="1">return params</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
        "time"
)

// QuotaHistoryService handles quota usage history operations
type QuotaHistoryService struct{ client *Client }

// RecordQuotaUsage records quota usage metrics in batch
// Authentication: Admin JWT Token or API Key required
// Endpoint: POST /v1/admin/quota-history/record
// Parameters:
//   - records: Array of quota usage records to store
//
// This method is used by org-management-controller to submit quota usage metrics
// to the API for historical tracking and trend analysis.
func (s *QuotaHistoryService) RecordQuotaUsage(ctx context.Context, records []QuotaUsageRecord) error <span class="cov10" title="2">{
        var resp StandardResponse

        req := QuotaUsageRecordRequest{
                Records: records,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/admin/quota-history/record",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetHistoricalUsage retrieves historical quota usage records
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/quota-history/:org_id/usage
// Parameters:
//   - orgID: Organization ID to retrieve usage for
//   - resourceType: Optional resource type filter (cpu, memory, storage, etc.)
//   - startDate: Start of the time range (default: 7 days ago)
//   - endDate: End of the time range (default: now)
func (s *QuotaHistoryService) GetHistoricalUsage(ctx context.Context, orgID uint, resourceType string, startDate, endDate time.Time) ([]QuotaUsageHistory, error) <span class="cov10" title="2">{
        var resp StandardResponse
        var history []QuotaUsageHistory
        resp.Data = &amp;history

        // Build query parameters
        query := make(map[string]string)
        if resourceType != "" </span><span class="cov10" title="2">{
                query["resource_type"] = resourceType
        }</span>
        <span class="cov10" title="2">if !startDate.IsZero() </span><span class="cov10" title="2">{
                query["start_date"] = startDate.Format(time.RFC3339)
        }</span>
        <span class="cov10" title="2">if !endDate.IsZero() </span><span class="cov10" title="2">{
                query["end_date"] = endDate.Format(time.RFC3339)
        }</span>

        <span class="cov10" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/quota-history/%d/usage", orgID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return history, nil</span>
}

// GetAverageUtilization calculates average utilization for a resource type
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/quota-history/:org_id/average-utilization
// Parameters:
//   - orgID: Organization ID
//   - resourceType: Resource type (cpu, memory, storage, etc.)
//   - startDate: Start of the time range (default: 7 days ago)
//   - endDate: End of the time range (default: now)
func (s *QuotaHistoryService) GetAverageUtilization(ctx context.Context, orgID uint, resourceType string, startDate, endDate time.Time) (*AverageUtilizationResponse, error) <span class="cov10" title="2">{
        var resp StandardResponse
        resp.Data = &amp;AverageUtilizationResponse{}

        // Build query parameters
        query := make(map[string]string)
        query["resource_type"] = resourceType
        if !startDate.IsZero() </span><span class="cov10" title="2">{
                query["start_date"] = startDate.Format(time.RFC3339)
        }</span>
        <span class="cov10" title="2">if !endDate.IsZero() </span><span class="cov10" title="2">{
                query["end_date"] = endDate.Format(time.RFC3339)
        }</span>

        <span class="cov10" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/quota-history/%d/average-utilization", orgID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if avgUtil, ok := resp.Data.(*AverageUtilizationResponse); ok </span><span class="cov1" title="1">{
                return avgUtil, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetPeakUtilization retrieves the highest utilization record for a resource type
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/quota-history/:org_id/peak-utilization
// Parameters:
//   - orgID: Organization ID
//   - resourceType: Resource type (cpu, memory, storage, etc.)
//   - startDate: Start of the time range (default: 7 days ago)
//   - endDate: End of the time range (default: now)
func (s *QuotaHistoryService) GetPeakUtilization(ctx context.Context, orgID uint, resourceType string, startDate, endDate time.Time) (*QuotaUsageHistory, error) <span class="cov10" title="2">{
        var resp StandardResponse
        resp.Data = &amp;QuotaUsageHistory{}

        // Build query parameters
        query := make(map[string]string)
        query["resource_type"] = resourceType
        if !startDate.IsZero() </span><span class="cov10" title="2">{
                query["start_date"] = startDate.Format(time.RFC3339)
        }</span>
        <span class="cov10" title="2">if !endDate.IsZero() </span><span class="cov10" title="2">{
                query["end_date"] = endDate.Format(time.RFC3339)
        }</span>

        <span class="cov10" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/quota-history/%d/peak-utilization", orgID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if peakRecord, ok := resp.Data.(*QuotaUsageHistory); ok </span><span class="cov1" title="1">{
                return peakRecord, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetDailyAggregates retrieves daily aggregated quota usage statistics
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/quota-history/:org_id/daily-aggregates
// Parameters:
//   - orgID: Organization ID
//   - resourceType: Resource type (cpu, memory, storage, etc.)
//   - startDate: Start of the time range (default: 30 days ago)
//   - endDate: End of the time range (default: now)
func (s *QuotaHistoryService) GetDailyAggregates(ctx context.Context, orgID uint, resourceType string, startDate, endDate time.Time) ([]DailyAggregateResponse, error) <span class="cov10" title="2">{
        var resp StandardResponse
        var aggregates []DailyAggregateResponse
        resp.Data = &amp;aggregates

        // Build query parameters
        query := make(map[string]string)
        query["resource_type"] = resourceType
        if !startDate.IsZero() </span><span class="cov10" title="2">{
                query["start_date"] = startDate.Format(time.RFC3339)
        }</span>
        <span class="cov10" title="2">if !endDate.IsZero() </span><span class="cov10" title="2">{
                query["end_date"] = endDate.Format(time.RFC3339)
        }</span>

        <span class="cov10" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/quota-history/%d/daily-aggregates", orgID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return aggregates, nil</span>
}

// GetResourceSummary retrieves summary statistics for all resource types
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/quota-history/:org_id/resource-summary
// Parameters:
//   - orgID: Organization ID
//   - startDate: Start date for averages (default: 7 days ago)
//   - endDate: End date for averages (default: now)
func (s *QuotaHistoryService) GetResourceSummary(ctx context.Context, orgID uint, startDate, endDate time.Time) ([]ResourceSummaryResponse, error) <span class="cov10" title="2">{
        var resp StandardResponse
        var summaries []ResourceSummaryResponse
        resp.Data = &amp;summaries

        // Build query parameters
        query := make(map[string]string)
        if !startDate.IsZero() </span><span class="cov10" title="2">{
                query["start_date"] = startDate.Format(time.RFC3339)
        }</span>
        <span class="cov10" title="2">if !endDate.IsZero() </span><span class="cov10" title="2">{
                query["end_date"] = endDate.Format(time.RFC3339)
        }</span>

        <span class="cov10" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/quota-history/%d/resource-summary", orgID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return summaries, nil</span>
}

// GetUsageTrend analyzes quota usage trends using linear regression
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/quota-history/:org_id/usage-trend
// Parameters:
//   - orgID: Organization ID
//   - resourceType: Resource type (cpu, memory, storage, etc.)
//   - days: Number of days to analyze (default: 7)
func (s *QuotaHistoryService) GetUsageTrend(ctx context.Context, orgID uint, resourceType string, days int) (*UsageTrendResponse, error) <span class="cov10" title="2">{
        var resp StandardResponse
        resp.Data = &amp;UsageTrendResponse{}

        // Build query parameters
        query := make(map[string]string)
        query["resource_type"] = resourceType
        if days &gt; 0 </span><span class="cov10" title="2">{
                query["days"] = fmt.Sprintf("%d", days)
        }</span>

        <span class="cov10" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/quota-history/%d/usage-trend", orgID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if trendResponse, ok := resp.Data.(*UsageTrendResponse); ok </span><span class="cov1" title="1">{
                return trendResponse, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// DetectUsagePatterns analyzes quota usage to detect anomalies and patterns
// Authentication: Admin JWT Token or API Key required
// Endpoint: GET /v1/admin/quota-history/:org_id/detect-patterns
// Parameters:
//   - orgID: Organization ID
//   - days: Number of days to analyze (default: 7)
func (s *QuotaHistoryService) DetectUsagePatterns(ctx context.Context, orgID uint, days int) (*UsagePatternsResponse, error) <span class="cov10" title="2">{
        var resp StandardResponse
        resp.Data = &amp;UsagePatternsResponse{}

        // Build query parameters
        query := make(map[string]string)
        if days &gt; 0 </span><span class="cov10" title="2">{
                query["days"] = fmt.Sprintf("%d", days)
        }</span>

        <span class="cov10" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/admin/quota-history/%d/detect-patterns", orgID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov10" title="2">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if patternsResponse, ok := resp.Data.(*UsagePatternsResponse); ok </span><span class="cov0" title="0">{
                return patternsResponse, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// CleanupOldRecords deletes quota history records older than specified retention days
// Authentication: Admin JWT Token or API Key required
// Endpoint: DELETE /v1/admin/quota-history/:org_id/cleanup
// Parameters:
//   - orgID: Organization ID
//   - retentionDays: Number of days to retain (default: 90, minimum: 7)
func (s *QuotaHistoryService) CleanupOldRecords(ctx context.Context, orgID uint, retentionDays int) (int, error) <span class="cov10" title="2">{
        var resp struct {
                Status  string `json:"status"`
                Message string `json:"message"`
                Data    struct {
                        DeletedCount   int    `json:"deleted_count"`
                        RetentionDays  int    `json:"retention_days"`
                        CutoffDate     string `json:"cutoff_date"`
                } `json:"data"`
        }

        // Build query parameters
        query := make(map[string]string)
        if retentionDays &gt; 0 </span><span class="cov10" title="2">{
                query["retention_days"] = fmt.Sprintf("%d", retentionDays)
        }</span>

        <span class="cov10" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/admin/quota-history/%d/cleanup", orgID),
                Query:  query,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return 0, err
        }</span>

        <span class="cov1" title="1">return resp.Data.DeletedCount, nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// ReportingService handles report generation and scheduling operations
type ReportingService struct {
        client *Client
}

// GenerateReport generates a new report with specified configuration
// Authentication: JWT Token required
// Endpoint: POST /v1/reports/generate
// Parameters:
//   - reportType: Type of report (usage, performance, compliance, billing)
//   - config: Report configuration including parameters and filters
// Returns: Report object with generation status
func (s *ReportingService) GenerateReport(ctx context.Context, config *ReportConfiguration) (*Report, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *Report `json:"data"`
                Status  string  `json:"status"`
                Message string  `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/reports/generate",
                Body:   config,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// ListReports retrieves a list of reports with optional filtering
// Authentication: JWT Token required
// Endpoint: GET /v1/reports
// Parameters:
//   - opts: Optional pagination options
//   - status: Optional status filter (pending, generating, completed, failed)
// Returns: Array of Report objects with pagination metadata
func (s *ReportingService) ListReports(ctx context.Context, opts *PaginationOptions, status string) ([]Report, *PaginationMeta, error) <span class="cov10" title="5">{
        var resp struct {
                Data []Report         `json:"data"`
                Meta *PaginationMeta  `json:"meta"`
        }

        query := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        query["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        query["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }
        <span class="cov10" title="5">if status != "" </span><span class="cov1" title="1">{
                query["status"] = status
        }</span>

        <span class="cov10" title="5">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/reports",
                Result: &amp;resp,
        }
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                req.Query = query
        }</span>

        <span class="cov10" title="5">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov8" title="4">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, resp.Meta, nil</span>
}

// GetReport retrieves details of a specific report
// Authentication: JWT Token required
// Endpoint: GET /v1/reports/{id}
// Parameters:
//   - reportID: Report ID
// Returns: Report object with full details
func (s *ReportingService) GetReport(ctx context.Context, reportID uint) (*Report, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *Report `json:"data"`
                Status  string  `json:"status"`
                Message string  `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/reports/%d", reportID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// DownloadReport downloads the generated report file
// Authentication: JWT Token required
// Endpoint: GET /v1/reports/{id}/download
// Parameters:
//   - reportID: Report ID
// Returns: Report file content as byte array
func (s *ReportingService) DownloadReport(ctx context.Context, reportID uint) ([]byte, error) <span class="cov1" title="1">{
        // Note: This endpoint returns raw file content, not JSON
        resp, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/reports/%d/download", reportID),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Body, nil</span>
}

// ScheduleReport creates a scheduled report with recurring execution
// Authentication: JWT Token required
// Endpoint: POST /v1/reports/schedule
// Parameters:
//   - schedule: ReportSchedule object with cron expression and configuration
// Returns: Created ReportSchedule object
func (s *ReportingService) ScheduleReport(ctx context.Context, schedule *ReportSchedule) (*ReportSchedule, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *ReportSchedule `json:"data"`
                Status  string          `json:"status"`
                Message string          `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/reports/schedule",
                Body:   schedule,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// ListSchedules retrieves a list of scheduled reports
// Authentication: JWT Token required
// Endpoint: GET /v1/reports/schedules
// Parameters:
//   - opts: Optional pagination options
//   - enabled: Optional filter for enabled/disabled schedules (nil = all)
// Returns: Array of ReportSchedule objects with pagination metadata
func (s *ReportingService) ListSchedules(ctx context.Context, opts *PaginationOptions, enabled *bool) ([]ReportSchedule, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp struct {
                Data []ReportSchedule `json:"data"`
                Meta *PaginationMeta  `json:"meta"`
        }

        query := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        query["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        query["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }
        <span class="cov1" title="1">if enabled != nil </span><span class="cov1" title="1">{
                query["enabled"] = fmt.Sprintf("%t", *enabled)
        }</span>

        <span class="cov1" title="1">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/reports/schedules",
                Result: &amp;resp,
        }
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                req.Query = query
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, resp.Meta, nil</span>
}

// DeleteSchedule deletes a scheduled report
// Authentication: JWT Token required
// Endpoint: DELETE /v1/reports/schedules/{id}
// Parameters:
//   - scheduleID: Schedule ID
// Returns: Success confirmation
func (s *ReportingService) DeleteSchedule(ctx context.Context, scheduleID uint) error <span class="cov1" title="1">{
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/reports/schedules/%d", scheduleID),
        })
        return err
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">package nexmonyx

import (
        "fmt"
        "time"
)

// StandardResponse represents a standard API response from the Nexmonyx API
type StandardResponse struct {
        Status  string      `json:"status"`
        Message string      `json:"message"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Details string      `json:"details,omitempty"`
}

// PaginatedResponse represents a paginated API response
type PaginatedResponse struct {
        Status  string          `json:"status"`
        Message string          `json:"message"`
        Data    interface{}     `json:"data"`
        Meta    *PaginationMeta `json:"meta"`
}

// PaginationMeta contains pagination metadata
type PaginationMeta struct {
        Page         int    `json:"page"`
        Limit        int    `json:"limit"`
        TotalItems   int    `json:"total_items"`
        TotalPages   int    `json:"total_pages"`
        HasMore      bool   `json:"has_more"`
        NextPage     *int   `json:"next_page,omitempty"`
        PrevPage     *int   `json:"prev_page,omitempty"`
        FirstPage    int    `json:"first_page"`
        LastPage     int    `json:"last_page"`
        From         int    `json:"from"`
        To           int    `json:"to"`
        PerPage      int    `json:"per_page"`
        CurrentPage  int    `json:"current_page"`
        LastPageURL  string `json:"last_page_url,omitempty"`
        NextPageURL  string `json:"next_page_url,omitempty"`
        PrevPageURL  string `json:"prev_page_url,omitempty"`
        FirstPageURL string `json:"first_page_url,omitempty"`
}

// ListOptions specifies options for listing resources
type ListOptions struct {
        Page        int               `url:"page,omitempty"`
        Limit       int               `url:"limit,omitempty"`
        PerPage     int               `url:"per_page,omitempty"`
        Sort        string            `url:"sort,omitempty"`
        Order       string            `url:"order,omitempty"`
        Search      string            `url:"search,omitempty"`
        Query       string            `url:"q,omitempty"`
        Filters     map[string]string `url:"-"`
        Fields      []string          `url:"fields,omitempty,comma"`
        Expand      []string          `url:"expand,omitempty,comma"`
        Include     []string          `url:"include,omitempty,comma"`
        StartDate   string            `url:"start_date,omitempty"`
        EndDate     string            `url:"end_date,omitempty"`
        TimeRange   string            `url:"time_range,omitempty"`
        GroupBy     string            `url:"group_by,omitempty"`
        Aggregation string            `url:"aggregation,omitempty"`
}

// ToQuery converts ListOptions to query parameters
func (lo *ListOptions) ToQuery() map[string]string <span class="cov10" title="56">{
        params := make(map[string]string)

        if lo.Page &gt; 0 </span><span class="cov9" title="46">{
                params["page"] = fmt.Sprintf("%d", lo.Page)
        }</span>
        <span class="cov10" title="56">if lo.Limit &gt; 0 </span><span class="cov9" title="42">{
                params["limit"] = fmt.Sprintf("%d", lo.Limit)
        }</span>
        <span class="cov10" title="56">if lo.PerPage &gt; 0 </span><span class="cov2" title="2">{
                params["per_page"] = fmt.Sprintf("%d", lo.PerPage)
        }</span>
        <span class="cov10" title="56">if lo.Sort != "" </span><span class="cov3" title="3">{
                params["sort"] = lo.Sort
        }</span>
        <span class="cov10" title="56">if lo.Order != "" </span><span class="cov3" title="3">{
                params["order"] = lo.Order
        }</span>
        <span class="cov10" title="56">if lo.Search != "" </span><span class="cov5" title="7">{
                params["search"] = lo.Search
        }</span>
        <span class="cov10" title="56">if lo.Query != "" </span><span class="cov1" title="1">{
                params["q"] = lo.Query
        }</span>
        <span class="cov10" title="56">if lo.StartDate != "" </span><span class="cov1" title="1">{
                params["start_date"] = lo.StartDate
        }</span>
        <span class="cov10" title="56">if lo.EndDate != "" </span><span class="cov1" title="1">{
                params["end_date"] = lo.EndDate
        }</span>
        <span class="cov10" title="56">if lo.TimeRange != "" </span><span class="cov1" title="1">{
                params["time_range"] = lo.TimeRange
        }</span>
        <span class="cov10" title="56">if lo.GroupBy != "" </span><span class="cov1" title="1">{
                params["group_by"] = lo.GroupBy
        }</span>
        <span class="cov10" title="56">if lo.Aggregation != "" </span><span class="cov1" title="1">{
                params["aggregation"] = lo.Aggregation
        }</span>

        // Add custom filters
        <span class="cov10" title="56">for k, v := range lo.Filters </span><span class="cov5" title="8">{
                params[k] = v
        }</span>

        <span class="cov10" title="56">return params</span>
}

// QueryTimeRange represents a time range for queries
type QueryTimeRange struct {
        Start time.Time `json:"start"`
        End   time.Time `json:"end"`
}

// ToStrings converts QueryTimeRange to start/end date strings
func (qtr *QueryTimeRange) ToStrings() (start, end string) <span class="cov4" title="5">{
        return qtr.Start.Format(time.RFC3339), qtr.End.Format(time.RFC3339)
}</span>

// Last24Hours returns a QueryTimeRange for the last 24 hours
func Last24Hours() *QueryTimeRange <span class="cov1" title="1">{
        now := time.Now()
        return &amp;QueryTimeRange{
                Start: now.Add(-24 * time.Hour),
                End:   now,
        }
}</span>

// Last7Days returns a QueryTimeRange for the last 7 days
func Last7Days() *QueryTimeRange <span class="cov1" title="1">{
        now := time.Now()
        return &amp;QueryTimeRange{
                Start: now.Add(-7 * 24 * time.Hour),
                End:   now,
        }
}</span>

// Last30Days returns a QueryTimeRange for the last 30 days
func Last30Days() *QueryTimeRange <span class="cov1" title="1">{
        now := time.Now()
        return &amp;QueryTimeRange{
                Start: now.Add(-30 * 24 * time.Hour),
                End:   now,
        }
}</span>

// ThisMonth returns a QueryTimeRange for the current month
func ThisMonth() *QueryTimeRange <span class="cov1" title="1">{
        now := time.Now()
        start := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location())
        return &amp;QueryTimeRange{
                Start: start,
                End:   now,
        }
}</span>

// LastMonth returns a QueryTimeRange for the previous month
func LastMonth() *QueryTimeRange <span class="cov2" title="2">{
        now := time.Now()
        start := time.Date(now.Year(), now.Month()-1, 1, 0, 0, 0, 0, now.Location())
        end := time.Date(now.Year(), now.Month(), 1, 0, 0, 0, 0, now.Location()).Add(-time.Second)
        return &amp;QueryTimeRange{
                Start: start,
                End:   end,
        }
}</span>

// TimeRange represents a time range for API requests
type TimeRange struct {
        Start string `url:"start,omitempty" json:"start,omitempty"`
        End   string `url:"end,omitempty" json:"end,omitempty"`
}

// BatchResponse represents a response from a batch operation
type BatchResponse struct {
        Status     string              `json:"status"`
        Message    string              `json:"message"`
        Successful []BatchItemResponse `json:"successful,omitempty"`
        Failed     []BatchItemResponse `json:"failed,omitempty"`
        Total      int                 `json:"total"`
        Success    int                 `json:"success"`
        Failures   int                 `json:"failures"`
}

// BatchItemResponse represents an individual item response in a batch
type BatchItemResponse struct {
        ID      string      `json:"id"`
        Status  string      `json:"status"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Message string      `json:"message,omitempty"`
}

// StatusResponse represents a status check response
type StatusResponse struct {
        Status    string                 `json:"status"`
        Healthy   bool                   `json:"healthy"`
        Version   string                 `json:"version,omitempty"`
        Uptime    int64                  `json:"uptime,omitempty"`
        Timestamp time.Time              `json:"timestamp"`
        Services  map[string]bool        `json:"services,omitempty"`
        Details   map[string]interface{} `json:"details,omitempty"`
}

// HeartbeatResponse represents a heartbeat response from the server
type HeartbeatResponse struct {
        Status         string     `json:"status"`
        Message        string     `json:"message"`
        LastHeartbeat  *time.Time `json:"last_heartbeat,omitempty"`
        ServerUUID     string     `json:"server_uuid"`
        ServerStatus   string     `json:"server_status,omitempty"`
        HeartbeatCount int        `json:"heartbeat_count,omitempty"`
        Details        struct {
                AgentVersion string     `json:"agent_version,omitempty"`
                LastSeen     *time.Time `json:"last_seen,omitempty"`
                NextExpected *time.Time `json:"next_expected,omitempty"`
        } `json:"details,omitempty"`
}

// ErrorResponse represents an error response from the API
type ErrorResponse struct {
        Status    string              `json:"status"`
        Error     string              `json:"error"`
        Message   string              `json:"message"`
        Details   string              `json:"details,omitempty"`
        RequestID string              `json:"request_id,omitempty"`
        Errors    map[string][]string `json:"errors,omitempty"`
}

// IsSuccess returns true if the response indicates a successful operation
func (r *StandardResponse) IsSuccess() bool <span class="cov2" title="2">{
        return r.Status == "success"
}</span>

// GetError returns an error if the response indicates a failure
func (r *StandardResponse) GetError() error <span class="cov2" title="2">{
        if r.Status == "error" </span><span class="cov1" title="1">{
                return &amp;APIError{
                        Status:    r.Status,
                        ErrorType: r.Error,
                        Message:   r.Message,
                        Details:   r.Details,
                }
        }</span>
        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package nexmonyx

import (
        "fmt"
        "math"
        "time"
)

// SafeInt64ToUint64 safely converts int64 to uint64 with overflow checking.
// Returns an error if the value is negative, as negative values cannot be
// represented as unsigned integers without wraparound.
//
// This is commonly used for size/byte conversions where negative values
// indicate invalid data (e.g., negative disk space, memory usage).
//
// Example:
//
//        val, err := SafeInt64ToUint64(diskMetrics.TotalBytes)
//        if err != nil {
//            log.Warn("Invalid disk size", "error", err)
//            return err
//        }
func SafeInt64ToUint64(val int64) (uint64, error) <span class="cov4" title="5">{
        if val &lt; 0 </span><span class="cov2" title="2">{
                return 0, fmt.Errorf("cannot convert negative int64 to uint64: %d", val)
        }</span>
        <span class="cov3" title="3">return uint64(val), nil</span>
}

// SafeInt64ToUint64OrZero safely converts int64 to uint64, returning 0 for negative values.
// This is useful when you want to treat negative values as zero (e.g., in aggregations)
// rather than failing with an error.
//
// Example:
//
//        total := SafeInt64ToUint64OrZero(diskMetrics.TotalBytes)
func SafeInt64ToUint64OrZero(val int64) uint64 <span class="cov10" title="49">{
        if val &lt; 0 </span><span class="cov3" title="3">{
                return 0
        }</span>
        <span class="cov9" title="46">return uint64(val)</span>
}

// SafeUint64ToInt64 safely converts uint64 to int64 with overflow checking.
// Returns an error if the value exceeds math.MaxInt64, which would cause
// wraparound to negative values.
//
// This is commonly used when converting large unsigned values to signed types
// like time.Duration (which is int64 internally).
//
// Example:
//
//        duration, err := SafeUint64ToInt64(cpuNanoseconds)
//        if err != nil {
//            log.Warn("CPU time overflow", "error", err)
//            return maxDuration
//        }
//        return time.Duration(duration) * time.Nanosecond
func SafeUint64ToInt64(val uint64) (int64, error) <span class="cov4" title="5">{
        if val &gt; math.MaxInt64 </span><span class="cov2" title="2">{
                return 0, fmt.Errorf("uint64 value exceeds int64 max: %d &gt; %d", val, int64(math.MaxInt64))
        }</span>
        <span class="cov3" title="3">return int64(val), nil</span>
}

// SafeUint64ToDuration safely converts uint64 nanoseconds to time.Duration.
// Returns an error if the value would overflow int64 (&gt; ~292 years).
//
// time.Duration is internally int64, so values larger than math.MaxInt64
// nanoseconds cannot be represented accurately.
//
// Example:
//
//        duration, err := SafeUint64ToDuration(cpuUsageNSec)
//        if err != nil {
//            log.Warn("Duration overflow", "error", err)
//            return time.Duration(math.MaxInt64)
//        }
func SafeUint64ToDuration(nanoseconds uint64) (time.Duration, error) <span class="cov5" title="6">{
        if nanoseconds &gt; math.MaxInt64 </span><span class="cov2" title="2">{
                return 0, fmt.Errorf("nanoseconds value exceeds time.Duration capacity: %d &gt; %d (~292 years)",
                        nanoseconds, int64(math.MaxInt64))
        }</span>
        <span class="cov4" title="4">return time.Duration(nanoseconds) * time.Nanosecond, nil</span>
}

// SafeUint64ToDurationCapped safely converts uint64 nanoseconds to time.Duration,
// capping at the maximum representable duration instead of returning an error.
//
// This is useful when you prefer graceful degradation over error handling.
//
// Example:
//
//        duration := SafeUint64ToDurationCapped(cpuUsageNSec)  // Never fails
func SafeUint64ToDurationCapped(nanoseconds uint64) time.Duration <span class="cov6" title="9">{
        if nanoseconds &gt; math.MaxInt64 </span><span class="cov3" title="3">{
                return time.Duration(math.MaxInt64)
        }</span>
        <span class="cov5" title="6">return time.Duration(nanoseconds) * time.Nanosecond</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// SearchService handles search operations across servers, tags, and other resources
type SearchService struct {
        client *Client
}

// SearchServers performs a comprehensive search across servers
// Authentication: JWT Token required
// Endpoint: GET /v1/search/servers
// Parameters:
//   - query: Search query string (searches name, UUID, hostname, IP addresses, tags)
//   - opts: Optional pagination options
//   - filters: Optional filters (location, environment, status, classification)
// Returns: Array of SearchResult objects with pagination metadata
func (s *SearchService) SearchServers(ctx context.Context, query string, opts *PaginationOptions, filters map[string]interface{}) ([]SearchResult, *PaginationMeta, error) <span class="cov10" title="6">{
        var resp struct {
                Data []SearchResult  `json:"data"`
                Meta *PaginationMeta `json:"meta"`
        }

        queryParams := make(map[string]string)
        if query != "" </span><span class="cov10" title="6">{
                queryParams["query"] = query
        }</span>
        <span class="cov10" title="6">if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }

        // Add filter parameters
        <span class="cov10" title="6">if filters != nil </span><span class="cov4" title="2">{
                if location, ok := filters["location"].(string); ok &amp;&amp; location != "" </span><span class="cov1" title="1">{
                        queryParams["location"] = location
                }</span>
                <span class="cov4" title="2">if environment, ok := filters["environment"].(string); ok &amp;&amp; environment != "" </span><span class="cov4" title="2">{
                        queryParams["environment"] = environment
                }</span>
                <span class="cov4" title="2">if status, ok := filters["status"].(string); ok &amp;&amp; status != "" </span><span class="cov1" title="1">{
                        queryParams["status"] = status
                }</span>
                <span class="cov4" title="2">if classification, ok := filters["classification"].(string); ok &amp;&amp; classification != "" </span><span class="cov1" title="1">{
                        queryParams["classification"] = classification
                }</span>
        }

        <span class="cov10" title="6">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/search/servers",
                Result: &amp;resp,
        }
        if len(queryParams) &gt; 0 </span><span class="cov10" title="6">{
                req.Query = queryParams
        }</span>

        <span class="cov10" title="6">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov7" title="4">{
                return nil, nil, err
        }</span>

        <span class="cov4" title="2">return resp.Data, resp.Meta, nil</span>
}

// SearchTags searches for tags across the system
// Authentication: JWT Token required
// Endpoint: GET /v1/search/tags
// Parameters:
//   - query: Search query string (searches tag names and descriptions)
//   - opts: Optional pagination options
//   - filters: Optional filters (tag_type, scope)
// Returns: Array of TagSearchResult objects with pagination metadata
func (s *SearchService) SearchTags(ctx context.Context, query string, opts *PaginationOptions, filters map[string]interface{}) ([]TagSearchResult, *PaginationMeta, error) <span class="cov4" title="2">{
        var resp struct {
                Data []TagSearchResult `json:"data"`
                Meta *PaginationMeta   `json:"meta"`
        }

        queryParams := make(map[string]string)
        if query != "" </span><span class="cov4" title="2">{
                queryParams["query"] = query
        }</span>
        <span class="cov4" title="2">if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }

        // Add filter parameters
        <span class="cov4" title="2">if filters != nil </span><span class="cov1" title="1">{
                if tagType, ok := filters["tag_type"].(string); ok &amp;&amp; tagType != "" </span><span class="cov1" title="1">{
                        queryParams["tag_type"] = tagType
                }</span>
                <span class="cov1" title="1">if scope, ok := filters["scope"].(string); ok &amp;&amp; scope != "" </span><span class="cov1" title="1">{
                        queryParams["scope"] = scope
                }</span>
        }

        <span class="cov4" title="2">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/search/tags",
                Result: &amp;resp,
        }
        if len(queryParams) &gt; 0 </span><span class="cov4" title="2">{
                req.Query = queryParams
        }</span>

        <span class="cov4" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov4" title="2">return resp.Data, resp.Meta, nil</span>
}

// GetTagStatistics retrieves comprehensive statistics about tag usage
// Authentication: JWT Token required
// Endpoint: GET /v1/search/tags/statistics
// Parameters:
//   - tagType: Optional filter by tag type (manual, auto, system)
//   - scope: Optional filter by scope (organization, user, server)
// Returns: TagStatistics object with comprehensive tag usage data
func (s *SearchService) GetTagStatistics(ctx context.Context, tagType string, scope string) (*TagStatistics, error) <span class="cov4" title="2">{
        var resp struct {
                Data    *TagStatistics `json:"data"`
                Status  string         `json:"status"`
                Message string         `json:"message"`
        }

        queryParams := make(map[string]string)
        if tagType != "" </span><span class="cov1" title="1">{
                queryParams["tag_type"] = tagType
        }</span>
        <span class="cov4" title="2">if scope != "" </span><span class="cov1" title="1">{
                queryParams["scope"] = scope
        }</span>

        <span class="cov4" title="2">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/search/tags/statistics",
                Result: &amp;resp,
        }
        if len(queryParams) &gt; 0 </span><span class="cov1" title="1">{
                req.Query = queryParams
        }</span>

        <span class="cov4" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return resp.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// ServerGroupsService handles server group management operations
type ServerGroupsService struct {
        client *Client
}

// CreateGroup creates a new server group
// Authentication: JWT Token required
// Endpoint: POST /v1/groups
// Parameters:
//   - name: Group name
//   - description: Optional group description
//   - tags: Optional tags for group organization
// Returns: Created ServerGroup object
func (s *ServerGroupsService) CreateGroup(ctx context.Context, name string, description string, tags []string) (*ServerGroup, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *ServerGroup `json:"data"`
                Status  string       `json:"status"`
                Message string       `json:"message"`
        }

        body := map[string]interface{}{
                "name": name,
        }
        if description != "" </span><span class="cov1" title="1">{
                body["description"] = description
        }</span>
        <span class="cov1" title="1">if len(tags) &gt; 0 </span><span class="cov1" title="1">{
                body["tags"] = tags
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/groups",
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// ListGroups retrieves a list of server groups
// Authentication: JWT Token required
// Endpoint: GET /v1/groups
// Parameters:
//   - opts: Optional pagination options
//   - nameFilter: Optional filter for group name search
//   - tags: Optional filter by tags
// Returns: Array of ServerGroup objects with pagination metadata
func (s *ServerGroupsService) ListGroups(ctx context.Context, opts *PaginationOptions, nameFilter string, tags []string) ([]ServerGroup, *PaginationMeta, error) <span class="cov10" title="5">{
        var resp struct {
                Data []ServerGroup   `json:"data"`
                Meta *PaginationMeta `json:"meta"`
        }

        query := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        query["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        query["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }
        <span class="cov10" title="5">if nameFilter != "" </span><span class="cov1" title="1">{
                query["name"] = nameFilter
        }</span>
        <span class="cov10" title="5">if len(tags) &gt; 0 </span><span class="cov0" title="0">{
                // Join tags with comma for query parameter
                tagStr := ""
                for i, tag := range tags </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                tagStr += ","
                        }</span>
                        <span class="cov0" title="0">tagStr += tag</span>
                }
                <span class="cov0" title="0">query["tags"] = tagStr</span>
        }

        <span class="cov10" title="5">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/groups",
                Result: &amp;resp,
        }
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                req.Query = query
        }</span>

        <span class="cov10" title="5">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov8" title="4">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, resp.Meta, nil</span>
}

// AddServersToGroup adds servers to a group
// Authentication: JWT Token required
// Endpoint: POST /v1/groups/{groupID}/servers
// Parameters:
//   - groupID: Group ID
//   - serverIDs: Array of server IDs to add
//   - serverUUIDs: Array of server UUIDs to add
// Returns: Number of servers added
func (s *ServerGroupsService) AddServersToGroup(ctx context.Context, groupID uint, serverIDs []uint, serverUUIDs []string) (int, error) <span class="cov1" title="1">{
        var resp struct {
                Data struct {
                        ServersAdded int `json:"servers_added"`
                } `json:"data"`
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        body := map[string]interface{}{}
        if len(serverIDs) &gt; 0 </span><span class="cov0" title="0">{
                body["server_ids"] = serverIDs
        }</span>
        <span class="cov1" title="1">if len(serverUUIDs) &gt; 0 </span><span class="cov1" title="1">{
                body["server_uuids"] = serverUUIDs
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/groups/%d/servers", groupID),
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov1" title="1">return resp.Data.ServersAdded, nil</span>
}

// GetGroupServers retrieves servers in a specific group
// Authentication: JWT Token required
// Endpoint: GET /v1/groups/{groupID}/servers
// Parameters:
//   - groupID: Group ID
//   - opts: Optional pagination options
//   - status: Optional filter by server status
//   - tags: Optional filter by server tags
// Returns: Array of ServerGroupMembership objects with pagination metadata
func (s *ServerGroupsService) GetGroupServers(ctx context.Context, groupID uint, opts *PaginationOptions, status string, tags []string) ([]ServerGroupMembership, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp struct {
                Data []ServerGroupMembership `json:"data"`
                Meta *PaginationMeta         `json:"meta"`
        }

        query := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        query["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        query["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }
        <span class="cov1" title="1">if status != "" </span><span class="cov1" title="1">{
                query["status"] = status
        }</span>
        <span class="cov1" title="1">if len(tags) &gt; 0 </span><span class="cov0" title="0">{
                tagStr := ""
                for i, tag := range tags </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                tagStr += ","
                        }</span>
                        <span class="cov0" title="0">tagStr += tag</span>
                }
                <span class="cov0" title="0">query["tags"] = tagStr</span>
        }

        <span class="cov1" title="1">req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/groups/%d/servers", groupID),
                Result: &amp;resp,
        }
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                req.Query = query
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, resp.Meta, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// GetServer retrieves a server by ID (deprecated - use GetByUUID instead)
// This method assumes the ID is actually a UUID
func (s *ServersService) Get(ctx context.Context, id string) (*Server, error) <span class="cov1" title="1">{
        // Redirect to GetByUUID since the API only supports UUID-based access
        return s.GetByUUID(ctx, id)
}</span>

// GetServerByUUID retrieves a server by UUID
func (s *ServersService) GetByUUID(ctx context.Context, uuid string) (*Server, error) <span class="cov10" title="4">{
        var resp StandardResponse
        resp.Data = &amp;Server{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/server/%s/details", uuid),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov5" title="2">{
                return nil, err
        }</span>

        <span class="cov5" title="2">if server, ok := resp.Data.(*Server); ok </span><span class="cov5" title="2">{
                return server, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ListServers retrieves a list of servers
func (s *ServersService) List(ctx context.Context, opts *ListOptions) ([]*Server, *PaginationMeta, error) <span class="cov10" title="4">{
        var resp PaginatedResponse
        var servers []*Server
        resp.Data = &amp;servers

        req := &amp;Request{
                Method: "GET",
                Path:   "/v2/servers",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov8" title="3">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov10" title="4">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov10" title="4">return servers, resp.Meta, nil</span>
}

// CreateServer registers a new server (deprecated - use RegisterWithKey instead)
// This method is deprecated as server creation now requires registration keys
func (s *ServersService) Create(ctx context.Context, server *Server) (*Server, error) <span class="cov5" title="2">{
        // For backward compatibility, try to register with empty key
        // This will likely fail unless the API supports it
        var resp StandardResponse
        resp.Data = &amp;Server{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/register",
                Body:   server,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if created, ok := resp.Data.(*Server); ok </span><span class="cov1" title="1">{
                return created, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// UpdateServer updates an existing server (deprecated - use UpdateDetails instead)
// This method assumes the ID is actually a UUID and uses the details endpoint
func (s *ServersService) Update(ctx context.Context, id string, server *Server) (*Server, error) <span class="cov1" title="1">{
        // Convert to server update request and use UpdateDetails
        // This is a best-effort mapping
        req := &amp;ServerDetailsUpdateRequest{
                // Map relevant fields from Server to ServerDetailsUpdateRequest
                Hostname: server.Hostname,
                // Add other fields as needed
        }
        return s.UpdateDetails(ctx, id, req)
}</span>

// DeleteServer deletes a server (requires admin permissions)
// This method assumes the ID is actually a UUID and uses the admin endpoint
func (s *ServersService) Delete(ctx context.Context, id string) error <span class="cov8" title="3">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/admin/server/%s", id),
                Result: &amp;resp,
        })
        return err
}</span>

// RegisterServer registers a new server with credentials
func (s *ServersService) Register(ctx context.Context, hostname string, organizationID uint) (*Server, error) <span class="cov5" title="2">{
        var resp StandardResponse
        resp.Data = &amp;Server{}

        body := map[string]interface{}{
                "hostname":        hostname,
                "organization_id": organizationID,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/register",
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if server, ok := resp.Data.(*Server); ok </span><span class="cov1" title="1">{
                return server, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// SendHeartbeat sends a heartbeat for a server
// Deprecated: UUID parameter is ignored. Use Heartbeat() method instead which uses server credentials from client config.
func (s *ServersService) SendHeartbeat(ctx context.Context, uuid string) error <span class="cov5" title="2">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/heartbeat",
                Result: &amp;resp,
        })
        return err
}</span>

// GetServerMetrics retrieves metrics for a server
func (s *ServersService) GetMetrics(ctx context.Context, id string, opts *ListOptions) ([]*Metric, *PaginationMeta, error) <span class="cov8" title="3">{
        var resp PaginatedResponse
        var metrics []*Metric
        resp.Data = &amp;metrics

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/server/%s/metrics", id),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov8" title="3">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, nil, err
        }</span>

        <span class="cov5" title="2">return metrics, resp.Meta, nil</span>
}

// GetServerAlerts retrieves alerts for a server
func (s *ServersService) GetAlerts(ctx context.Context, id string, opts *ListOptions) ([]*Alert, *PaginationMeta, error) <span class="cov5" title="2">{
        var resp PaginatedResponse
        var alerts []*Alert
        resp.Data = &amp;alerts

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/server/%s/alerts", id),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov5" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov5" title="2">return alerts, resp.Meta, nil</span>
}

// UpdateServerTags updates tags for a server
func (s *ServersService) UpdateTags(ctx context.Context, id string, tags []string) (*Server, error) <span class="cov8" title="3">{
        var resp StandardResponse
        resp.Data = &amp;Server{}

        body := map[string]interface{}{
                "tags": tags,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/server/%s/tags", id),
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="2">if server, ok := resp.Data.(*Server); ok </span><span class="cov5" title="2">{
                return server, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ExecuteCommand executes a command on a server
func (s *ServersService) ExecuteCommand(ctx context.Context, id string, command string) (map[string]interface{}, error) <span class="cov8" title="3">{
        var resp StandardResponse
        var result map[string]interface{}
        resp.Data = &amp;result

        body := map[string]interface{}{
                "command": command,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/server/%s/execute", id),
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="2">return result, nil</span>
}

// GetServerSystemInfo retrieves system information for a server
func (s *ServersService) GetSystemInfo(ctx context.Context, id string) (*SystemInfo, error) <span class="cov5" title="2">{
        var resp StandardResponse
        resp.Data = &amp;SystemInfo{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/server/%s/system-info", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if info, ok := resp.Data.(*SystemInfo); ok </span><span class="cov1" title="1">{
                return info, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// RegisterWithKey registers a new server with a registration key
func (s *ServersService) RegisterWithKey(ctx context.Context, registrationKey string, req *ServerCreateRequest) (*Server, error) <span class="cov5" title="2">{
        resp, err := s.RegisterWithKeyFull(ctx, registrationKey, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp.Server, nil</span>
}

// RegisterWithKeyFull registers a new server with a registration key and returns the full response
func (s *ServersService) RegisterWithKeyFull(ctx context.Context, registrationKey string, req *ServerCreateRequest) (*ServerRegistrationResponse, error) <span class="cov8" title="3">{
        var resp StandardResponse
        resp.Data = &amp;ServerRegistrationResponse{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/register",
                Headers: map[string]string{
                        "X-Registration-Key": registrationKey,
                },
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov5" title="2">if regResp, ok := resp.Data.(*ServerRegistrationResponse); ok </span><span class="cov5" title="2">{
                return regResp, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// =============================================================================
// Unified Registration Key Methods
// =============================================================================

// RegisterWithUnifiedKey registers a new server using a unified registration key
func (s *ServersService) RegisterWithUnifiedKey(ctx context.Context, key *UnifiedAPIKey, req *ServerCreateRequest) (*Server, error) <span class="cov8" title="3">{
        if !key.CanRegisterServers() </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("API key does not have server registration capabilities")
        }</span>

        <span class="cov5" title="2">resp, err := s.RegisterWithUnifiedKeyFull(ctx, key, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>
        <span class="cov1" title="1">return resp.Server, nil</span>
}

// RegisterWithUnifiedKeyFull registers a new server using a unified registration key and returns the full response
func (s *ServersService) RegisterWithUnifiedKeyFull(ctx context.Context, key *UnifiedAPIKey, req *ServerCreateRequest) (*ServerRegistrationResponse, error) <span class="cov10" title="4">{
        if !key.CanRegisterServers() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API key does not have server registration capabilities")
        }</span>

        <span class="cov10" title="4">var headers map[string]string
        switch key.GetAuthenticationMethod() </span>{
        case "headers":<span class="cov10" title="4">
                if key.Type == APIKeyTypeRegistration </span><span class="cov8" title="3">{
                        headers = map[string]string{
                                "X-Registration-Key": key.FullToken,
                        }
                }</span> else<span class="cov1" title="1"> {
                        headers = map[string]string{
                                "Access-Key":    key.Key,
                                "Access-Secret": key.Secret,
                        }
                }</span>
        case "bearer":<span class="cov0" title="0">
                headers = map[string]string{
                        "Authorization": "Bearer " + key.FullToken,
                }</span>
        }

        <span class="cov10" title="4">var resp StandardResponse
        resp.Data = &amp;ServerRegistrationResponse{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method:  "POST",
                Path:    "/v1/register",
                Headers: headers,
                Body:    req,
                Result:  &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="3">if regResp, ok := resp.Data.(*ServerRegistrationResponse); ok </span><span class="cov8" title="3">{
                return regResp, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ValidateRegistrationKey validates that a unified API key can be used for server registration
func (s *ServersService) ValidateRegistrationKey(ctx context.Context, key *UnifiedAPIKey) error <span class="cov8" title="3">{
        if !key.IsActive() </span><span class="cov1" title="1">{
                return fmt.Errorf("registration key is not active")
        }</span>

        <span class="cov5" title="2">if !key.CanRegisterServers() </span><span class="cov1" title="1">{
                return fmt.Errorf("API key does not have server registration capabilities")
        }</span>

        // For registration keys, we might also want to check organization access
        // This would depend on the API implementation
        <span class="cov1" title="1">return nil</span>
}

// RegisterServerQuick is a convenience method that creates a registration key and immediately uses it
func (s *ServersService) RegisterServerQuick(ctx context.Context, orgID uint, hostname, mainIP string) (*ServerRegistrationResponse, error) <span class="cov1" title="1">{
        // This would require admin privileges to create a registration key
        // For now, return an error indicating this needs to be done in two steps
        return nil, fmt.Errorf("quick registration not supported - create a registration key first using APIKeys.CreateRegistrationKey()")
}</span>

// Heartbeat sends a heartbeat from the authenticated server
func (s *ServersService) Heartbeat(ctx context.Context) error <span class="cov5" title="2">{
        if s.client.config.Debug </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] Heartbeat: Starting heartbeat request\n")
                fmt.Printf("[DEBUG] Heartbeat: Endpoint: POST /v1/heartbeat\n")
                fmt.Printf("[DEBUG] Heartbeat: Using server UUID: %s\n", s.client.config.Auth.ServerUUID)
        }</span>

        <span class="cov5" title="2">var resp StandardResponse

        httpResp, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/heartbeat",
                Result: &amp;resp,
        })

        if s.client.config.Debug </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[DEBUG] Heartbeat: Request failed with error: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("[DEBUG] Heartbeat: Request successful\n")
                        fmt.Printf("[DEBUG] Heartbeat: Response status: %s\n", resp.Status)
                        fmt.Printf("[DEBUG] Heartbeat: Response message: %s\n", resp.Message)
                        if httpResp != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[DEBUG] Heartbeat: HTTP Status Code: %d\n", httpResp.StatusCode)
                        }</span>
                }
        }

        <span class="cov5" title="2">return err</span>
}

// HeartbeatWithVersion sends a heartbeat with agent version from the authenticated server
func (s *ServersService) HeartbeatWithVersion(ctx context.Context, agentVersion string) error <span class="cov5" title="2">{
        if s.client.config.Debug </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] HeartbeatWithVersion: Starting heartbeat request with version\n")
                fmt.Printf("[DEBUG] HeartbeatWithVersion: Endpoint: POST /v1/heartbeat\n")
                fmt.Printf("[DEBUG] HeartbeatWithVersion: Agent version: %s\n", agentVersion)
                fmt.Printf("[DEBUG] HeartbeatWithVersion: Using server UUID: %s\n", s.client.config.Auth.ServerUUID)
        }</span>

        <span class="cov5" title="2">var resp StandardResponse

        body := map[string]string{
                "agent_version": agentVersion,
        }

        if s.client.config.Debug </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] HeartbeatWithVersion: Request body: %+v\n", body)
        }</span>

        <span class="cov5" title="2">httpResp, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/heartbeat",
                Body:   body,
                Result: &amp;resp,
        })

        if s.client.config.Debug </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[DEBUG] HeartbeatWithVersion: Request failed with error: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("[DEBUG] HeartbeatWithVersion: Request successful\n")
                        fmt.Printf("[DEBUG] HeartbeatWithVersion: Response status: %s\n", resp.Status)
                        fmt.Printf("[DEBUG] HeartbeatWithVersion: Response message: %s\n", resp.Message)
                        if httpResp != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[DEBUG] HeartbeatWithVersion: HTTP Status Code: %d\n", httpResp.StatusCode)
                        }</span>
                }
        }

        <span class="cov5" title="2">return err</span>
}

// UpdateServer updates server information
func (s *ServersService) UpdateServer(ctx context.Context, serverUUID string, req *ServerUpdateRequest) (*Server, error) <span class="cov5" title="2">{
        var resp StandardResponse
        resp.Data = &amp;Server{}

        // Use the admin endpoint since there's no general server update endpoint
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/admin/server/%s", serverUUID),
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if server, ok := resp.Data.(*Server); ok </span><span class="cov1" title="1">{
                return server, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// UpdateDetails updates detailed server information including hardware info
func (s *ServersService) UpdateDetails(ctx context.Context, serverUUID string, req *ServerDetailsUpdateRequest) (*Server, error) <span class="cov10" title="4">{
        endpoint := fmt.Sprintf("/v1/server/%s/details", serverUUID)

        if s.client.config.Debug </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] UpdateDetails: Starting server details update\n")
                fmt.Printf("[DEBUG] UpdateDetails: Endpoint: PUT %s\n", endpoint)
                fmt.Printf("[DEBUG] UpdateDetails: Server UUID: %s\n", serverUUID)
                fmt.Printf("[DEBUG] UpdateDetails: Request data:\n")
                if req != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[DEBUG]   Hostname: %s\n", req.Hostname)
                        fmt.Printf("[DEBUG]   OS: %s\n", req.OS)
                        fmt.Printf("[DEBUG]   OS Version: %s\n", req.OSVersion)
                        fmt.Printf("[DEBUG]   OS Arch: %s\n", req.OSArch)
                        fmt.Printf("[DEBUG]   CPUModel: %s\n", req.CPUModel)
                        fmt.Printf("[DEBUG]   CPUCores: %d\n", req.CPUCores)
                        fmt.Printf("[DEBUG]   MemoryTotal: %d\n", req.MemoryTotal)
                        fmt.Printf("[DEBUG]   StorageTotal: %d\n", req.StorageTotal)
                        
                        // Debug enhanced hardware details
                        if req.HasHardwareDetails() </span><span class="cov0" title="0">{
                                fmt.Printf("[DEBUG] UpdateDetails: Enhanced hardware details present\n")
                                if len(req.Hardware.CPU) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("[DEBUG]   CPU Count: %d\n", len(req.Hardware.CPU))
                                        for i, cpu := range req.Hardware.CPU </span><span class="cov0" title="0">{
                                                fmt.Printf("[DEBUG]   CPU[%d]: %s %s (%d cores)\n", i, cpu.Manufacturer, cpu.ModelName, cpu.PhysicalCores)
                                        }</span>
                                }
                                <span class="cov0" title="0">if req.Hardware.Memory != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("[DEBUG]   Memory: %d bytes total, %s type\n", req.Hardware.Memory.TotalSize, req.Hardware.Memory.MemoryType)
                                }</span>
                                <span class="cov0" title="0">if len(req.Hardware.Network) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Printf("[DEBUG]   Network Interfaces: %d\n", len(req.Hardware.Network))
                                        for i, iface := range req.Hardware.Network </span><span class="cov0" title="0">{
                                                fmt.Printf("[DEBUG]   Interface[%d]: %s (%s) - %d Mbps\n", i, iface.Name, iface.HardwareAddr, iface.SpeedMbps)
                                        }</span>
                                }
                                <span class="cov0" title="0">if req.HasDisks() </span><span class="cov0" title="0">{
                                        fmt.Printf("[DEBUG]   Disks: %d\n", len(req.Hardware.Disks))
                                        for i, disk := range req.Hardware.Disks </span><span class="cov0" title="0">{
                                                fmt.Printf("[DEBUG]   Disk[%d]: %s (%s) %s - %d bytes\n", i, disk.Device, disk.DiskModel, disk.Type, disk.Size)
                                        }</span>
                                }
                        } else<span class="cov0" title="0"> {
                                fmt.Printf("[DEBUG] UpdateDetails: No enhanced hardware details\n")
                        }</span>
                }
                <span class="cov0" title="0">fmt.Printf("[DEBUG] UpdateDetails: Using authentication - Server UUID: %s\n", s.client.config.Auth.ServerUUID)</span>
        }

        <span class="cov10" title="4">var resp StandardResponse
        resp.Data = &amp;Server{}

        httpResp, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   endpoint,
                Body:   req,
                Result: &amp;resp,
        })

        if s.client.config.Debug </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[DEBUG] UpdateDetails: Request failed with error: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("[DEBUG] UpdateDetails: Request successful\n")
                        fmt.Printf("[DEBUG] UpdateDetails: Response status: %s\n", resp.Status)
                        fmt.Printf("[DEBUG] UpdateDetails: Response message: %s\n", resp.Message)
                        if httpResp != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[DEBUG] UpdateDetails: HTTP Status Code: %d\n", httpResp.StatusCode)
                        }</span>
                        <span class="cov0" title="0">if server, ok := resp.Data.(*Server); ok &amp;&amp; server != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[DEBUG] UpdateDetails: Server ID: %d\n", server.ID)
                                fmt.Printf("[DEBUG] UpdateDetails: Server UUID: %s\n", server.ServerUUID)
                                fmt.Printf("[DEBUG] UpdateDetails: Server Hostname: %s\n", server.Hostname)
                        }</span>
                }
        }

        <span class="cov10" title="4">if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="3">if server, ok := resp.Data.(*Server); ok </span><span class="cov8" title="3">{
                return server, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// UpdateInfo updates server information (alias for UpdateDetails)
func (s *ServersService) UpdateInfo(ctx context.Context, serverUUID string, req *ServerDetailsUpdateRequest) (*Server, error) <span class="cov5" title="2">{
        endpoint := fmt.Sprintf("/v1/server/%s/info", serverUUID)

        if s.client.config.Debug </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] UpdateInfo: Starting server info update\n")
                fmt.Printf("[DEBUG] UpdateInfo: Endpoint: PUT %s\n", endpoint)
                fmt.Printf("[DEBUG] UpdateInfo: Server UUID: %s\n", serverUUID)
                fmt.Printf("[DEBUG] UpdateInfo: Request data:\n")
                if req != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[DEBUG]   Hostname: %s\n", req.Hostname)
                        fmt.Printf("[DEBUG]   OS: %s\n", req.OS)
                        fmt.Printf("[DEBUG]   OS Version: %s\n", req.OSVersion)
                        fmt.Printf("[DEBUG]   OS Arch: %s\n", req.OSArch)
                        fmt.Printf("[DEBUG]   CPUModel: %s\n", req.CPUModel)
                        fmt.Printf("[DEBUG]   CPUCores: %d\n", req.CPUCores)
                        fmt.Printf("[DEBUG]   MemoryTotal: %d\n", req.MemoryTotal)
                        fmt.Printf("[DEBUG]   StorageTotal: %d\n", req.StorageTotal)
                }</span>
                <span class="cov0" title="0">fmt.Printf("[DEBUG] UpdateInfo: Using authentication - Server UUID: %s\n", s.client.config.Auth.ServerUUID)</span>
        }

        <span class="cov5" title="2">var resp StandardResponse
        resp.Data = &amp;Server{}

        httpResp, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   endpoint,
                Body:   req,
                Result: &amp;resp,
        })

        if s.client.config.Debug </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[DEBUG] UpdateInfo: Request failed with error: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("[DEBUG] UpdateInfo: Request successful\n")
                        fmt.Printf("[DEBUG] UpdateInfo: Response status: %s\n", resp.Status)
                        fmt.Printf("[DEBUG] UpdateInfo: Response message: %s\n", resp.Message)
                        if httpResp != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[DEBUG] UpdateInfo: HTTP Status Code: %d\n", httpResp.StatusCode)
                        }</span>
                        <span class="cov0" title="0">if server, ok := resp.Data.(*Server); ok &amp;&amp; server != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[DEBUG] UpdateInfo: Server ID: %d\n", server.ID)
                                fmt.Printf("[DEBUG] UpdateInfo: Server UUID: %s\n", server.ServerUUID)
                                fmt.Printf("[DEBUG] UpdateInfo: Server Hostname: %s\n", server.Hostname)
                        }</span>
                }
        }

        <span class="cov5" title="2">if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if server, ok := resp.Data.(*Server); ok </span><span class="cov1" title="1">{
                return server, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetDetails retrieves server details
func (s *ServersService) GetDetails(ctx context.Context, serverUUID string) (*Server, error) <span class="cov5" title="2">{
        var resp StandardResponse
        resp.Data = &amp;Server{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/server/%s/details", serverUUID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if server, ok := resp.Data.(*Server); ok </span><span class="cov1" title="1">{
                return server, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}



</pre>
		
		<pre class="file" id="file53" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// ServiceMonitoringService handles service monitoring related API operations
type ServiceMonitoringService struct {
        client *Client
}

// ServiceMonitoringRequest represents a request to submit service monitoring data
type ServiceMonitoringRequest struct {
        ServerUUID string       `json:"server_uuid"`
        Services   *ServiceInfo `json:"services"`
}

// ServiceMetricsRequest represents a request to submit service metrics
type ServiceMetricsRequest struct {
        ServerUUID string            `json:"server_uuid"`
        Metrics    []*ServiceMetrics `json:"metrics"`
}

// ServiceLogsRequest represents a request to submit service logs
type ServiceLogsRequest struct {
        ServerUUID string                        `json:"server_uuid"`
        Logs       map[string][]ServiceLogEntry `json:"logs"`
}

// ServiceStatusResponse represents the response from getting service status
type ServiceStatusResponse struct {
        ServerUUID   string                 `json:"server_uuid"`
        LastUpdated  string                 `json:"last_updated"`
        Services     []*ServiceMonitoringInfo  `json:"services"`
        Summary      ServiceStatusSummary   `json:"summary"`
}

// ServiceStatusSummary provides a summary of service states
type ServiceStatusSummary struct {
        Total        int            `json:"total"`
        Active       int            `json:"active"`
        Inactive     int            `json:"inactive"`
        Failed       int            `json:"failed"`
        StateCounts  map[string]int `json:"state_counts"`
}

// ServiceHistoryResponse represents historical service data
type ServiceHistoryResponse struct {
        ServerUUID   string                `json:"server_uuid"`
        ServiceName  string                `json:"service_name"`
        History      []ServiceHistoryEntry `json:"history"`
}

// ServiceHistoryEntry represents a point in service history
type ServiceHistoryEntry struct {
        Timestamp    string  `json:"timestamp"`
        State        string  `json:"state"`
        SubState     string  `json:"sub_state"`
        CPUPercent   float64 `json:"cpu_percent,omitempty"`
        MemoryBytes  uint64  `json:"memory_bytes,omitempty"`
        RestartCount int     `json:"restart_count,omitempty"`
}

// SubmitServiceData submits service monitoring data
func (s *ServiceMonitoringService) SubmitServiceData(ctx context.Context, serverID string, services *ServiceInfo) error <span class="cov0" title="0">{
        req := &amp;ServiceMonitoringRequest{
                ServerUUID: serverID,
                Services:   services,
        }

        path := fmt.Sprintf("/v1/servers/%s/services", serverID)
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   path,
                Body:   req,
        })
        return err
}</span>

// SubmitServiceMetrics submits service metrics as time-series data
func (s *ServiceMonitoringService) SubmitServiceMetrics(ctx context.Context, serverID string, metrics []*ServiceMetrics) error <span class="cov0" title="0">{
        req := &amp;ServiceMetricsRequest{
                ServerUUID: serverID,
                Metrics:    metrics,
        }

        path := fmt.Sprintf("/v1/servers/%s/services/metrics", serverID)
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   path,
                Body:   req,
        })
        return err
}</span>

// SubmitServiceLogs submits service logs
func (s *ServiceMonitoringService) SubmitServiceLogs(ctx context.Context, serverID string, logs map[string][]ServiceLogEntry) error <span class="cov0" title="0">{
        req := &amp;ServiceLogsRequest{
                ServerUUID: serverID,
                Logs:       logs,
        }

        path := fmt.Sprintf("/v1/servers/%s/services/logs", serverID)
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   path,
                Body:   req,
        })
        return err
}</span>

// GetServerServices gets the current service status for a server
func (s *ServiceMonitoringService) GetServerServices(ctx context.Context, serverID string) (*ServiceStatusResponse, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("/v1/servers/%s/services", serverID)
        
        var response ServiceStatusResponse
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   path,
                Result: &amp;response,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// GetServiceHistory gets historical data for a specific service
func (s *ServiceMonitoringService) GetServiceHistory(ctx context.Context, serverID string, serviceName string, opts *ListOptions) (*ServiceHistoryResponse, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("/v1/servers/%s/services/%s/history", serverID, serviceName)
        
        var query map[string]string
        if opts != nil </span><span class="cov0" title="0">{
                query = opts.ToQuery()
        }</span>

        <span class="cov0" title="0">var response ServiceHistoryResponse
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   path,
                Query:  query,
                Result: &amp;response,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// RestartService requests a service restart (requires appropriate permissions)
func (s *ServiceMonitoringService) RestartService(ctx context.Context, serverID string, serviceName string) error <span class="cov0" title="0">{
        path := fmt.Sprintf("/v1/servers/%s/services/%s/restart", serverID, serviceName)
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   path,
        })
        return err
}</span>

// GetServiceLogs retrieves logs for a specific service
func (s *ServiceMonitoringService) GetServiceLogs(ctx context.Context, serverID string, serviceName string, opts *ListOptions) ([]ServiceLogEntry, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("/v1/servers/%s/services/%s/logs", serverID, serviceName)
        
        var query map[string]string
        if opts != nil </span><span class="cov0" title="0">{
                query = opts.ToQuery()
        }</span>

        <span class="cov0" title="0">var logs []ServiceLogEntry
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   path,
                Query:  query,
                Result: &amp;logs,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return logs, nil</span>
}

// GetFailedServices returns all failed services across servers in an organization
func (s *ServiceMonitoringService) GetFailedServices(ctx context.Context, organizationID string) ([]*ServiceMonitoringInfo, error) <span class="cov0" title="0">{
        path := fmt.Sprintf("/v1/organizations/%s/services/failed", organizationID)
        
        var services []*ServiceMonitoringInfo
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   path,
                Result: &amp;services,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return services, nil</span>
}

// CreateServiceAlert creates an alert rule for service monitoring
func (s *ServiceMonitoringService) CreateServiceAlert(ctx context.Context, organizationID string, alertConfig ServiceAlertConfig) error <span class="cov0" title="0">{
        path := fmt.Sprintf("/v1/organizations/%s/alerts/services", organizationID)
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   path,
                Body:   alertConfig,
        })
        return err
}</span>

// ServiceAlertConfig represents configuration for service alerts
type ServiceAlertConfig struct {
        Name            string   `json:"name"`
        Description     string   `json:"description"`
        ServicePatterns []string `json:"service_patterns"`
        Conditions      []string `json:"conditions"` // e.g., "state=failed", "restart_count&gt;3"
        Severity        string   `json:"severity"`    // info, warning, critical
        Enabled         bool     `json:"enabled"`
}</pre>
		
		<pre class="file" id="file54" style="display: none">package nexmonyx

import (
        "fmt"
        "strings"
        "time"
)

// NewServiceInfo creates a new ServiceInfo instance
func NewServiceInfo() *ServiceInfo <span class="cov6" title="10">{
        return &amp;ServiceInfo{
                Services: make([]*ServiceMonitoringInfo, 0),
                Metrics:  make([]*ServiceMetrics, 0),
                Logs:     make(map[string][]ServiceLogEntry),
        }
}</span>

// AddService adds a systemd service to the service info
func (s *ServiceInfo) AddService(service *ServiceMonitoringInfo) <span class="cov7" title="14">{
        if s.Services == nil </span><span class="cov0" title="0">{
                s.Services = make([]*ServiceMonitoringInfo, 0)
        }</span>
        <span class="cov7" title="14">s.Services = append(s.Services, service)</span>
}

// AddMetrics adds metrics for a service
func (s *ServiceInfo) AddMetrics(metrics *ServiceMetrics) <span class="cov3" title="3">{
        if s.Metrics == nil </span><span class="cov0" title="0">{
                s.Metrics = make([]*ServiceMetrics, 0)
        }</span>
        <span class="cov3" title="3">s.Metrics = append(s.Metrics, metrics)</span>
}

// AddLogEntry adds a log entry for a specific service
func (s *ServiceInfo) AddLogEntry(serviceName string, logEntry ServiceLogEntry) <span class="cov5" title="6">{
        if s.Logs == nil </span><span class="cov0" title="0">{
                s.Logs = make(map[string][]ServiceLogEntry)
        }</span>
        <span class="cov5" title="6">s.Logs[serviceName] = append(s.Logs[serviceName], logEntry)</span>
}

// GetServiceByName returns a service by its name
func (s *ServiceInfo) GetServiceByName(name string) *ServiceMonitoringInfo <span class="cov2" title="2">{
        for _, service := range s.Services </span><span class="cov3" title="3">{
                if service.Name == name </span><span class="cov1" title="1">{
                        return service
                }</span>
        }
        <span class="cov1" title="1">return nil</span>
}

// GetFailedServices returns all services in failed state
func (s *ServiceInfo) GetFailedServices() []*ServiceMonitoringInfo <span class="cov1" title="1">{
        var failed []*ServiceMonitoringInfo
        for _, service := range s.Services </span><span class="cov4" title="4">{
                if service.State == "failed" </span><span class="cov2" title="2">{
                        failed = append(failed, service)
                }</span>
        }
        <span class="cov1" title="1">return failed</span>
}

// GetActiveServices returns all active services
func (s *ServiceInfo) GetActiveServices() []*ServiceMonitoringInfo <span class="cov0" title="0">{
        var active []*ServiceMonitoringInfo
        for _, service := range s.Services </span><span class="cov0" title="0">{
                if service.State == "active" </span><span class="cov0" title="0">{
                        active = append(active, service)
                }</span>
        }
        <span class="cov0" title="0">return active</span>
}

// GetServiceMetrics returns the latest metrics for a specific service
func (s *ServiceInfo) GetServiceMetrics(serviceName string) *ServiceMetrics <span class="cov1" title="1">{
        var latest *ServiceMetrics
        for _, metrics := range s.Metrics </span><span class="cov2" title="2">{
                if metrics.ServiceName == serviceName </span><span class="cov2" title="2">{
                        if latest == nil || metrics.Timestamp.After(latest.Timestamp) </span><span class="cov2" title="2">{
                                latest = metrics
                        }</span>
                }
        }
        <span class="cov1" title="1">return latest</span>
}

// CountServicesByState returns a map of service states to counts
func (s *ServiceInfo) CountServicesByState() map[string]int <span class="cov1" title="1">{
        counts := make(map[string]int)
        for _, service := range s.Services </span><span class="cov4" title="4">{
                counts[service.State]++
        }</span>
        <span class="cov1" title="1">return counts</span>
}

// GetServiceLogs returns logs for a specific service
func (s *ServiceInfo) GetServiceLogs(serviceName string) []ServiceLogEntry <span class="cov1" title="1">{
        return s.Logs[serviceName]
}</span>

// GetErrorLogs returns all error-level logs across all services
func (s *ServiceInfo) GetErrorLogs() map[string][]ServiceLogEntry <span class="cov1" title="1">{
        errorLogs := make(map[string][]ServiceLogEntry)
        for serviceName, logs := range s.Logs </span><span class="cov3" title="3">{
                for _, log := range logs </span><span class="cov5" title="5">{
                        if strings.ToLower(log.Level) == "error" || strings.ToLower(log.Level) == "err" </span><span class="cov3" title="3">{
                                errorLogs[serviceName] = append(errorLogs[serviceName], log)
                        }</span>
                }
        }
        <span class="cov1" title="1">return errorLogs</span>
}

// CalculateTotalMemoryUsage calculates total memory usage across all services
func (s *ServiceInfo) CalculateTotalMemoryUsage() uint64 <span class="cov1" title="1">{
        var total uint64
        for _, service := range s.Services </span><span class="cov3" title="3">{
                total += service.MemoryCurrent
        }</span>
        <span class="cov1" title="1">return total</span>
}

// CalculateTotalCPUTime calculates total CPU time across all services.
// Returns the maximum representable duration if the total would overflow.
func (s *ServiceInfo) CalculateTotalCPUTime() time.Duration <span class="cov0" title="0">{
        var totalNanoseconds uint64
        for _, service := range s.Services </span><span class="cov0" title="0">{
                totalNanoseconds += service.CPUUsageNSec
        }</span>
        // Safely convert uint64 nanoseconds to time.Duration (int64)
        // Cap at max duration (~292 years) if overflow would occur
        <span class="cov0" title="0">return SafeUint64ToDurationCapped(totalNanoseconds)</span>
}

// GetHighMemoryServices returns services using more than the specified memory threshold
func (s *ServiceInfo) GetHighMemoryServices(thresholdBytes uint64) []*ServiceMonitoringInfo <span class="cov0" title="0">{
        var highMemServices []*ServiceMonitoringInfo
        for _, service := range s.Services </span><span class="cov0" title="0">{
                if service.MemoryCurrent &gt; thresholdBytes </span><span class="cov0" title="0">{
                        highMemServices = append(highMemServices, service)
                }</span>
        }
        <span class="cov0" title="0">return highMemServices</span>
}

// GetRecentlyRestartedServices returns services that have been restarted
func (s *ServiceInfo) GetRecentlyRestartedServices() []*ServiceMonitoringInfo <span class="cov0" title="0">{
        var restarted []*ServiceMonitoringInfo
        for _, service := range s.Services </span><span class="cov0" title="0">{
                if service.RestartCount &gt; 0 </span><span class="cov0" title="0">{
                        restarted = append(restarted, service)
                }</span>
        }
        <span class="cov0" title="0">return restarted</span>
}

// NewServiceMonitoringConfig creates a new service monitoring configuration with defaults
func NewServiceMonitoringConfig() *ServiceMonitoringConfig <span class="cov2" title="2">{
        return &amp;ServiceMonitoringConfig{
                Enabled:         true,
                IncludeServices: []string{},
                ExcludeServices: []string{},
                IncludePatterns: []string{"ssh*", "systemd*", "network*", "cron*"},
                ExcludePatterns: []string{"*-debug", "test-*", "*.scope", "*.slice"},
                CollectMetrics:  true,
                CollectLogs:     true,
                LogLines:        100,
                MetricsInterval: "60s",
                LogStateFile:    "/var/lib/nexmonyx/service-log-state",
        }
}</span>

// ShouldMonitorService determines if a service should be monitored based on configuration
func (c *ServiceMonitoringConfig) ShouldMonitorService(serviceName string) bool <span class="cov6" title="8">{
        // Check explicit excludes first
        for _, exclude := range c.ExcludeServices </span><span class="cov2" title="2">{
                if serviceName == exclude </span><span class="cov1" title="1">{
                        return false
                }</span>
        }
        
        // Check exclude patterns
        <span class="cov6" title="7">for _, pattern := range c.ExcludePatterns </span><span class="cov9" title="25">{
                if matchPattern(serviceName, pattern) </span><span class="cov1" title="1">{
                        return false
                }</span>
        }
        
        // Check explicit includes
        <span class="cov5" title="6">for _, include := range c.IncludeServices </span><span class="cov5" title="5">{
                if serviceName == include </span><span class="cov3" title="3">{
                        return true
                }</span>
        }
        
        // Check include patterns
        <span class="cov3" title="3">for _, pattern := range c.IncludePatterns </span><span class="cov6" title="7">{
                if matchPattern(serviceName, pattern) </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        
        // If no patterns match and we have include patterns, don't monitor
        <span class="cov1" title="1">if len(c.IncludePatterns) &gt; 0 || len(c.IncludeServices) &gt; 0 </span><span class="cov1" title="1">{
                return false
        }</span>
        
        // Default to monitoring if no rules apply
        <span class="cov0" title="0">return true</span>
}

// matchPattern performs simple glob pattern matching
func matchPattern(name, pattern string) bool <span class="cov10" title="32">{
        // Simple implementation - can be enhanced
        if strings.HasPrefix(pattern, "*") &amp;&amp; strings.HasSuffix(pattern, "*") </span><span class="cov0" title="0">{
                return strings.Contains(name, pattern[1:len(pattern)-1])
        }</span> else<span class="cov10" title="32"> if strings.HasPrefix(pattern, "*") </span><span class="cov8" title="19">{
                return strings.HasSuffix(name, pattern[1:])
        }</span> else<span class="cov7" title="13"> if strings.HasSuffix(pattern, "*") </span><span class="cov7" title="13">{
                return strings.HasPrefix(name, pattern[:len(pattern)-1])
        }</span>
        <span class="cov0" title="0">return name == pattern</span>
}

// CreateServiceMetrics creates a ServiceMetrics instance from current data
func CreateServiceMetrics(serviceName string, cpuPercent float64, memoryRSS uint64, processCount, threadCount int) *ServiceMetrics <span class="cov1" title="1">{
        return &amp;ServiceMetrics{
                ServiceName:  serviceName,
                Timestamp:    time.Now(),
                CPUPercent:   cpuPercent,
                MemoryRSS:    memoryRSS,
                ProcessCount: processCount,
                ThreadCount:  threadCount,
        }
}</span>

// CreateServiceLogEntry creates a ServiceLogEntry
func CreateServiceLogEntry(level, message string) ServiceLogEntry <span class="cov1" title="1">{
        return ServiceLogEntry{
                Timestamp: time.Now(),
                Level:     level,
                Message:   message,
                Fields:    make(map[string]string),
        }
}</span>

// FormatServiceUptime formats the service uptime in a human-readable format
func FormatServiceUptime(activeSince *time.Time) string <span class="cov4" title="4">{
        if activeSince == nil </span><span class="cov1" title="1">{
                return "N/A"
        }</span>
        
        <span class="cov3" title="3">duration := time.Since(*activeSince)
        days := int(duration.Hours() / 24)
        hours := int(duration.Hours()) % 24
        minutes := int(duration.Minutes()) % 60
        
        if days &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Sprintf("%dd %dh %dm", days, hours, minutes)
        }</span> else<span class="cov2" title="2"> if hours &gt; 0 </span><span class="cov1" title="1">{
                return fmt.Sprintf("%dh %dm", hours, minutes)
        }</span>
        <span class="cov1" title="1">return fmt.Sprintf("%dm", minutes)</span>
}

// GetServiceHealth returns a health score (0-100) based on service state
func GetServiceHealth(service *ServiceMonitoringInfo) int <span class="cov5" title="5">{
        switch service.State </span>{
        case "active":<span class="cov3" title="3">
                if service.SubState == "running" </span><span class="cov2" title="2">{
                        // Penalize for restarts
                        health := 100 - (service.RestartCount * 10)
                        if health &lt; 0 </span><span class="cov0" title="0">{
                                health = 0
                        }</span>
                        <span class="cov2" title="2">return health</span>
                }
                <span class="cov1" title="1">return 75</span> // Active but not running
        case "inactive":<span class="cov1" title="1">
                return 50</span> // Service is stopped
        case "failed":<span class="cov1" title="1">
                return 0</span> // Service has failed
        default:<span class="cov0" title="0">
                return 25</span> // Unknown state
        }
}</pre>
		
		<pre class="file" id="file55" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// GetSettings retrieves settings for an organization
func (s *SettingsService) Get(ctx context.Context, organizationID string) (*Settings, error) <span class="cov10" title="3">{
        var resp StandardResponse
        resp.Data = &amp;Settings{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/organizations/%s/settings", organizationID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov6" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if settings, ok := resp.Data.(*Settings); ok </span><span class="cov1" title="1">{
                return settings, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// UpdateSettings updates settings for an organization
func (s *SettingsService) Update(ctx context.Context, organizationID string, settings *Settings) (*Settings, error) <span class="cov10" title="3">{
        var resp StandardResponse
        resp.Data = &amp;Settings{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/organizations/%s/settings", organizationID),
                Body:   settings,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov6" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if updated, ok := resp.Data.(*Settings); ok </span><span class="cov1" title="1">{
                return updated, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetNotificationSettings retrieves notification settings
func (s *SettingsService) GetNotificationSettings(ctx context.Context, organizationID string) (*NotificationSettings, error) <span class="cov10" title="3">{
        var resp StandardResponse
        resp.Data = &amp;NotificationSettings{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/organizations/%s/settings/notifications", organizationID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov6" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if settings, ok := resp.Data.(*NotificationSettings); ok </span><span class="cov1" title="1">{
                return settings, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// UpdateNotificationSettings updates notification settings
func (s *SettingsService) UpdateNotificationSettings(ctx context.Context, organizationID string, settings *NotificationSettings) (*NotificationSettings, error) <span class="cov10" title="3">{
        var resp StandardResponse
        resp.Data = &amp;NotificationSettings{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/organizations/%s/settings/notifications", organizationID),
                Body:   settings,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov6" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if updated, ok := resp.Data.(*NotificationSettings); ok </span><span class="cov1" title="1">{
                return updated, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// Settings represents organization settings
type Settings struct {
        OrganizationID       uint                   `json:"organization_id"`
        GeneralSettings      *GeneralSettings       `json:"general,omitempty"`
        SecuritySettings     *SecuritySettings      `json:"security,omitempty"`
        NotificationSettings *NotificationSettings  `json:"notifications,omitempty"`
        MonitoringSettings   *MonitoringSettings    `json:"monitoring,omitempty"`
        IntegrationSettings  *IntegrationSettings   `json:"integrations,omitempty"`
        CustomSettings       map[string]interface{} `json:"custom,omitempty"`
}

// GeneralSettings represents general organization settings
type GeneralSettings struct {
        TimeZone           string          `json:"timezone"`
        DateFormat         string          `json:"date_format"`
        TimeFormat         string          `json:"time_format"`
        Language           string          `json:"language"`
        DefaultDashboard   string          `json:"default_dashboard"`
        AllowedIPAddresses []string        `json:"allowed_ip_addresses,omitempty"`
        SessionTimeout     int             `json:"session_timeout"` // minutes
        PasswordPolicy     *PasswordPolicy `json:"password_policy,omitempty"`
}

// SecuritySettings represents security-related settings
type SecuritySettings struct {
        Require2FA        bool                   `json:"require_2fa"`
        AllowAPIKeys      bool                   `json:"allow_api_keys"`
        APIKeyExpiration  int                    `json:"api_key_expiration"` // days
        AllowedDomains    []string               `json:"allowed_domains,omitempty"`
        SSOEnabled        bool                   `json:"sso_enabled"`
        SSOProvider       string                 `json:"sso_provider,omitempty"`
        SSOConfig         map[string]interface{} `json:"sso_config,omitempty"`
        AuditLogRetention int                    `json:"audit_log_retention"` // days
}

// NotificationSettings represents notification settings
type NotificationSettings struct {
        EmailEnabled         bool                  `json:"email_enabled"`
        EmailRecipients      []string              `json:"email_recipients"`
        SlackEnabled         bool                  `json:"slack_enabled"`
        SlackWebhook         string                `json:"slack_webhook,omitempty"`
        SlackChannels        map[string]string     `json:"slack_channels,omitempty"`
        PagerDutyEnabled     bool                  `json:"pagerduty_enabled"`
        PagerDutyIntegration *PagerDutyIntegration `json:"pagerduty_integration,omitempty"`
        WebhooksEnabled      bool                  `json:"webhooks_enabled"`
        Webhooks             []WebhookConfig       `json:"webhooks,omitempty"`
        NotificationRules    []NotificationRule    `json:"notification_rules,omitempty"`
}

// MonitoringSettings represents monitoring-related settings
type MonitoringSettings struct {
        MetricsRetention       int                 `json:"metrics_retention"` // days
        DefaultInterval        int                 `json:"default_interval"`  // seconds
        EnableAutoDiscovery    bool                `json:"enable_auto_discovery"`
        AutoDiscoveryFilters   []string            `json:"auto_discovery_filters,omitempty"`
        DefaultAlertThresholds map[string]float64  `json:"default_alert_thresholds,omitempty"`
        MaintenanceWindows     []MaintenanceWindow `json:"maintenance_windows,omitempty"`
}

// IntegrationSettings represents third-party integration settings
type IntegrationSettings struct {
        AWSEnabled        bool                   `json:"aws_enabled"`
        AWSConfig         map[string]interface{} `json:"aws_config,omitempty"`
        AzureEnabled      bool                   `json:"azure_enabled"`
        AzureConfig       map[string]interface{} `json:"azure_config,omitempty"`
        GCPEnabled        bool                   `json:"gcp_enabled"`
        GCPConfig         map[string]interface{} `json:"gcp_config,omitempty"`
        DatadogEnabled    bool                   `json:"datadog_enabled"`
        DatadogConfig     map[string]interface{} `json:"datadog_config,omitempty"`
        PrometheusEnabled bool                   `json:"prometheus_enabled"`
        PrometheusConfig  map[string]interface{} `json:"prometheus_config,omitempty"`
}

// PasswordPolicy represents password policy settings
type PasswordPolicy struct {
        MinLength           int  `json:"min_length"`
        RequireUppercase    bool `json:"require_uppercase"`
        RequireLowercase    bool `json:"require_lowercase"`
        RequireNumbers      bool `json:"require_numbers"`
        RequireSpecialChars bool `json:"require_special_chars"`
        ExpirationDays      int  `json:"expiration_days"`
        HistoryCount        int  `json:"history_count"` // Prevent reuse of last N passwords
}

// PagerDutyIntegration represents PagerDuty integration settings
type PagerDutyIntegration struct {
        APIKey           string `json:"api_key"`
        ServiceID        string `json:"service_id"`
        EscalationPolicy string `json:"escalation_policy"`
}

// WebhookConfig represents a webhook configuration
type WebhookConfig struct {
        ID      string            `json:"id"`
        Name    string            `json:"name"`
        URL     string            `json:"url"`
        Secret  string            `json:"secret,omitempty"`
        Events  []string          `json:"events"`
        Enabled bool              `json:"enabled"`
        Headers map[string]string `json:"headers,omitempty"`
}

// NotificationRule represents a notification rule
type NotificationRule struct {
        ID             string                 `json:"id"`
        Name           string                 `json:"name"`
        EventType      string                 `json:"event_type"`
        Conditions     map[string]interface{} `json:"conditions"`
        Channels       []string               `json:"channels"`
        Enabled        bool                   `json:"enabled"`
        SeverityFilter []string               `json:"severity_filter,omitempty"`
}

// MaintenanceWindow represents a maintenance window
type MaintenanceWindow struct {
        ID               string      `json:"id"`
        Name             string      `json:"name"`
        StartTime        *CustomTime `json:"start_time"`
        EndTime          *CustomTime `json:"end_time"`
        Recurrence       string      `json:"recurrence,omitempty"` // daily, weekly, monthly
        AffectedServices []string    `json:"affected_services,omitempty"`
        Enabled          bool        `json:"enabled"`
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package nexmonyx

import (
        "context"
        "time"

        "github.com/google/uuid"
)

// SmartHealthService handles SMART health metrics operations
type SmartHealthService struct {
        client *Client
}

// SmartHealthMetricsSubmission represents the payload for submitting SMART health metrics
type SmartHealthMetricsSubmission struct {
        ServerUUID uuid.UUID                   `json:"server_uuid"`
        Timestamp  time.Time                   `json:"timestamp"`
        Devices    []SmartHealthDeviceMetrics  `json:"devices"`
}

// SmartHealthDeviceMetrics represents SMART health data for a single device
type SmartHealthDeviceMetrics struct {
        DeviceName      string  `json:"device_name"`
        DeviceModel     string  `json:"device_model"`
        DeviceSerial    string  `json:"device_serial"`
        DeviceType      string  `json:"device_type"` // 'ata', 'scsi', 'nvme', 'usb'
        DeviceInterface *string `json:"device_interface,omitempty"`
        FirmwareVersion *string `json:"firmware_version,omitempty"`
        CapacityBytes   *int64  `json:"capacity_bytes,omitempty"`

        // Overall health status
        OverallHealthStatus         string   `json:"overall_health_status"` // 'PASSED', 'FAILED', 'UNKNOWN'
        HealthPercentage           *float64 `json:"health_percentage,omitempty"`
        PredictedFailure           bool     `json:"predicted_failure"`
        FailurePredictionConfidence *float64 `json:"failure_prediction_confidence,omitempty"`

        // Critical SMART attributes (common across drive types)
        TemperatureCelsius      *int   `json:"temperature_celsius,omitempty"`
        PowerOnHours           *int64 `json:"power_on_hours,omitempty"`
        PowerCycleCount        *int64 `json:"power_cycle_count,omitempty"`
        ReallocatedSectorsCount *int64 `json:"reallocated_sectors_count,omitempty"`
        PendingSectorsCount    *int64 `json:"pending_sectors_count,omitempty"`
        UncorrectableErrorsCount *int64 `json:"uncorrectable_errors_count,omitempty"`

        // SSD-specific attributes
        WearLevelingCount    *int64   `json:"wear_leveling_count,omitempty"`
        ProgramFailCount     *int64   `json:"program_fail_count,omitempty"`
        EraseFailCount       *int64   `json:"erase_fail_count,omitempty"`
        TotalLBAsWritten     *int64   `json:"total_lbas_written,omitempty"`
        TotalLBAsRead        *int64   `json:"total_lbas_read,omitempty"`
        SSDLifeLeftPercent   *float64 `json:"ssd_life_left_percent,omitempty"`

        // HDD-specific attributes
        SpinRetryCount           *int64 `json:"spin_retry_count,omitempty"`
        CalibrationRetryCount    *int64 `json:"calibration_retry_count,omitempty"`
        HeadFlyingHours         *int64 `json:"head_flying_hours,omitempty"`
        LoadUnloadCycles        *int64 `json:"load_unload_cycles,omitempty"`
        SeekErrorRate           *int64 `json:"seek_error_rate,omitempty"`

        // NVMe-specific attributes
        NVMeCriticalWarning                  *int     `json:"nvme_critical_warning,omitempty"`
        NVMeCompositeTemperature            *int     `json:"nvme_composite_temperature,omitempty"`
        NVMeAvailableSparePercent           *float64 `json:"nvme_available_spare_percent,omitempty"`
        NVMeAvailableSpareThresholdPercent  *float64 `json:"nvme_available_spare_threshold_percent,omitempty"`
        NVMePercentageUsed                  *float64 `json:"nvme_percentage_used,omitempty"`
        NVMeDataUnitsRead                   *int64   `json:"nvme_data_units_read,omitempty"`
        NVMeDataUnitsWritten                *int64   `json:"nvme_data_units_written,omitempty"`
        NVMeHostReads                       *int64   `json:"nvme_host_reads,omitempty"`
        NVMeHostWrites                      *int64   `json:"nvme_host_writes,omitempty"`
        NVMeControllerBusyTime              *int64   `json:"nvme_controller_busy_time,omitempty"`
        NVMePowerCycles                     *int64   `json:"nvme_power_cycles,omitempty"`
        NVMePowerOnHours                    *int64   `json:"nvme_power_on_hours,omitempty"`
        NVMeUnsafeShutdowns                 *int64   `json:"nvme_unsafe_shutdowns,omitempty"`
        NVMeMediaErrors                     *int64   `json:"nvme_media_errors,omitempty"`
        NVMeErrorLogEntries                 *int64   `json:"nvme_error_log_entries,omitempty"`

        // Self-test results
        LastSelfTestResult               *string    `json:"last_self_test_result,omitempty"`
        LastSelfTestTimestamp           *time.Time `json:"last_self_test_timestamp,omitempty"`
        ShortSelfTestPollingMinutes     *int       `json:"short_self_test_polling_minutes,omitempty"`
        ExtendedSelfTestPollingMinutes  *int       `json:"extended_self_test_polling_minutes,omitempty"`

        // Performance degradation indicators
        ReadErrorRate          *int64 `json:"read_error_rate,omitempty"`
        ThroughputPerformance  *int64 `json:"throughput_performance,omitempty"`
        SeekTimePerformance    *int64 `json:"seek_time_performance,omitempty"`

        // Raw SMART data (JSON for extensibility)
        RawSmartAttributes map[string]interface{} `json:"raw_smart_attributes,omitempty"`

        // Health alerts and warnings
        CriticalWarnings []string `json:"critical_warnings,omitempty"`
        WarningMessages  []string `json:"warning_messages,omitempty"`
}

// Submit submits SMART health metrics to the API
func (s *SmartHealthService) Submit(ctx context.Context, submission *SmartHealthMetricsSubmission) error <span class="cov10" title="8">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v2/metrics/smart-health",
                Body:   submission,
                Result: &amp;resp,
        })
        return err
}</pre>
		
		<pre class="file" id="file57" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
        "time"
)

// SubmitSystemdServices submits systemd service data
func (s *SystemdService) Submit(ctx context.Context, request *SystemdServiceRequest) error <span class="cov1" title="1">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/systemd",
                Body:   request,
                Result: &amp;resp,
        })
        return err
}</span>

// GetSystemdServices retrieves systemd services for a server
func (s *SystemdService) Get(ctx context.Context, serverUUID string) ([]*SystemdServiceInfo, error) <span class="cov1" title="1">{
        var resp StandardResponse
        var services []*SystemdServiceInfo
        resp.Data = &amp;services

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/systemd/%s", serverUUID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return services, nil</span>
}

// ListSystemdServices lists systemd services with filters
func (s *SystemdService) List(ctx context.Context, opts *ListOptions) ([]*SystemdServiceInfo, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp PaginatedResponse
        var services []*SystemdServiceInfo
        resp.Data = &amp;services

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/systemd",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return services, resp.Meta, nil</span>
}

// GetServiceByName retrieves a specific systemd service by name
func (s *SystemdService) GetServiceByName(ctx context.Context, serverUUID, serviceName string) (*SystemdServiceInfo, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;SystemdServiceInfo{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/systemd/%s/service/%s", serverUUID, serviceName),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if service, ok := resp.Data.(*SystemdServiceInfo); ok </span><span class="cov1" title="1">{
                return service, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetSystemStats retrieves systemd system statistics
func (s *SystemdService) GetSystemStats(ctx context.Context, serverUUID string) (*SystemdSystemStats, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;SystemdSystemStats{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/systemd/%s/stats", serverUUID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov6" title="2">if stats, ok := resp.Data.(*SystemdSystemStats); ok </span><span class="cov6" title="2">{
                return stats, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// SystemdServiceRequest represents a request to submit systemd service data
type SystemdServiceRequest struct {
        ServerUUID  string               `json:"server_uuid"`
        CollectedAt string               `json:"collected_at"`
        Services    []SystemdServiceInfo `json:"services"`
        SystemStats *SystemdSystemStats  `json:"system_stats,omitempty"`
}

// SystemdServiceInfo represents information about a systemd service
type SystemdServiceInfo struct {
        Name                 string                 `json:"name"`
        UnitType             string                 `json:"unit_type"`
        Description          string                 `json:"description,omitempty"`
        LoadState            string                 `json:"load_state"`
        ActiveState          string                 `json:"active_state"`
        SubState             string                 `json:"sub_state"`
        UnitState            string                 `json:"unit_state"`
        MainPID              int                    `json:"main_pid,omitempty"`
        Type                 string                 `json:"type,omitempty"`
        User                 string                 `json:"user,omitempty"`
        Group                string                 `json:"group,omitempty"`
        WorkingDir           string                 `json:"working_dir,omitempty"`
        ExecStart            []string               `json:"exec_start,omitempty"`
        ExecReload           []string               `json:"exec_reload,omitempty"`
        ExecStop             []string               `json:"exec_stop,omitempty"`
        Environment          []string               `json:"environment,omitempty"`
        Wants                []string               `json:"wants,omitempty"`
        After                []string               `json:"after,omitempty"`
        Before               []string               `json:"before,omitempty"`
        MemoryCurrent        int64                  `json:"memory_current,omitempty"`
        MemoryPeak           int64                  `json:"memory_peak,omitempty"`
        MemoryLimit          int64                  `json:"memory_limit,omitempty"`
        CPUUsageNSec         int64                  `json:"cpu_usage_nsec,omitempty"`
        CPUUsagePercent      float64                `json:"cpu_usage_percent,omitempty"`
        TasksCurrent         int                    `json:"tasks_current,omitempty"`
        TasksLimit           int                    `json:"tasks_limit,omitempty"`
        ExitCode             int                    `json:"exit_code,omitempty"`
        ExitStatus           string                 `json:"exit_status,omitempty"`
        Result               string                 `json:"result,omitempty"`
        StatusText           string                 `json:"status_text,omitempty"`
        RestartCount         int                    `json:"restart_count,omitempty"`
        StartupDuration      float64                `json:"startup_duration,omitempty"`
        HealthScore          int                    `json:"health_score,omitempty"`
        PrivateTmp           bool                   `json:"private_tmp,omitempty"`
        PrivateNetwork       bool                   `json:"private_network,omitempty"`
        ProtectSystem        string                 `json:"protect_system,omitempty"`
        ProtectHome          string                 `json:"protect_home,omitempty"`
        NoNewPrivileges      bool                   `json:"no_new_privileges,omitempty"`
        DetectionMethod      string                 `json:"detection_method,omitempty"`
        ActiveEnterTimestamp *time.Time             `json:"active_enter_timestamp,omitempty"`
        ActiveExitTimestamp  *time.Time             `json:"active_exit_timestamp,omitempty"`
        NextElapseTime       *time.Time             `json:"next_elapse_time,omitempty"` // For timer units
        AdditionalInfo       map[string]interface{} `json:"additional_info,omitempty"`
}

// SystemdSystemStats represents system-wide systemd statistics
type SystemdSystemStats struct {
        TotalUnits         int       `json:"total_units"`
        ServiceUnits       int       `json:"service_units"`
        SocketUnits        int       `json:"socket_units"`
        TargetUnits        int       `json:"target_units"`
        TimerUnits         int       `json:"timer_units"`
        MountUnits         int       `json:"mount_units"`
        DeviceUnits        int       `json:"device_units"`
        ScopeUnits         int       `json:"scope_units"`
        SliceUnits         int       `json:"slice_units"`
        ActiveUnits        int       `json:"active_units"`
        InactiveUnits      int       `json:"inactive_units"`
        FailedUnits        int       `json:"failed_units"`
        EnabledUnits       int       `json:"enabled_units"`
        DisabledUnits      int       `json:"disabled_units"`
        MaskedUnits        int       `json:"masked_units"`
        SystemStartupTime  float64   `json:"system_startup_time"`
        LastBootTime       time.Time `json:"last_boot_time"`
        SystemManagerPID   int       `json:"system_manager_pid"`
        SystemState        string    `json:"system_state"`
        TotalMemoryUsage   int64     `json:"total_memory_usage"`
        TotalCPUUsage      float64   `json:"total_cpu_usage"`
        TotalTaskCount     int       `json:"total_task_count"`
        OverallHealthScore int       `json:"overall_health_score"`
        CriticalServices   []string  `json:"critical_services,omitempty"`
        SystemdIssues      []string  `json:"systemd_issues,omitempty"`
        RecentFailures     int       `json:"recent_failures"`
}

// Helper methods for SystemdServiceInfo

// IsHealthy returns true if the service is considered healthy
func (s *SystemdServiceInfo) IsHealthy() bool <span class="cov10" title="3">{
        return s.ActiveState == "active" &amp;&amp; s.SubState == "running" &amp;&amp; s.HealthScore &gt;= 80
}</span>

// IsFailed returns true if the service is in a failed state
func (s *SystemdServiceInfo) IsFailed() bool <span class="cov10" title="3">{
        return s.ActiveState == "failed" || s.SubState == "failed"
}</span>

// IsEnabled returns true if the service is enabled
func (s *SystemdServiceInfo) IsEnabled() bool <span class="cov6" title="2">{
        return s.UnitState == "enabled"
}</span>

// GetAdditionalInfo retrieves a value from additional info
func (s *SystemdServiceInfo) GetAdditionalInfo(key string) (interface{}, bool) <span class="cov6" title="2">{
        if s.AdditionalInfo == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov6" title="2">val, ok := s.AdditionalInfo[key]
        return val, ok</span>
}

// Helper methods for SystemdSystemStats

// IsHealthy returns true if the system is healthy
func (s *SystemdSystemStats) IsHealthy() bool <span class="cov10" title="3">{
        return s.SystemState == "running" &amp;&amp; s.FailedUnits == 0 &amp;&amp; s.OverallHealthScore &gt;= 90
}</span>

// IsDegraded returns true if the system is in degraded state
func (s *SystemdSystemStats) IsDegraded() bool <span class="cov10" title="3">{
        return s.SystemState == "degraded" || s.FailedUnits &gt; 0
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// TagsService handles tag-related operations
type TagsService struct {
        client *Client
}

// List retrieves a list of tags with optional filtering
// Authentication: JWT Token required
// Endpoint: GET /v1/tags
// Parameters:
//   - opts: Filtering and pagination options (namespace, source, key, page, limit)
func (s *TagsService) List(ctx context.Context, opts *TagListOptions) ([]*Tag, *PaginationMeta, error) <span class="cov10" title="5">{
        var resp struct {
                Data       []*Tag          `json:"data"`
                Pagination *PaginationMeta `json:"pagination"`
                Status     string          `json:"status"`
                Message    string          `json:"message"`
        }

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/tags",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov10" title="5">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov10" title="5">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return resp.Data, resp.Pagination, nil</span>
}

// Create creates a new tag
// Authentication: JWT Token required
// Endpoint: POST /v1/tags
// Parameters:
//   - req: Tag creation request with namespace, key, value, and optional description
func (s *TagsService) Create(ctx context.Context, req *TagCreateRequest) (*Tag, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *Tag   `json:"data"`
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/tags",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Data, nil</span>
}

// GetServerTags retrieves all tags assigned to a specific server
// Authentication: JWT Token required
// Endpoint: GET /v1/server/{serverID}/tags
// Parameters:
//   - serverID: Server UUID
func (s *TagsService) GetServerTags(ctx context.Context, serverID string) ([]*ServerTag, error) <span class="cov1" title="1">{
        var resp struct {
                Data    []*ServerTag `json:"data"`
                Status  string       `json:"status"`
                Message string       `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/server/%s/tags", serverID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Data, nil</span>
}

// AssignTagsToServer assigns one or more tags to a server
// Authentication: JWT Token required
// Endpoint: POST /v1/server/{serverID}/tags
// Parameters:
//   - serverID: Server UUID
//   - req: Tag assignment request with array of tag IDs
func (s *TagsService) AssignTagsToServer(ctx context.Context, serverID string, req *TagAssignRequest) (*TagAssignmentResult, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *TagAssignmentResult `json:"data"`
                Status  string               `json:"status"`
                Message string               `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/server/%s/tags", serverID),
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// RemoveTagFromServer removes a specific tag from a server
// Authentication: JWT Token required
// Endpoint: DELETE /v1/server/{serverID}/tags/{tagID}
// Parameters:
//   - serverID: Server UUID
//   - tagID: Tag ID to remove
func (s *TagsService) RemoveTagFromServer(ctx context.Context, serverID string, tagID uint) error <span class="cov1" title="1">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/server/%s/tags/%d", serverID, tagID),
                Result: &amp;resp,
        })
        return err
}</span>

// ============================================================================
// Tag Namespace Methods
// ============================================================================

// CreateNamespace creates a new tag namespace with validation rules
// Authentication: JWT Token required
// Endpoint: POST /v1/tag-namespaces
// Parameters:
//   - req: Namespace creation request with namespace name, type, patterns, and validation rules
func (s *TagsService) CreateNamespace(ctx context.Context, req *TagNamespaceCreateRequest) (*TagNamespace, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *TagNamespace `json:"data"`
                Status  string        `json:"status"`
                Message string        `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/tag-namespaces",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Data, nil</span>
}

// ListNamespaces retrieves all namespaces for the organization with optional filtering
// Authentication: JWT Token required
// Endpoint: GET /v1/tag-namespaces
// Parameters:
//   - opts: Filtering options (type, parent, active, search, hierarchy)
//
// Returns namespaces array and total count
func (s *TagsService) ListNamespaces(ctx context.Context, opts *TagNamespaceListOptions) ([]*TagNamespace, int, error) <span class="cov1" title="1">{
        var resp struct {
                Data struct {
                        Namespaces []*TagNamespace `json:"namespaces"`
                        Total      int             `json:"total"`
                } `json:"data"`
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/tag-namespaces",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov0" title="0">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return resp.Data.Namespaces, resp.Data.Total, nil</span>
}

// SetNamespacePermissions sets user or role permissions for a namespace
// Authentication: JWT Token required
// Endpoint: POST /v1/tag-namespaces/{namespace}/permissions
// Parameters:
//   - namespace: Namespace name
//   - req: Permission request with user_id OR role_name and permission flags
//
// Note: Either UserID or RoleName must be provided, but not both
func (s *TagsService) SetNamespacePermissions(ctx context.Context, namespace string, req *TagNamespacePermissionRequest) error <span class="cov1" title="1">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/tag-namespaces/%s/permissions", namespace),
                Body:   req,
                Result: &amp;resp,
        })
        return err
}</span>

// ============================================================================
// Tag Inheritance Methods
// ============================================================================

// CreateInheritanceRule creates a new tag inheritance rule for automatic propagation
// Authentication: JWT Token required
// Endpoint: POST /v1/tag-inheritance/rules
// Parameters:
//   - req: Rule creation request with source/target types, patterns, and conditions
//
// Returns the created inheritance rule with metadata
func (s *TagsService) CreateInheritanceRule(ctx context.Context, req *TagInheritanceRuleCreateRequest) (*TagInheritanceRule, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *TagInheritanceRule `json:"data"`
                Status  string              `json:"status"`
                Message string              `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/tag-inheritance/rules",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Data, nil</span>
}

// SetOrganizationTag sets a tag at the organization level with inheritance options
// Authentication: JWT Token required
// Endpoint: POST /v1/tag-inheritance/organization-tags
// Parameters:
//   - req: Organization tag request with tag ID and inheritance settings
//
// Returns the organization tag with inheritance configuration
func (s *TagsService) SetOrganizationTag(ctx context.Context, req *OrganizationTagRequest) (*OrganizationTag, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *OrganizationTag `json:"data"`
                Status  string           `json:"status"`
                Message string           `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/tag-inheritance/organization-tags",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Data, nil</span>
}

// ListOrganizationTags retrieves all tags set at the organization level
// Authentication: JWT Token required
// Endpoint: GET /v1/tag-inheritance/organization-tags
// Parameters:
//   - opts: Filtering options (inherit_only)
//
// Returns array of organization tags and total count
func (s *TagsService) ListOrganizationTags(ctx context.Context, opts *OrganizationTagListOptions) ([]*OrganizationTag, int, error) <span class="cov1" title="1">{
        var resp struct {
                Data struct {
                        Tags  []*OrganizationTag `json:"tags"`
                        Total int                `json:"total"`
                } `json:"data"`
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/tag-inheritance/organization-tags",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov0" title="0">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return resp.Data.Tags, resp.Data.Total, nil</span>
}

// RemoveOrganizationTag removes a tag from the organization level
// Authentication: JWT Token required
// Endpoint: DELETE /v1/tag-inheritance/organization-tags/{tagID}
// Parameters:
//   - tagID: Tag ID to remove from organization level
//
// This stops inheritance of the tag to all servers
func (s *TagsService) RemoveOrganizationTag(ctx context.Context, tagID uint) error <span class="cov1" title="1">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/tag-inheritance/organization-tags/%d", tagID),
                Result: &amp;resp,
        })
        return err
}</span>

// CreateServerRelationship creates a parent-child relationship between servers
// Authentication: JWT Token required
// Endpoint: POST /v1/tag-inheritance/server-relationships
// Parameters:
//   - req: Server relationship request with parent/child server IDs and inheritance settings
//
// Returns the created relationship with server information
func (s *TagsService) CreateServerRelationship(ctx context.Context, req *ServerRelationshipRequest) (*ServerParentRelationship, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *ServerParentRelationship `json:"data"`
                Status  string                    `json:"status"`
                Message string                    `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/tag-inheritance/server-relationships",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return resp.Data, nil</span>
}

// ListServerRelationships retrieves all server parent-child relationships
// Authentication: JWT Token required
// Endpoint: GET /v1/tag-inheritance/server-relationships
// Parameters:
//   - opts: Filtering options (server_id, relation_type, inherit_only)
//
// Returns array of server relationships and total count
func (s *TagsService) ListServerRelationships(ctx context.Context, opts *ServerRelationshipListOptions) ([]*ServerParentRelationship, int, error) <span class="cov1" title="1">{
        var resp struct {
                Data struct {
                        Relationships []*ServerParentRelationship `json:"relationships"`
                        Total         int                         `json:"total"`
                } `json:"data"`
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/tag-inheritance/server-relationships",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov0" title="0">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov1" title="1">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return resp.Data.Relationships, resp.Data.Total, nil</span>
}

// DeleteServerRelationship deletes a server parent-child relationship
// Authentication: JWT Token required
// Endpoint: DELETE /v1/tag-inheritance/server-relationships/{id}
// Parameters:
//   - relationshipID: Relationship ID to delete
//
// This stops tag inheritance between the parent and child servers
func (s *TagsService) DeleteServerRelationship(ctx context.Context, relationshipID uint) error <span class="cov1" title="1">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/tag-inheritance/server-relationships/%d", relationshipID),
                Result: &amp;resp,
        })
        return err
}</span>

// ============================================================================
// Tag History Methods
// ============================================================================

// GetTagHistory retrieves the complete tag change history for a specific server
// Authentication: JWT Token required
// Endpoint: GET /v1/servers/{serverID}/tags/history
// Parameters:
//   - serverID: Server ID to retrieve history for
//   - opts: Query options for filtering and pagination (action, namespace, source, date range, page, limit)
//
// Returns paginated list of tag history entries with pagination metadata
func (s *TagsService) GetTagHistory(ctx context.Context, serverID uint, opts *TagHistoryQueryParams) ([]*TagHistoryResponse, *PaginationMeta, error) <span class="cov1" title="1">{
        var resp struct {
                Data       []*TagHistoryResponse `json:"data"`
                Pagination *PaginationMeta       `json:"pagination"`
                Status     string                `json:"status"`
                Message    string                `json:"message"`
                Meta       *PaginationMeta       `json:"meta"` // Alternative location for pagination
        }

        req := &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/servers/%d/tags/history", serverID),
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Handle both pagination and meta fields (API might use either)
        <span class="cov1" title="1">pagination := resp.Pagination
        if pagination == nil </span><span class="cov0" title="0">{
                pagination = resp.Meta
        }</span>

        <span class="cov1" title="1">return resp.Data, pagination, nil</span>
}

// GetTagHistorySummary retrieves aggregated statistics about tag changes for a specific server
// Authentication: JWT Token required
// Endpoint: GET /v1/servers/{serverID}/tags/history/summary
// Parameters:
//   - serverID: Server ID to retrieve summary for
//
// Returns aggregated statistics including:
//   - Total changes count
//   - Changes grouped by action type (added, removed, modified)
//   - Changes grouped by namespace
//   - Most active users (top 5)
//   - Recent activity stats (24h, 7d, 30d)
func (s *TagsService) GetTagHistorySummary(ctx context.Context, serverID uint) (*TagHistorySummary, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *TagHistorySummary `json:"data"`
                Status  string             `json:"status"`
                Message string             `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/servers/%d/tags/history/summary", serverID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// ============================================================================
// Bulk Tag Operations
// ============================================================================

// BulkCreateTags creates multiple tags in a single operation
// Authentication: JWT Token required
// Endpoint: POST /v1/bulk/tags
// Parameters:
//   - req: Bulk tag creation request with array of tags to create
//
// Returns result with created tags, skipped tags (already exist), and counts
func (s *TagsService) BulkCreateTags(ctx context.Context, req *BulkTagCreateRequest) (*BulkTagCreateResult, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *BulkTagCreateResult `json:"data"`
                Status  string               `json:"status"`
                Message string               `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/bulk/tags",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// BulkAssignTags assigns multiple tags to multiple servers in a single operation
// Authentication: JWT Token required
// Endpoint: POST /v1/bulk/tags/assign
// Parameters:
//   - req: Bulk assignment request with server IDs and tag IDs
//
// Returns result with assigned, skipped, and total assignment counts
func (s *TagsService) BulkAssignTags(ctx context.Context, req *BulkTagAssignRequest) (*BulkTagAssignResult, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *BulkTagAssignResult `json:"data"`
                Status  string               `json:"status"`
                Message string               `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/bulk/tags/assign",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// AssignTagsToGroups assigns multiple servers to multiple groups in a single operation
// Authentication: JWT Token required
// Endpoint: POST /v1/bulk/groups/assign
// Parameters:
//   - req: Bulk group assignment request with server IDs and group IDs
//
// Returns result with assigned, skipped, and total assignment counts
// Note: Skips smart (automatic) groups automatically
func (s *TagsService) AssignTagsToGroups(ctx context.Context, req *BulkGroupAssignRequest) (*BulkGroupAssignResult, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *BulkGroupAssignResult `json:"data"`
                Status  string                 `json:"status"`
                Message string                 `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/bulk/groups/assign",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// ============================================================================
// Tag Detection Rules
// ============================================================================

// ListTagDetectionRules retrieves all tag detection rules for the organization
//
// Endpoint: GET /v1/tag-rules
// Authentication: JWT Token or API Key required
//
// Parameters:
//   - ctx: Context for request cancellation and timeouts
//   - opts: Optional filtering parameters (enabled status, namespace, pagination)
//
// Returns:
//   - rules: List of tag detection rules matching the filters
//   - total: Total number of rules matching the filters
//   - err: Error if the request fails
func (s *TagsService) ListTagDetectionRules(ctx context.Context, opts *TagDetectionRuleListOptions) ([]*TagDetectionRule, int, error) <span class="cov1" title="1">{
        var resp struct {
                Data       []*TagDetectionRule `json:"data"`
                Status     string              `json:"status"`
                Message    string              `json:"message"`
                Pagination *PaginationMeta     `json:"pagination"`
                Meta       *PaginationMeta     `json:"meta"` // Alternative location
        }

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/tag-rules",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov1" title="1">totalItems := 0
        if resp.Pagination != nil </span><span class="cov1" title="1">{
                totalItems = resp.Pagination.TotalItems
        }</span> else<span class="cov0" title="0"> if resp.Meta != nil </span><span class="cov0" title="0">{
                totalItems = resp.Meta.TotalItems
        }</span>

        <span class="cov1" title="1">return resp.Data, totalItems, nil</span>
}

// CreateDefaultRules creates default tag detection rules for the organization
//
// Endpoint: POST /v1/tag-rules/defaults
// Authentication: JWT Token or API Key required
//
// This creates a standard set of detection rules for common infrastructure patterns.
//
// Parameters:
//   - ctx: Context for request cancellation and timeouts
//
// Returns:
//   - result: Result containing the count of created rules
//   - err: Error if the request fails
func (s *TagsService) CreateDefaultRules(ctx context.Context) (*DefaultRulesCreateResult, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *DefaultRulesCreateResult `json:"data"`
                Status  string                    `json:"status"`
                Message string                    `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/tag-rules/defaults",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// EvaluateRules evaluates tag detection rules for specified servers
//
// Endpoint: POST /v1/tag-rules/evaluate
// Authentication: JWT Token or API Key required
//
// This triggers asynchronous evaluation of tag detection rules. Rules are evaluated
// in the background and matching tags are automatically assigned to servers.
//
// Parameters:
//   - ctx: Context for request cancellation and timeouts
//   - req: Request specifying which servers to evaluate (specific IDs or all servers)
//
// Returns:
//   - result: Result containing the count of servers queued for processing
//   - err: Error if the request fails
func (s *TagsService) EvaluateRules(ctx context.Context, req *EvaluateRulesRequest) (*EvaluateRulesResult, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *EvaluateRulesResult `json:"data"`
                Status  string               `json:"status"`
                Message string               `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/tag-rules/evaluate",
                Body:   req,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// TasksService handles task management, scheduling, and workflow automation
type TasksService struct {
        client *Client
}

// CreateTask creates a new task with specified configuration
// Authentication: JWT Token required
// Endpoint: POST /v1/tasks
// Parameters:
//   - config: Task configuration including type, parameters, and scheduling
// Returns: Created Task object
func (s *TasksService) CreateTask(ctx context.Context, config *TaskConfiguration) (*Task, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *Task  `json:"data"`
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/tasks",
                Body:   config,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// ListTasks retrieves a list of tasks with filtering and pagination
// Authentication: JWT Token required
// Endpoint: GET /v1/tasks
// Parameters:
//   - opts: Optional pagination options
//   - filters: Optional filters (status, type, priority, scheduled_after, scheduled_before)
// Returns: Array of Task objects with pagination metadata
func (s *TasksService) ListTasks(ctx context.Context, opts *PaginationOptions, filters map[string]interface{}) ([]Task, *PaginationMeta, error) <span class="cov10" title="6">{
        var resp struct {
                Data []Task          `json:"data"`
                Meta *PaginationMeta `json:"meta"`
        }

        queryParams := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        queryParams["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }

        // Add filter parameters
        <span class="cov10" title="6">if filters != nil </span><span class="cov1" title="1">{
                if status, ok := filters["status"].(string); ok &amp;&amp; status != "" </span><span class="cov1" title="1">{
                        queryParams["status"] = status
                }</span>
                <span class="cov1" title="1">if taskType, ok := filters["type"].(string); ok &amp;&amp; taskType != "" </span><span class="cov1" title="1">{
                        queryParams["type"] = taskType
                }</span>
                <span class="cov1" title="1">if priority, ok := filters["priority"].(string); ok &amp;&amp; priority != "" </span><span class="cov1" title="1">{
                        queryParams["priority"] = priority
                }</span>
                <span class="cov1" title="1">if scheduledAfter, ok := filters["scheduled_after"].(string); ok &amp;&amp; scheduledAfter != "" </span><span class="cov0" title="0">{
                        queryParams["scheduled_after"] = scheduledAfter
                }</span>
                <span class="cov1" title="1">if scheduledBefore, ok := filters["scheduled_before"].(string); ok &amp;&amp; scheduledBefore != "" </span><span class="cov0" title="0">{
                        queryParams["scheduled_before"] = scheduledBefore
                }</span>
        }

        <span class="cov10" title="6">req := &amp;Request{
                Method: "GET",
                Path:   "/v1/tasks",
                Result: &amp;resp,
        }
        if len(queryParams) &gt; 0 </span><span class="cov4" title="2">{
                req.Query = queryParams
        }</span>

        <span class="cov10" title="6">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov7" title="4">{
                return nil, nil, err
        }</span>

        <span class="cov4" title="2">return resp.Data, resp.Meta, nil</span>
}

// GetTask retrieves a specific task by ID
// Authentication: JWT Token required
// Endpoint: GET /v1/tasks/{id}
// Parameters:
//   - taskID: Task ID
// Returns: Task object with full details including execution history
func (s *TasksService) GetTask(ctx context.Context, taskID uint) (*Task, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *Task  `json:"data"`
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/tasks/%d", taskID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// UpdateTaskStatus updates the status of a task
// Authentication: JWT Token required
// Endpoint: PUT /v1/tasks/{id}/status
// Parameters:
//   - taskID: Task ID
//   - status: New status (pending, running, completed, failed, cancelled)
//   - result: Optional result data for completed/failed tasks
// Returns: Updated Task object
func (s *TasksService) UpdateTaskStatus(ctx context.Context, taskID uint, status string, result map[string]interface{}) (*Task, error) <span class="cov1" title="1">{
        var resp struct {
                Data    *Task  `json:"data"`
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        body := map[string]interface{}{
                "status": status,
        }
        if result != nil </span><span class="cov1" title="1">{
                body["result"] = result
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/tasks/%d/status", taskID),
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// CancelTask cancels a pending or running task
// Authentication: JWT Token required
// Endpoint: POST /v1/tasks/{id}/cancel
// Parameters:
//   - taskID: Task ID
// Returns: Error if cancellation fails
func (s *TasksService) CancelTask(ctx context.Context, taskID uint) error <span class="cov1" title="1">{
        var resp struct {
                Status  string `json:"status"`
                Message string `json:"message"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/tasks/%d/cancel", taskID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package nexmonyx

import "fmt"

// NewTemperatureMetrics creates a new TemperatureMetrics instance
func NewTemperatureMetrics() *TemperatureMetrics <span class="cov7" title="7">{
        return &amp;TemperatureMetrics{
                Sensors: make([]TemperatureSensorData, 0),
        }
}</span>

// AddTemperatureSensor adds a temperature sensor reading
func (t *TemperatureMetrics) AddTemperatureSensor(sensor TemperatureSensorData) <span class="cov8" title="10">{
        if t.Sensors == nil </span><span class="cov1" title="1">{
                t.Sensors = make([]TemperatureSensorData, 0)
        }</span>
        <span class="cov8" title="10">t.Sensors = append(t.Sensors, sensor)</span>
}

// GetSensorByID returns a temperature sensor by its ID
func (t *TemperatureMetrics) GetSensorByID(sensorID string) *TemperatureSensorData <span class="cov4" title="3">{
        for i := range t.Sensors </span><span class="cov4" title="3">{
                if t.Sensors[i].SensorID == sensorID </span><span class="cov1" title="1">{
                        return &amp;t.Sensors[i]
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// GetSensorsByType returns all temperature sensors of a specific type
func (t *TemperatureMetrics) GetSensorsByType(sensorType string) []TemperatureSensorData <span class="cov5" title="4">{
        var sensors []TemperatureSensorData
        for _, sensor := range t.Sensors </span><span class="cov8" title="12">{
                if sensor.Type == sensorType </span><span class="cov4" title="3">{
                        sensors = append(sensors, sensor)
                }</span>
        }
        <span class="cov5" title="4">return sensors</span>
}

// GetMaxTemperature returns the maximum temperature across all sensors
func (t *TemperatureMetrics) GetMaxTemperature() (float64, string) <span class="cov3" title="2">{
        if len(t.Sensors) == 0 </span><span class="cov1" title="1">{
                return 0, ""
        }</span>
        
        <span class="cov1" title="1">maxTemp := t.Sensors[0].Temperature
        maxSensorName := t.Sensors[0].SensorName
        
        for _, sensor := range t.Sensors[1:] </span><span class="cov1" title="1">{
                if sensor.Temperature &gt; maxTemp </span><span class="cov1" title="1">{
                        maxTemp = sensor.Temperature
                        maxSensorName = sensor.SensorName
                }</span>
        }
        
        <span class="cov1" title="1">return maxTemp, maxSensorName</span>
}

// NewPowerMetrics creates a new PowerMetrics instance
func NewPowerMetrics() *PowerMetrics <span class="cov8" title="11">{
        return &amp;PowerMetrics{
                PowerSupplies: make([]PowerSupplyMetrics, 0),
        }
}</span>

// AddPowerSupply adds power supply metrics
func (p *PowerMetrics) AddPowerSupply(ps PowerSupplyMetrics) <span class="cov5" title="4">{
        if p.PowerSupplies == nil </span><span class="cov1" title="1">{
                p.PowerSupplies = make([]PowerSupplyMetrics, 0)
        }</span>
        <span class="cov5" title="4">p.PowerSupplies = append(p.PowerSupplies, ps)
        
        // Update total power
        p.TotalPowerW = p.CalculateTotalPower()</span>
}

// CalculateTotalPower calculates the total power consumption across all power supplies
func (p *PowerMetrics) CalculateTotalPower() float64 <span class="cov6" title="5">{
        total := 0.0
        for _, ps := range p.PowerSupplies </span><span class="cov7" title="8">{
                total += ps.PowerWatts
        }</span>
        <span class="cov6" title="5">return total</span>
}

// GetPowerSupplyByID returns a power supply by its ID
func (p *PowerMetrics) GetPowerSupplyByID(id string) *PowerSupplyMetrics <span class="cov4" title="3">{
        for i := range p.PowerSupplies </span><span class="cov4" title="3">{
                if p.PowerSupplies[i].ID == id </span><span class="cov1" title="1">{
                        return &amp;p.PowerSupplies[i]
                }</span>
        }
        <span class="cov3" title="2">return nil</span>
}

// GetFailedPowerSupplies returns all power supplies with failed status
func (p *PowerMetrics) GetFailedPowerSupplies() []PowerSupplyMetrics <span class="cov4" title="3">{
        var failed []PowerSupplyMetrics
        for _, ps := range p.PowerSupplies </span><span class="cov7" title="7">{
                if ps.Status == "failed" || ps.Status == "critical" </span><span class="cov3" title="2">{
                        failed = append(failed, ps)
                }</span>
        }
        <span class="cov4" title="3">return failed</span>
}

// CalculateAverageEfficiency calculates the average efficiency across all power supplies
func (p *PowerMetrics) CalculateAverageEfficiency() float64 <span class="cov5" title="4">{
        if len(p.PowerSupplies) == 0 </span><span class="cov1" title="1">{
                return 0
        }</span>
        
        <span class="cov4" title="3">totalEfficiency := 0.0
        count := 0
        
        for _, ps := range p.PowerSupplies </span><span class="cov8" title="10">{
                if ps.Efficiency &gt; 0 </span><span class="cov6" title="5">{
                        totalEfficiency += ps.Efficiency
                        count++
                }</span>
        }
        
        <span class="cov4" title="3">if count == 0 </span><span class="cov1" title="1">{
                return 0
        }</span>
        
        <span class="cov3" title="2">return totalEfficiency / float64(count)</span>
}

// DetermineTemperatureStatus determines the status based on temperature and thresholds
func DetermineTemperatureStatus(temp, warning, critical float64) string <span class="cov10" title="18">{
        if temp &gt;= critical &amp;&amp; critical &gt; 0 </span><span class="cov6" title="5">{
                return "critical"
        }</span> else<span class="cov8" title="13"> if temp &gt;= warning &amp;&amp; warning &gt; 0 </span><span class="cov6" title="6">{
                return "warning"
        }</span>
        <span class="cov7" title="7">return "ok"</span>
}

// CreateCPUTemperatureSensor creates a temperature sensor for CPU
func CreateCPUTemperatureSensor(coreID int, temp float64) TemperatureSensorData <span class="cov5" title="4">{
        sensorID := fmt.Sprintf("cpu_core_%d", coreID)
        return TemperatureSensorData{
                SensorID:      sensorID,
                SensorName:    fmt.Sprintf("CPU Core %d", coreID),
                Temperature:   temp,
                Status:        DetermineTemperatureStatus(temp, 75.0, 90.0),
                Type:          "cpu",
                Location:      "processor",
                UpperWarning:  75.0,
                UpperCritical: 90.0,
        }
}</span>

// CreateDiskTemperatureSensor creates a temperature sensor for disk
func CreateDiskTemperatureSensor(device string, temp float64) TemperatureSensorData <span class="cov4" title="3">{
        return TemperatureSensorData{
                SensorID:      "disk_" + device,
                SensorName:    "Disk " + device,
                Temperature:   temp,
                Status:        DetermineTemperatureStatus(temp, 50.0, 60.0),
                Type:          "disk",
                Location:      "storage",
                UpperWarning:  50.0,
                UpperCritical: 60.0,
        }
}</span>

// CreateSystemTemperatureSensor creates a generic system temperature sensor
func CreateSystemTemperatureSensor(name string, temp float64) TemperatureSensorData <span class="cov4" title="3">{
        return TemperatureSensorData{
                SensorID:      "system_" + name,
                SensorName:    name,
                Temperature:   temp,
                Status:        DetermineTemperatureStatus(temp, 60.0, 75.0),
                Type:          "system",
                UpperWarning:  60.0,
                UpperCritical: 75.0,
        }
}</pre>
		
		<pre class="file" id="file61" style="display: none">package nexmonyx

// Test helper functions

func testStringPtr(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>

func testUintPtr(u uint) *uint <span class="cov0" title="0">{
        return &amp;u
}</span>

func testIntPtr(i int) *int <span class="cov0" title="0">{
        return &amp;i
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// GetUser retrieves a user by ID
func (s *UsersService) Get(ctx context.Context, id string) (*User, error) <span class="cov10" title="3">{
        var resp StandardResponse
        resp.Data = &amp;User{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/users/%s", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov6" title="2">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if user, ok := resp.Data.(*User); ok </span><span class="cov1" title="1">{
                return user, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// GetUserByEmail retrieves a user by email
func (s *UsersService) GetByEmail(ctx context.Context, email string) (*User, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;User{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/v1/users/email/%s", email),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if user, ok := resp.Data.(*User); ok </span><span class="cov1" title="1">{
                return user, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ListUsers retrieves a list of users
func (s *UsersService) List(ctx context.Context, opts *ListOptions) ([]*User, *PaginationMeta, error) <span class="cov6" title="2">{
        var resp PaginatedResponse
        var users []*User
        resp.Data = &amp;users

        req := &amp;Request{
                Method: "GET",
                Path:   "/v1/users",
                Result: &amp;resp,
        }

        if opts != nil </span><span class="cov1" title="1">{
                req.Query = opts.ToQuery()
        }</span>

        <span class="cov6" title="2">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov6" title="2">return users, resp.Meta, nil</span>
}

// CreateUser creates a new user
func (s *UsersService) Create(ctx context.Context, user *User) (*User, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;User{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/users",
                Body:   user,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if created, ok := resp.Data.(*User); ok </span><span class="cov1" title="1">{
                return created, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// UpdateUser updates an existing user
func (s *UsersService) Update(ctx context.Context, id string, user *User) (*User, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;User{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/users/%s", id),
                Body:   user,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if updated, ok := resp.Data.(*User); ok </span><span class="cov1" title="1">{
                return updated, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// DeleteUser deletes a user
func (s *UsersService) Delete(ctx context.Context, id string) error <span class="cov6" title="2">{
        var resp StandardResponse

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/v1/users/%s", id),
                Result: &amp;resp,
        })
        return err
}</span>

// GetCurrentUser retrieves the currently authenticated user
func (s *UsersService) GetCurrent(ctx context.Context) (*User, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;User{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   "/v1/users/me",
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if user, ok := resp.Data.(*User); ok </span><span class="cov1" title="1">{
                return user, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// UpdateUserRole updates a user's role
func (s *UsersService) UpdateRole(ctx context.Context, id string, role string) (*User, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;User{}

        body := map[string]interface{}{
                "role": role,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/users/%s/role", id),
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if user, ok := resp.Data.(*User); ok </span><span class="cov1" title="1">{
                return user, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// UpdateUserPermissions updates a user's permissions
func (s *UsersService) UpdatePermissions(ctx context.Context, id string, permissions []string) (*User, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;User{}

        body := map[string]interface{}{
                "permissions": permissions,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/users/%s/permissions", id),
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if user, ok := resp.Data.(*User); ok </span><span class="cov1" title="1">{
                return user, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// UpdateUserPreferences updates a user's preferences
func (s *UsersService) UpdatePreferences(ctx context.Context, id string, preferences map[string]interface{}) (*User, error) <span class="cov1" title="1">{
        var resp StandardResponse
        resp.Data = &amp;User{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "PUT",
                Path:   fmt.Sprintf("/v1/users/%s/preferences", id),
                Body:   preferences,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if user, ok := resp.Data.(*User); ok </span><span class="cov1" title="1">{
                return user, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// ResetUserPassword sends a password reset email
func (s *UsersService) ResetPassword(ctx context.Context, email string) error <span class="cov6" title="2">{
        var resp StandardResponse

        body := map[string]interface{}{
                "email": email,
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/v1/users/reset-password",
                Body:   body,
                Result: &amp;resp,
        })
        return err
}</span>

// EnableUser enables a user account
func (s *UsersService) Enable(ctx context.Context, id string) (*User, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;User{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/users/%s/enable", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if user, ok := resp.Data.(*User); ok </span><span class="cov1" title="1">{
                return user, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}

// DisableUser disables a user account
func (s *UsersService) Disable(ctx context.Context, id string) (*User, error) <span class="cov6" title="2">{
        var resp StandardResponse
        resp.Data = &amp;User{}

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/v1/users/%s/disable", id),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">if user, ok := resp.Data.(*User); ok </span><span class="cov1" title="1">{
                return user, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("unexpected response type")</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package nexmonyx

import (
        "strings"
        "time"
)

// AggregateDiskUsage calculates overall disk usage from individual disk metrics
// This function applies filtering rules to exclude virtual/temporary filesystems
// and returns aggregated statistics across all valid filesystems.
func AggregateDiskUsage(disks []DiskMetrics) *DiskUsageAggregate <span class="cov4" title="8">{
        var total, used, free uint64
        var largestMount string
        var largestSize uint64
        validCount := 0
        
        // Initialize empty slice to avoid nil
        criticalMounts := make([]string, 0)

        for _, disk := range disks </span><span class="cov5" title="12">{
                // Apply filtering rules to exclude virtual/temporary filesystems
                if !shouldIncludeInAggregation(disk) </span><span class="cov2" title="2">{
                        continue</span>
                }

                // Safely convert int64 to uint64 for aggregation
                // Negative values indicate invalid data and are treated as zero
                <span class="cov4" title="10">totalBytes := SafeInt64ToUint64OrZero(disk.TotalBytes)
                usedBytes := SafeInt64ToUint64OrZero(disk.UsedBytes)
                freeBytes := SafeInt64ToUint64OrZero(disk.FreeBytes)

                // Skip disks with invalid/zero total size
                if totalBytes == 0 </span><span class="cov1" title="1">{
                        continue</span>
                }

                <span class="cov4" title="9">total += totalBytes
                used += usedBytes
                free += freeBytes
                validCount++

                // Track largest mount by total capacity
                if totalBytes &gt; largestSize </span><span class="cov4" title="7">{
                        largestSize = totalBytes
                        largestMount = disk.Mountpoint
                }</span>

                // Track critical mounts (&gt;90% full)
                <span class="cov4" title="9">if disk.UsagePercent &gt; 90.0 </span><span class="cov2" title="3">{
                        criticalMounts = append(criticalMounts, disk.Mountpoint)
                }</span>
        }

        // Calculate overall usage percentage
        <span class="cov4" title="8">var usedPercent float64
        if total &gt; 0 </span><span class="cov4" title="6">{
                usedPercent = float64(used) / float64(total) * 100.0
        }</span>

        <span class="cov4" title="8">return &amp;DiskUsageAggregate{
                TotalBytes:      total,
                UsedBytes:       used,
                FreeBytes:       free,
                UsedPercent:     usedPercent,
                FilesystemCount: validCount,
                LargestMount:    largestMount,
                CriticalMounts:  criticalMounts,
                CalculatedAt:    time.Now().UTC().Format(time.RFC3339),
        }</span>
}

// shouldIncludeInAggregation determines if a filesystem should be included in aggregation
// This function filters out virtual, temporary, and system filesystems that should not
// be included in disk usage calculations.
func shouldIncludeInAggregation(disk DiskMetrics) bool <span class="cov6" title="20">{
        // INCLUDE these filesystem types
        includedTypes := map[string]bool{
                "ext4": true, "ext3": true, "ext2": true,
                "xfs": true, "btrfs": true, "zfs": true,
                "ntfs": true, "apfs": true, "hfs+": true,
                "reiserfs": true, "jfs": true,
                "nfs": true, "nfs4": true, "cifs": true, "smb": true,
                "glusterfs": true, "lustre": true,
                "overlay": true, "aufs": true,
        }

        // EXCLUDE these filesystem types
        excludedTypes := map[string]bool{
                "tmpfs": true, "devtmpfs": true, "sysfs": true,
                "proc": true, "devpts": true, "debugfs": true,
                "tracefs": true, "securityfs": true, "cgroup": true,
                "cgroup2": true, "pstore": true, "bpf": true,
                "autofs": true, "mqueue": true, "hugetlbfs": true,
                "fusectl": true, "configfs": true, "ramfs": true,
                "rpc_pipefs": true, "fuse.gvfsd-fuse": true,
                "fuse.portal": true, "efivarfs": true, "binfmt_misc": true,
        }

        // EXCLUDE these mount point patterns
        excludedMountPrefixes := []string{
                "/tmp", "/var/tmp", "/dev/shm",
                "/sys/", "/proc/", "/dev/",
                "/boot/efi", "/boot/EFI",
                "/var/lib/docker/overlay2/",
                "/var/lib/kubelet/pods/",
                "/snap/",
                "/run/systemd/",
        }

        // Check if filesystem type should be excluded
        if excludedTypes[disk.Filesystem] </span><span class="cov3" title="4">{
                return false
        }</span>

        // Check if mount point should be excluded
        <span class="cov5" title="16">for _, prefix := range excludedMountPrefixes </span><span class="cov10" title="188">{
                if strings.HasPrefix(disk.Mountpoint, prefix) </span><span class="cov2" title="2">{
                        return false
                }</span>
        }

        // Check if filesystem type should be included
        <span class="cov5" title="14">if includedTypes[disk.Filesystem] </span><span class="cov5" title="13">{
                return true
        }</span>

        // Default to exclude unknown filesystem types
        <span class="cov1" title="1">return false</span>
}

// AggregateDiskUsageFromRequest is a convenience function that extracts disk metrics
// from a ComprehensiveMetricsRequest and calculates the aggregated disk usage.
// This is useful when you want to calculate aggregation from an existing metrics request.
func AggregateDiskUsageFromRequest(request *ComprehensiveMetricsRequest) *DiskUsageAggregate <span class="cov2" title="3">{
        if request == nil || request.Disks == nil </span><span class="cov2" title="2">{
                return &amp;DiskUsageAggregate{
                        TotalBytes:      0,
                        UsedBytes:       0,
                        FreeBytes:       0,
                        UsedPercent:     0,
                        FilesystemCount: 0,
                        LargestMount:    "",
                        CriticalMounts:  make([]string, 0),
                        CalculatedAt:    time.Now().UTC().Format(time.RFC3339),
                }
        }</span>

        <span class="cov1" title="1">return AggregateDiskUsage(request.Disks)</span>
}

// ValidateDiskUsageAggregate validates that the DiskUsageAggregate struct contains
// consistent and valid data. Returns true if valid, false otherwise.
func ValidateDiskUsageAggregate(aggregate *DiskUsageAggregate) bool <span class="cov4" title="6">{
        if aggregate == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check that TotalBytes = UsedBytes + FreeBytes (with some tolerance for rounding)
        <span class="cov3" title="5">expectedTotal := aggregate.UsedBytes + aggregate.FreeBytes
        tolerance := uint64(1024 * 1024) // 1MB tolerance for rounding differences

        if aggregate.TotalBytes &gt; expectedTotal+tolerance || expectedTotal &gt; aggregate.TotalBytes+tolerance </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check that usage percentage is consistent
        <span class="cov3" title="4">if aggregate.TotalBytes &gt; 0 </span><span class="cov3" title="4">{
                expectedPercent := float64(aggregate.UsedBytes) / float64(aggregate.TotalBytes) * 100.0
                tolerance := 1.0 // 1% tolerance for rounding
                if expectedPercent &gt; aggregate.UsedPercent+tolerance || aggregate.UsedPercent &gt; expectedPercent+tolerance </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        // Check that usage percentage is within valid range
        <span class="cov2" title="3">if aggregate.UsedPercent &lt; 0 || aggregate.UsedPercent &gt; 100 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check that filesystem count is non-negative
        <span class="cov2" title="3">if aggregate.FilesystemCount &lt; 0 </span><span class="cov1" title="1">{
                return false
        }</span>

        // Validate timestamp format
        <span class="cov2" title="2">if aggregate.CalculatedAt != "" </span><span class="cov2" title="2">{
                if _, err := time.Parse(time.RFC3339, aggregate.CalculatedAt); err != nil </span><span class="cov1" title="1">{
                        return false
                }</span>
        }

        <span class="cov1" title="1">return true</span>
}</pre>
		
		<pre class="file" id="file64" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
)

// VMsService handles virtual machine management operations
type VMsService struct {
        client *Client
}

// List retrieves a list of virtual machines
// Authentication: JWT Token required
// Endpoint: GET /api/v1/vms
// Parameters:
//   - opts: Optional pagination options
// Returns: Array of VirtualMachine objects with pagination metadata
func (s *VMsService) List(ctx context.Context, opts *PaginationOptions) ([]VirtualMachine, *PaginationMeta, error) <span class="cov10" title="5">{
        var resp struct {
                Data []VirtualMachine `json:"data"`
                Meta *PaginationMeta  `json:"meta"`
        }

        query := make(map[string]string)
        if opts != nil </span><span class="cov1" title="1">{
                if opts.Page &gt; 0 </span><span class="cov1" title="1">{
                        query["page"] = fmt.Sprintf("%d", opts.Page)
                }</span>
                <span class="cov1" title="1">if opts.Limit &gt; 0 </span><span class="cov1" title="1">{
                        query["limit"] = fmt.Sprintf("%d", opts.Limit)
                }</span>
        }

        <span class="cov10" title="5">req := &amp;Request{
                Method: "GET",
                Path:   "/api/v1/vms",
                Result: &amp;resp,
        }
        if len(query) &gt; 0 </span><span class="cov1" title="1">{
                req.Query = query
        }</span>

        <span class="cov10" title="5">_, err := s.client.Do(ctx, req)
        if err != nil </span><span class="cov8" title="4">{
                return nil, nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, resp.Meta, nil</span>
}

// Create creates a new virtual machine
// Authentication: JWT Token required
// Endpoint: POST /api/v1/vms
// Parameters:
//   - config: VM configuration (name, CPU, memory, storage, etc.)
// Returns: Created VirtualMachine object
func (s *VMsService) Create(ctx context.Context, config *VMConfiguration) (*VirtualMachine, error) <span class="cov1" title="1">{
        var resp struct {
                Data *VirtualMachine `json:"data"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   "/api/v1/vms",
                Body:   config,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// Get retrieves details of a specific virtual machine
// Authentication: JWT Token required
// Endpoint: GET /api/v1/vms/{id}
// Parameters:
//   - vmID: Virtual machine ID
// Returns: VirtualMachine object with full details
func (s *VMsService) Get(ctx context.Context, vmID uint) (*VirtualMachine, error) <span class="cov1" title="1">{
        var resp struct {
                Data *VirtualMachine `json:"data"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "GET",
                Path:   fmt.Sprintf("/api/v1/vms/%d", vmID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// Delete deletes a virtual machine
// Authentication: JWT Token required
// Endpoint: DELETE /api/v2/organizations/{orgId}/virtual-machines/{vmId}
// Parameters:
//   - orgID: Organization ID
//   - vmID: Virtual machine ID
// Returns: Success confirmation
func (s *VMsService) Delete(ctx context.Context, orgID uint, vmID uint) error <span class="cov1" title="1">{
        _, err := s.client.Do(ctx, &amp;Request{
                Method: "DELETE",
                Path:   fmt.Sprintf("/api/v2/organizations/%d/virtual-machines/%d", orgID, vmID),
        })
        return err
}</span>

// Start starts a stopped virtual machine
// Authentication: JWT Token required
// Endpoint: POST /api/v2/organizations/{orgId}/virtual-machines/{vmId}/start
// Parameters:
//   - orgID: Organization ID
//   - vmID: Virtual machine ID
// Returns: VMOperation object with operation status
func (s *VMsService) Start(ctx context.Context, orgID uint, vmID uint) (*VMOperation, error) <span class="cov1" title="1">{
        var resp struct {
                Data *VMOperation `json:"data"`
        }

        _, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/api/v2/organizations/%d/virtual-machines/%d/start", orgID, vmID),
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}

// Stop stops a running virtual machine
// Authentication: JWT Token required
// Endpoint: POST /api/v2/organizations/{orgId}/virtual-machines/{vmId}/stop
// Parameters:
//   - orgID: Organization ID
//   - vmID: Virtual machine ID
//   - force: Optional force flag for immediate shutdown (default: graceful)
// Returns: VMOperation object with operation status
func (s *VMsService) Stop(ctx context.Context, orgID uint, vmID uint, force bool) (*VMOperation, error) <span class="cov4" title="2">{
        var resp struct {
                Data *VMOperation `json:"data"`
        }

        body := map[string]interface{}{}
        if force </span><span class="cov1" title="1">{
                body["force"] = true
        }</span>

        <span class="cov4" title="2">_, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/api/v2/organizations/%d/virtual-machines/%d/stop", orgID, vmID),
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov4" title="2">return resp.Data, nil</span>
}

// Restart restarts a virtual machine
// Authentication: JWT Token required
// Endpoint: POST /api/v2/organizations/{orgId}/virtual-machines/{vmId}/restart
// Parameters:
//   - orgID: Organization ID
//   - vmID: Virtual machine ID
//   - force: Optional force flag for immediate restart (default: graceful)
// Returns: VMOperation object with operation status
func (s *VMsService) Restart(ctx context.Context, orgID uint, vmID uint, force bool) (*VMOperation, error) <span class="cov1" title="1">{
        var resp struct {
                Data *VMOperation `json:"data"`
        }

        body := map[string]interface{}{}
        if force </span><span class="cov0" title="0">{
                body["force"] = true
        }</span>

        <span class="cov1" title="1">_, err := s.client.Do(ctx, &amp;Request{
                Method: "POST",
                Path:   fmt.Sprintf("/api/v2/organizations/%d/virtual-machines/%d/restart", orgID, vmID),
                Body:   body,
                Result: &amp;resp,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return resp.Data, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package nexmonyx

import (
        "context"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        "github.com/gorilla/websocket"
)

// WebSocketServiceImpl provides WebSocket communication capabilities for sending commands to agents
type WebSocketServiceImpl struct {
        client *Client
        
        // Connection management
        conn       *websocket.Conn
        connected  bool
        connecting bool
        mu         sync.RWMutex
        
        // Message correlation
        pendingResponses map[string]chan *WSCommandResponse
        responseMutex    sync.RWMutex
        
        // Configuration
        timeout         time.Duration
        reconnectDelay  time.Duration
        maxReconnects   int
        
        // Context for connection management
        ctx    context.Context
        cancel context.CancelFunc
        
        // Message handlers
        onConnect    func()
        onDisconnect func(error)
        onMessage    func(*WSMessage)
}

// WebSocket message types matching the API WebSocket manager
const (
        WSTypeAuth            = "auth"
        WSTypeAuthResponse    = "auth_response"
        WSTypePing            = "ping"
        WSTypePong            = "pong"
        WSTypeCommand         = "command"
        WSTypeCommandResponse = "command_response"
        WSTypeRequest         = "request"
        WSTypeRequestResponse = "request_response"
        WSTypeUpdateProgress  = "update_progress"
        WSTypeError           = "error"

        // WSProtocolVersion is the WebSocket protocol version
        WSProtocolVersion = "1.0"
)

// WSMessage represents a WebSocket message
type WSMessage struct {
        Type      string          `json:"type"`
        ID        string          `json:"id,omitempty"`
        Timestamp int64           `json:"timestamp,omitempty"`
        Priority  int             `json:"priority,omitempty"` // 0=normal, 1=high, 2=urgent
        Payload   json.RawMessage `json:"payload,omitempty"`
}

// WSAuthPayload represents authentication payload
type WSAuthPayload struct {
        ServerUUID      string   `json:"server_uuid"`
        ServerSecret    string   `json:"server_secret"`
        AgentVersion    string   `json:"agent_version"`
        ProtocolVersion string   `json:"protocol_version"`         // WebSocket protocol version (e.g., "1.0")
        Capabilities    []string `json:"capabilities"`
        OrganizationID  int      `json:"organization_id,omitempty"` // Optional organization ID
}

// WSAuthResponsePayload represents authentication response
type WSAuthResponsePayload struct {
        Status            string `json:"status"`
        SessionID         string `json:"session_id"`
        HeartbeatInterval int    `json:"heartbeat_interval"`
        Error             string `json:"error,omitempty"`
}

// WSCommandPayload represents a command message
type WSCommandPayload struct {
        Command string          `json:"command"`
        Payload json.RawMessage `json:"payload"`
}

// WSCommandResponse represents the response from a command execution
type WSCommandResponse struct {
        Success  bool                   `json:"success"`
        Data     json.RawMessage        `json:"data,omitempty"`
        Error    string                 `json:"error,omitempty"`
        Metadata map[string]interface{} `json:"metadata,omitempty"`
}

// Command-specific payload structures for the 8 system commands
type CollectionRequest struct {
        CollectorTypes []string `json:"collector_types,omitempty"`
        Force          bool     `json:"force,omitempty"`
        Comprehensive  bool     `json:"comprehensive,omitempty"`
        Timeout        int      `json:"timeout,omitempty"`
}

type UpdateRequest struct {
        Version     string `json:"version,omitempty"`
        Force       bool   `json:"force,omitempty"`
        Immediate   bool   `json:"immediate,omitempty"`
        DownloadURL string `json:"download_url,omitempty"`
}

type RestartRequest struct {
        Delay    int    `json:"delay,omitempty"`
        Reason   string `json:"reason,omitempty"`
        Graceful bool   `json:"graceful,omitempty"`
}

// NewWebSocketService creates a new WebSocket service instance
func (c *Client) NewWebSocketService() (*WebSocketServiceImpl, error) <span class="cov10" title="28">{
        if c.config.Auth.ServerUUID == "" || c.config.Auth.ServerSecret == "" </span><span class="cov5" title="5">{
                return nil, fmt.Errorf("WebSocket service requires server authentication credentials")
        }</span>

        <span class="cov9" title="23">ctx, cancel := context.WithCancel(context.Background())
        
        ws := &amp;WebSocketServiceImpl{
                client:           c,
                pendingResponses: make(map[string]chan *WSCommandResponse),
                timeout:          30 * time.Second,
                reconnectDelay:   5 * time.Second,
                maxReconnects:    5,
                ctx:              ctx,
                cancel:           cancel,
        }

        return ws, nil</span>
}

// Connect establishes a WebSocket connection to the API
func (ws *WebSocketServiceImpl) Connect() error <span class="cov5" title="6">{
        ws.mu.Lock()
        defer ws.mu.Unlock()

        if ws.connected </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov5" title="5">if ws.connecting </span><span class="cov0" title="0">{
                return fmt.Errorf("connection already in progress")
        }</span>

        <span class="cov5" title="5">ws.connecting = true
        defer func() </span><span class="cov5" title="5">{ ws.connecting = false }</span>()

        // Build WebSocket URL
        <span class="cov5" title="5">wsURL := ws.buildWebSocketURL()

        // Create WebSocket connection
        dialer := websocket.DefaultDialer
        conn, _, err := dialer.Dial(wsURL, nil)
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to connect to WebSocket: %w", err)
        }</span>

        <span class="cov4" title="4">ws.conn = conn
        ws.connected = true

        // Authenticate
        if err := ws.authenticate(); err != nil </span><span class="cov0" title="0">{
                // Close connection on authentication failure
                if closeErr := ws.conn.Close(); closeErr != nil </span><span class="cov0" title="0">{
                        // Log but don't fail - we're already in an error state
                        // Silently ignore close error as we're already in error state
                        _ = closeErr
                }</span>
                <span class="cov0" title="0">ws.conn = nil
                ws.connected = false
                return fmt.Errorf("authentication failed: %w", err)</span>
        }

        // Start message handling
        <span class="cov4" title="4">go ws.handleMessages()
        go ws.pingHandler()

        if ws.onConnect != nil </span><span class="cov1" title="1">{
                ws.onConnect()
        }</span>

        <span class="cov4" title="4">return nil</span>
}

// Disconnect closes the WebSocket connection
func (ws *WebSocketServiceImpl) Disconnect() error <span class="cov5" title="6">{
        ws.mu.Lock()
        defer ws.mu.Unlock()

        if !ws.connected || ws.conn == nil </span><span class="cov2" title="2">{
                return nil
        }</span>

        // Cancel context to stop goroutines
        <span class="cov4" title="4">ws.cancel()

        // Close connection
        err := ws.conn.Close()
        ws.conn = nil
        ws.connected = false

        // Clean up pending responses
        ws.responseMutex.Lock()
        for id, ch := range ws.pendingResponses </span><span class="cov0" title="0">{
                select </span>{
                case ch &lt;- &amp;WSCommandResponse{
                        Success: false,
                        Error:   "connection closed",
                }:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">close(ch)
                delete(ws.pendingResponses, id)</span>
        }
        <span class="cov4" title="4">ws.responseMutex.Unlock()

        if ws.onDisconnect != nil </span><span class="cov1" title="1">{
                ws.onDisconnect(err)
        }</span>

        <span class="cov4" title="4">return err</span>
}

// IsConnected returns whether the WebSocket connection is active
func (ws *WebSocketServiceImpl) IsConnected() bool <span class="cov5" title="6">{
        ws.mu.RLock()
        defer ws.mu.RUnlock()
        return ws.connected
}</span>

// =============================================================================
// System Command Methods
// =============================================================================

// RunCollection triggers a metrics collection run on the agent
func (ws *WebSocketServiceImpl) RunCollection(ctx context.Context, serverUUID string, req *CollectionRequest) (*WSCommandResponse, error) <span class="cov2" title="2">{
        if req == nil </span><span class="cov1" title="1">{
                req = &amp;CollectionRequest{}
        }</span>
        <span class="cov2" title="2">return ws.sendCommand(ctx, serverUUID, "run_collection", req)</span>
}

// ForceCollection forces an immediate comprehensive metrics collection
func (ws *WebSocketServiceImpl) ForceCollection(ctx context.Context, serverUUID string, req *CollectionRequest) (*WSCommandResponse, error) <span class="cov2" title="2">{
        if req == nil </span><span class="cov1" title="1">{
                req = &amp;CollectionRequest{Force: true, Comprehensive: true}
        }</span> else<span class="cov1" title="1"> {
                req.Force = true
                req.Comprehensive = true
        }</span>
        <span class="cov2" title="2">return ws.sendCommand(ctx, serverUUID, "force_collection", req)</span>
}

// UpdateAgent triggers an agent update
func (ws *WebSocketServiceImpl) UpdateAgent(ctx context.Context, serverUUID string, req *UpdateRequest) (*WSCommandResponse, error) <span class="cov2" title="2">{
        if req == nil </span><span class="cov1" title="1">{
                req = &amp;UpdateRequest{}
        }</span>
        <span class="cov2" title="2">return ws.sendCommand(ctx, serverUUID, "update_agent", req)</span>
}

// CheckUpdates checks for available agent updates
func (ws *WebSocketServiceImpl) CheckUpdates(ctx context.Context, serverUUID string) (*WSCommandResponse, error) <span class="cov1" title="1">{
        return ws.sendCommand(ctx, serverUUID, "check_updates", map[string]interface{}{})
}</span>

// RestartAgent restarts the agent service
func (ws *WebSocketServiceImpl) RestartAgent(ctx context.Context, serverUUID string, req *RestartRequest) (*WSCommandResponse, error) <span class="cov2" title="2">{
        if req == nil </span><span class="cov1" title="1">{
                req = &amp;RestartRequest{}
        }</span>
        <span class="cov2" title="2">return ws.sendCommand(ctx, serverUUID, "restart_agent", req)</span>
}

// GracefulRestart performs a graceful restart of the agent
func (ws *WebSocketServiceImpl) GracefulRestart(ctx context.Context, serverUUID string, req *RestartRequest) (*WSCommandResponse, error) <span class="cov2" title="2">{
        if req == nil </span><span class="cov1" title="1">{
                req = &amp;RestartRequest{Graceful: true}
        }</span> else<span class="cov1" title="1"> {
                req.Graceful = true
        }</span>
        <span class="cov2" title="2">return ws.sendCommand(ctx, serverUUID, "graceful_restart", req)</span>
}

// AgentHealth requests agent health status
func (ws *WebSocketServiceImpl) AgentHealth(ctx context.Context, serverUUID string) (*WSCommandResponse, error) <span class="cov2" title="2">{
        return ws.sendCommand(ctx, serverUUID, "agent_health", map[string]interface{}{})
}</span>

// SystemStatus requests system status information
func (ws *WebSocketServiceImpl) SystemStatus(ctx context.Context, serverUUID string) (*WSCommandResponse, error) <span class="cov1" title="1">{
        return ws.sendCommand(ctx, serverUUID, "system_status", map[string]interface{}{})
}</span>

// =============================================================================
// Event Handlers
// =============================================================================

// OnConnect sets the connection callback
func (ws *WebSocketServiceImpl) OnConnect(fn func()) <span class="cov2" title="2">{
        ws.onConnect = fn
}</span>

// OnDisconnect sets the disconnection callback
func (ws *WebSocketServiceImpl) OnDisconnect(fn func(error)) <span class="cov2" title="2">{
        ws.onDisconnect = fn
}</span>

// OnMessage sets the message callback for handling non-command messages
func (ws *WebSocketServiceImpl) OnMessage(fn func(*WSMessage)) <span class="cov2" title="2">{
        ws.onMessage = fn
}</span>

// SetTimeout configures the command timeout duration
func (ws *WebSocketServiceImpl) SetTimeout(timeout time.Duration) <span class="cov1" title="1">{
        ws.timeout = timeout
}</span>

// SetReconnectDelay configures the delay between reconnection attempts
func (ws *WebSocketServiceImpl) SetReconnectDelay(delay time.Duration) <span class="cov1" title="1">{
        ws.reconnectDelay = delay
}</span>

// SetMaxReconnects configures the maximum number of reconnection attempts
func (ws *WebSocketServiceImpl) SetMaxReconnects(max int) <span class="cov1" title="1">{
        ws.maxReconnects = max
}</span>

// =============================================================================
// Private Methods
// =============================================================================

// buildWebSocketURL constructs the WebSocket URL from the base URL
func (ws *WebSocketServiceImpl) buildWebSocketURL() string <span class="cov6" title="8">{
        baseURL := ws.client.config.BaseURL
        if len(baseURL) &gt; 4 &amp;&amp; baseURL[:4] == "http" </span><span class="cov2" title="2">{
                if baseURL[:5] == "https" </span><span class="cov1" title="1">{
                        baseURL = "wss" + baseURL[5:]
                }</span> else<span class="cov1" title="1"> {
                        baseURL = "ws" + baseURL[4:]
                }</span>
        }
        <span class="cov6" title="8">return fmt.Sprintf("%s/v1/agent/websocket", baseURL)</span>
}

// authenticate sends authentication message to the WebSocket server
func (ws *WebSocketServiceImpl) authenticate() error <span class="cov4" title="4">{
        authPayload := WSAuthPayload{
                ServerUUID:      ws.client.config.Auth.ServerUUID,
                ServerSecret:    ws.client.config.Auth.ServerSecret,
                AgentVersion:    "sdk-" + Version,
                ProtocolVersion: WSProtocolVersion, // "1.0"
                Capabilities:    []string{"commands", "responses"},
                // OrganizationID is omitted (0 value) - determined server-side
        }

        payloadBytes, err := json.Marshal(authPayload)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="4">msg := WSMessage{
                Type:      WSTypeAuth,
                Timestamp: time.Now().Unix(),
                Payload:   payloadBytes,
        }

        if err := ws.conn.WriteJSON(msg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Wait for auth response
        <span class="cov4" title="4">if err := ws.conn.SetReadDeadline(time.Now().Add(10 * time.Second)); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set read deadline: %w", err)
        }</span>
        <span class="cov4" title="4">var response WSMessage
        if err := ws.conn.ReadJSON(&amp;response); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="4">if response.Type != WSTypeAuthResponse </span><span class="cov0" title="0">{
                return fmt.Errorf("expected auth response, got %s", response.Type)
        }</span>

        <span class="cov4" title="4">var authResp WSAuthResponsePayload
        if err := json.Unmarshal(response.Payload, &amp;authResp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov4" title="4">if authResp.Status != "success" </span><span class="cov0" title="0">{
                return fmt.Errorf("authentication failed: %s", authResp.Error)
        }</span>

        // Clear read deadline
        <span class="cov4" title="4">if err := ws.conn.SetReadDeadline(time.Time{}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to clear read deadline: %w", err)
        }</span>
        <span class="cov4" title="4">return nil</span>
}

// sendCommand sends a command and waits for response with correlation ID
func (ws *WebSocketServiceImpl) sendCommand(ctx context.Context, serverUUID, command string, payload interface{}) (*WSCommandResponse, error) <span class="cov8" title="14">{
        if !ws.connected </span><span class="cov5" title="6">{
                return nil, fmt.Errorf("not connected to WebSocket")
        }</span>

        // Generate correlation ID
        <span class="cov6" title="8">correlationID := generateCorrelationID()

        // Create response channel
        responseChan := make(chan *WSCommandResponse, 1)
        
        // Store pending response
        ws.responseMutex.Lock()
        ws.pendingResponses[correlationID] = responseChan
        ws.responseMutex.Unlock()

        // Clean up on exit
        defer func() </span><span class="cov6" title="8">{
                ws.responseMutex.Lock()
                delete(ws.pendingResponses, correlationID)
                ws.responseMutex.Unlock()
                close(responseChan)
        }</span>()

        // Marshal command payload
        <span class="cov6" title="8">payloadBytes, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create command payload
        <span class="cov6" title="8">commandPayload := WSCommandPayload{
                Command: command,
                Payload: payloadBytes,
        }

        cmdPayloadBytes, err := json.Marshal(commandPayload)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Send command message
        <span class="cov6" title="8">msg := WSMessage{
                Type:      WSTypeCommand,
                ID:        correlationID,
                Timestamp: time.Now().Unix(),
                Payload:   cmdPayloadBytes,
        }

        ws.mu.RLock()
        if ws.conn == nil </span><span class="cov0" title="0">{
                ws.mu.RUnlock()
                return nil, fmt.Errorf("connection closed")
        }</span>
        <span class="cov6" title="8">err = ws.conn.WriteJSON(msg)
        ws.mu.RUnlock()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Wait for response
        <span class="cov6" title="8">select </span>{
        case response := &lt;-responseChan:<span class="cov6" title="8">
                return response, nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return nil, ctx.Err()</span>
        case &lt;-time.After(ws.timeout):<span class="cov0" title="0">
                return nil, fmt.Errorf("command timeout after %v", ws.timeout)</span>
        }
}

// handleMessages processes incoming WebSocket messages
func (ws *WebSocketServiceImpl) handleMessages() <span class="cov4" title="4">{
        defer func() </span><span class="cov4" title="4">{
                ws.mu.Lock()
                ws.connected = false
                ws.mu.Unlock()
        }</span>()

        <span class="cov4" title="4">for </span><span class="cov7" title="12">{
                select </span>{
                case &lt;-ws.ctx.Done():<span class="cov2" title="2">
                        return</span>
                default:<span class="cov7" title="10">
                        var msg WSMessage
                        if err := ws.conn.ReadJSON(&amp;msg); err != nil </span><span class="cov2" title="2">{
                                if ws.onDisconnect != nil &amp;&amp; ws.connected </span><span class="cov1" title="1">{
                                        ws.onDisconnect(err)
                                }</span>
                                <span class="cov2" title="2">return</span>
                        }

                        <span class="cov6" title="8">switch msg.Type </span>{
                        case WSTypeCommandResponse:<span class="cov6" title="8">
                                ws.handleCommandResponse(&amp;msg)</span>
                        case WSTypePing:<span class="cov0" title="0">
                                // Send pong response
                                if err := ws.sendPong(); err != nil </span><span class="cov0" title="0">{
                                        // Connection likely broken, trigger disconnect
                                        if ws.onDisconnect != nil &amp;&amp; ws.connected </span><span class="cov0" title="0">{
                                                ws.onDisconnect(err)
                                        }</span>
                                        <span class="cov0" title="0">return</span>
                                }
                        case WSTypePong:<span class="cov0" title="0"></span>
                                // Pong received, connection is alive
                        default:<span class="cov0" title="0">
                                if ws.onMessage != nil </span><span class="cov0" title="0">{
                                        ws.onMessage(&amp;msg)
                                }</span>
                        }
                }
        }
}

// handleCommandResponse processes command response messages
func (ws *WebSocketServiceImpl) handleCommandResponse(msg *WSMessage) <span class="cov6" title="8">{
        if msg.ID == "" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="8">ws.responseMutex.RLock()
        responseChan, exists := ws.pendingResponses[msg.ID]
        ws.responseMutex.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov6" title="8">var response WSCommandResponse
        if err := json.Unmarshal(msg.Payload, &amp;response); err != nil </span><span class="cov0" title="0">{
                response = WSCommandResponse{
                        Success: false,
                        Error:   fmt.Sprintf("Failed to parse response: %v", err),
                }
        }</span>

        <span class="cov6" title="8">select </span>{
        case responseChan &lt;- &amp;response:<span class="cov6" title="8"></span>
        default:<span class="cov0" title="0"></span>
                // Channel is full or closed
        }
}

// pingHandler sends periodic ping messages
func (ws *WebSocketServiceImpl) pingHandler() <span class="cov4" title="4">{
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for </span><span class="cov4" title="4">{
                select </span>{
                case &lt;-ws.ctx.Done():<span class="cov4" title="4">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := ws.sendPing(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// sendPing sends a ping message
func (ws *WebSocketServiceImpl) sendPing() error <span class="cov0" title="0">{
        ws.mu.RLock()
        defer ws.mu.RUnlock()

        if !ws.connected || ws.conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">msg := WSMessage{
                Type:      WSTypePing,
                Timestamp: time.Now().Unix(),
        }

        return ws.conn.WriteJSON(msg)</span>
}

// sendPong sends a pong message
func (ws *WebSocketServiceImpl) sendPong() error <span class="cov0" title="0">{
        ws.mu.RLock()
        defer ws.mu.RUnlock()

        if !ws.connected || ws.conn == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("not connected")
        }</span>

        <span class="cov0" title="0">msg := WSMessage{
                Type:      WSTypePong,
                Timestamp: time.Now().Unix(),
        }

        return ws.conn.WriteJSON(msg)</span>
}

// generateCorrelationID generates a unique correlation ID for commands
func generateCorrelationID() string <span class="cov7" title="10">{
        return fmt.Sprintf("sdk-%d-%d", time.Now().UnixNano(), time.Now().Nanosecond()%1000)
}</pre>
		
		<pre class="file" id="file66" style="display: none">package nexmonyx

import (
        "context"
        "fmt"
        "log"
        "time"
)

// Example: Basic WebSocket connection and command execution
func ExampleWebSocketService_basic() <span class="cov0" title="0">{
        // Create client with server credentials
        config := &amp;Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
        }

        client, err := NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        // Initialize WebSocket service
        <span class="cov0" title="0">wsService, err := client.NewWebSocketService()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create WebSocket service: %v", err)
        }</span>

        // Set up event handlers
        <span class="cov0" title="0">wsService.OnConnect(func() </span><span class="cov0" title="0">{
                fmt.Println("WebSocket connected successfully")
        }</span>)

        <span class="cov0" title="0">wsService.OnDisconnect(func(err error) </span><span class="cov0" title="0">{
                fmt.Printf("WebSocket disconnected: %v\n", err)
        }</span>)

        // Connect to WebSocket
        <span class="cov0" title="0">if err := wsService.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer wsService.Disconnect()

        // Send a command
        ctx := context.Background()
        serverUUID := "target-server-uuid"

        response, err := wsService.AgentHealth(ctx, serverUUID)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Command failed: %v", err)
        }</span>

        <span class="cov0" title="0">if response.Success </span><span class="cov0" title="0">{
                fmt.Printf("Agent health check successful: %s\n", string(response.Data))
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("Agent health check failed: %s\n", response.Error)
        }</span>
}

// Example: Running metrics collection
func ExampleWebSocketService_RunCollection() <span class="cov0" title="0">{
        config := &amp;Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
        }

        client, err := NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">wsService, err := client.NewWebSocketService()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create WebSocket service: %v", err)
        }</span>

        <span class="cov0" title="0">if err := wsService.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer wsService.Disconnect()

        // Run collection with specific parameters
        collectionReq := &amp;CollectionRequest{
                CollectorTypes: []string{"cpu", "memory", "network"},
                Comprehensive:  false,
                Timeout:        30,
        }

        ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
        defer cancel()

        response, err := wsService.RunCollection(ctx, "target-server-uuid", collectionReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Collection failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Collection result: success=%v, data=%s\n", 
                response.Success, string(response.Data))</span>
}

// Example: Force collection (immediate comprehensive metrics)
func ExampleWebSocketService_ForceCollection() <span class="cov0" title="0">{
        config := &amp;Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
        }

        client, err := NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">wsService, err := client.NewWebSocketService()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create WebSocket service: %v", err)
        }</span>

        <span class="cov0" title="0">if err := wsService.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer wsService.Disconnect()

        // Force comprehensive collection
        collectionReq := &amp;CollectionRequest{
                CollectorTypes: []string{"all"}, // Collect all available metrics
                Timeout:        60,              // Allow more time for comprehensive collection
        }

        ctx, cancel := context.WithTimeout(context.Background(), 90*time.Second)
        defer cancel()

        response, err := wsService.ForceCollection(ctx, "target-server-uuid", collectionReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Force collection failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Force collection result: success=%v\n", response.Success)
        if response.Metadata != nil </span><span class="cov0" title="0">{
                if execTime, ok := response.Metadata["execution_time_ms"].(float64); ok </span><span class="cov0" title="0">{
                        fmt.Printf("Execution time: %.0fms\n", execTime)
                }</span>
        }
}

// Example: Agent update
func ExampleWebSocketService_UpdateAgent() <span class="cov0" title="0">{
        config := &amp;Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
        }

        client, err := NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">wsService, err := client.NewWebSocketService()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create WebSocket service: %v", err)
        }</span>

        <span class="cov0" title="0">if err := wsService.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer wsService.Disconnect()

        // Update agent to specific version
        updateReq := &amp;UpdateRequest{
                Version:   "2.1.5",
                Force:     false,
                Immediate: false,
        }

        ctx, cancel := context.WithTimeout(context.Background(), 120*time.Second)
        defer cancel()

        response, err := wsService.UpdateAgent(ctx, "target-server-uuid", updateReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Agent update failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Agent update result: success=%v\n", response.Success)
        if !response.Success </span><span class="cov0" title="0">{
                fmt.Printf("Update error: %s\n", response.Error)
        }</span>
}

// Example: Graceful agent restart
func ExampleWebSocketService_GracefulRestart() <span class="cov0" title="0">{
        config := &amp;Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
        }

        client, err := NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">wsService, err := client.NewWebSocketService()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create WebSocket service: %v", err)
        }</span>

        <span class="cov0" title="0">if err := wsService.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer wsService.Disconnect()

        // Graceful restart with delay
        restartReq := &amp;RestartRequest{
                Delay:  5,                         // 5 second delay
                Reason: "Scheduled maintenance",   // Reason for restart
        }

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        response, err := wsService.GracefulRestart(ctx, "target-server-uuid", restartReq)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Graceful restart failed: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Graceful restart initiated: success=%v\n", response.Success)</span>
}

// Example: System status check
func ExampleWebSocketService_SystemStatus() <span class="cov0" title="0">{
        config := &amp;Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
        }

        client, err := NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">wsService, err := client.NewWebSocketService()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create WebSocket service: %v", err)
        }</span>

        <span class="cov0" title="0">if err := wsService.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer wsService.Disconnect()

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        response, err := wsService.SystemStatus(ctx, "target-server-uuid")
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("System status failed: %v", err)
        }</span>

        <span class="cov0" title="0">if response.Success </span><span class="cov0" title="0">{
                fmt.Printf("System status: %s\n", string(response.Data))
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("System status error: %s\n", response.Error)
        }</span>
}

// Example: Batch operations with multiple servers
func ExampleWebSocketService_batch() <span class="cov0" title="0">{
        config := &amp;Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
        }

        client, err := NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">wsService, err := client.NewWebSocketService()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create WebSocket service: %v", err)
        }</span>

        <span class="cov0" title="0">if err := wsService.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer wsService.Disconnect()

        // List of target servers
        servers := []string{
                "server-uuid-1",
                "server-uuid-2",
                "server-uuid-3",
        }

        ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
        defer cancel()

        // Run health checks on all servers
        results := make(map[string]*WSCommandResponse)
        for _, serverUUID := range servers </span><span class="cov0" title="0">{
                response, err := wsService.AgentHealth(ctx, serverUUID)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Health check failed for %s: %v\n", serverUUID, err)
                        continue</span>
                }
                <span class="cov0" title="0">results[serverUUID] = response</span>
        }

        // Print results
        <span class="cov0" title="0">for serverUUID, response := range results </span><span class="cov0" title="0">{
                status := "FAILED"
                if response.Success </span><span class="cov0" title="0">{
                        status = "OK"
                }</span>
                <span class="cov0" title="0">fmt.Printf("Server %s: %s\n", serverUUID, status)</span>
        }
}

// Example: Advanced usage with custom message handling
func ExampleWebSocketService_advanced() <span class="cov0" title="0">{
        config := &amp;Config{
                BaseURL: "https://api.nexmonyx.com",
                Auth: AuthConfig{
                        ServerUUID:   "your-server-uuid",
                        ServerSecret: "your-server-secret",
                },
                Debug: true, // Enable debug logging
        }

        client, err := NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create client: %v", err)
        }</span>

        <span class="cov0" title="0">wsService, err := client.NewWebSocketService()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to create WebSocket service: %v", err)
        }</span>

        // Set up comprehensive event handlers
        <span class="cov0" title="0">wsService.OnConnect(func() </span><span class="cov0" title="0">{
                fmt.Println(" WebSocket connected successfully")
        }</span>)

        <span class="cov0" title="0">wsService.OnDisconnect(func(err error) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf(" WebSocket disconnected with error: %v\n", err)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println(" WebSocket disconnected gracefully")
                }</span>
        })

        <span class="cov0" title="0">wsService.OnMessage(func(msg *WSMessage) </span><span class="cov0" title="0">{
                switch msg.Type </span>{
                case WSTypeUpdateProgress:<span class="cov0" title="0">
                        fmt.Printf(" Update progress: %s\n", string(msg.Payload))</span>
                case WSTypeError:<span class="cov0" title="0">
                        fmt.Printf(" WebSocket error: %s\n", string(msg.Payload))</span>
                default:<span class="cov0" title="0">
                        fmt.Printf(" Received message: type=%s, id=%s\n", msg.Type, msg.ID)</span>
                }
        })

        <span class="cov0" title="0">if err := wsService.Connect(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to connect: %v", err)
        }</span>
        <span class="cov0" title="0">defer wsService.Disconnect()

        // Keep connection alive and handle messages
        fmt.Println("WebSocket service is running. Press Ctrl+C to exit.")
        
        // In a real application, you would handle shutdown signals properly
        time.Sleep(60 * time.Second)</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
